# Theoretical Concepts: Repository Pattern

## 1. What is the Repository Pattern?

The **Repository Pattern** provides an **abstraction layer** between the domain/business logic and data access.

**Key Principle**: Encapsulate data access logic in a separate layer

### Without Repository Pattern

```csharp
// Business logic directly uses database
public class CreateTankHandler
{
    private readonly DbContext _context;
    
    public async Task Handle(CreateTankCommand command)
    {
        // ❌ Business logic knows about database
        var tank = new Tank { Name = command.Name };
        _context.Tanks.Add(tank);
        await _context.SaveChangesAsync();
    }
}
```

### With Repository Pattern

```csharp
// Business logic uses repository interface
public class CreateTankHandler
{
    private readonly ITankRepository _repository;
    
    public async Task Handle(CreateTankCommand command)
    {
        // ✅ Business logic doesn't know about database
        var tank = Tank.Create(command.Name, ...);
        await _repository.AddAsync(tank);
        await _unitOfWork.SaveChangesAsync();
    }
}
```

---

## 2. Why Repository Pattern?

### Benefits

**1. Abstraction**:
- Business logic doesn't know about database
- Can change database without changing business logic
- Testable (can mock repository)

**2. Separation of Concerns**:
- Business logic: What to do
- Repository: How to persist
- Clear boundaries

**3. Testability**:
- Mock repository in tests
- Test business logic without database
- Fast unit tests

**4. Flexibility**:
- Can use different databases
- Can use different storage mechanisms
- Easy to swap implementations

---

## 3. Repository Interface

### Interface Definition

**Repository Interface** (in Application/Domain layer):
```csharp
public interface ITankRepository
{
    Task<Tank?> GetByIdAsync(TankId id, CancellationToken ct = default);
    Task<Tank?> GetByNameAsync(string name, CancellationToken ct = default);
    Task AddAsync(Tank tank, CancellationToken ct = default);
    Task UpdateAsync(Tank tank, CancellationToken ct = default);
    Task DeleteAsync(Tank tank, CancellationToken ct = default);
}
```

**Key Points**:
- Interface in Application/Domain layer
- Uses domain types (Tank, TankId)
- No database-specific types
- Business-focused methods

---

## 4. Repository Implementation

### Implementation (in Infrastructure layer)

```csharp
public class TankRepository : ITankRepository
{
    private readonly IEventStore _eventStore;
    private readonly ReadModelDbContext _readContext;
    
    public async Task<Tank?> GetByIdAsync(TankId id, CancellationToken ct)
    {
        // Load from event store
        var snapshot = await _eventStore.GetSnapshotAsync<Tank>(id.Value, ct);
        var events = await _eventStore.GetEventsAsync(id.Value, snapshot?.Version ?? 0, ct);
        
        // Rebuild aggregate from events
        var tank = RebuildAggregate(snapshot, events);
        return tank;
    }
    
    public async Task AddAsync(Tank tank, CancellationToken ct)
    {
        var events = tank.DomainEvents;
        await _eventStore.SaveEventsAsync<Tank>(tank.Id.Value, events, 0, ct);
        tank.ClearDomainEvents();
    }
}
```

**Key Points**:
- Implementation in Infrastructure layer
- Knows about event store, database
- Converts between domain and persistence
- Handles event sourcing logic

---

## 5. Repository with Event Sourcing

### Event-Sourced Repository

**Traditional Repository**:
- Loads entity from database
- Saves entity to database
- Simple CRUD operations

**Event-Sourced Repository**:
- Loads events from event store
- Rebuilds aggregate from events
- Saves events to event store
- More complex but powerful

### Loading Aggregate

```csharp
public async Task<Tank?> GetByIdAsync(TankId id, CancellationToken ct)
{
    // 1. Try to load snapshot
    var snapshot = await _eventStore.GetSnapshotAsync<Tank>(id.Value, ct);
    var fromVersion = snapshot?.Version ?? 0;
    
    // 2. Load events since snapshot
    var events = await _eventStore.GetEventsAsync(id.Value, fromVersion, ct);
    
    // 3. Rebuild aggregate
    if (snapshot != null)
    {
        // Start from snapshot
        var tank = snapshot;
        // Apply events since snapshot
        foreach (var evt in events)
        {
            ApplyEvent(tank, evt);
        }
        return tank;
    }
    else if (events.Any())
    {
        // Rebuild from events only
        return RebuildFromEvents(events);
    }
    
    return null;
}
```

### Saving Aggregate

```csharp
public async Task AddAsync(Tank tank, CancellationToken ct)
{
    // 1. Get domain events
    var events = tank.DomainEvents;
    
    // 2. Save events to event store
    await _eventStore.SaveEventsAsync<Tank>(
        tank.Id.Value, 
        events, 
        expectedVersion: 0,  // New aggregate
        ct);
    
    // 3. Clear events (they're now persisted)
    tank.ClearDomainEvents();
}
```

---

## 6. Unit of Work Pattern

### What is Unit of Work?

**Unit of Work** manages **transactions** and **coordination** between repositories.

**Purpose**:
- Ensures all changes are saved together
- Manages transactions
- Coordinates multiple repositories
- Publishes domain events

### Unit of Work Implementation

```csharp
public class UnitOfWork : IUnitOfWork
{
    private readonly EventStoreDbContext _eventStoreContext;
    private readonly ReadModelDbContext _readModelContext;
    private readonly IMediator _mediator;
    
    public async Task<int> SaveChangesAsync(CancellationToken ct)
    {
        using var transaction = await _eventStoreContext.Database.BeginTransactionAsync(ct);
        
        try
        {
            // 1. Save event store changes
            var eventStoreResult = await _eventStoreContext.SaveChangesAsync(ct);
            
            // 2. Save read model changes
            var readModelResult = await _readModelContext.SaveChangesAsync(ct);
            
            // 3. Publish domain events
            await PublishDomainEventsAsync(ct);
            
            // 4. Commit transaction
            await transaction.CommitAsync(ct);
            
            return eventStoreResult + readModelResult;
        }
        catch
        {
            await transaction.RollbackAsync(ct);
            throw;
        }
    }
}
```

---

## 7. Repository Best Practices

### ✅ Do

1. **Use Interfaces**: Define repository interfaces
2. **Domain Types**: Use domain types in interface
3. **Async Methods**: Use async/await
4. **Cancellation Tokens**: Accept CancellationToken
5. **Clear Methods**: Method names should be clear
6. **Single Responsibility**: One repository per aggregate

### ❌ Don't

1. **Don't Expose Database**: Hide database details
2. **Don't Return DTOs**: Return domain entities
3. **Don't Mix Concerns**: Keep business logic out
4. **Don't Skip Transactions**: Use Unit of Work
5. **Don't Ignore Errors**: Handle errors properly

---

## 8. Repository vs Direct Database Access

### Direct Database Access

```csharp
// ❌ Business logic knows about database
public class CreateTankHandler
{
    private readonly DbContext _context;
    
    public async Task Handle(CreateTankCommand command)
    {
        var tank = new TankEntity
        {
            Name = command.Name,
            Status = "Inactive"
        };
        _context.Tanks.Add(tank);
        await _context.SaveChangesAsync();
    }
}
```

**Problems**:
- Business logic coupled to database
- Hard to test
- Hard to change database
- Database concerns leak into business logic

### Repository Pattern

```csharp
// ✅ Business logic uses repository
public class CreateTankHandler
{
    private readonly ITankRepository _repository;
    private readonly IUnitOfWork _unitOfWork;
    
    public async Task Handle(CreateTankCommand command)
    {
        var tank = Tank.Create(command.Name, ...);
        await _repository.AddAsync(tank);
        await _unitOfWork.SaveChangesAsync();
    }
}
```

**Benefits**:
- Business logic decoupled from database
- Easy to test (mock repository)
- Easy to change database
- Clear separation of concerns

---

## 9. Real-World Analogy

Think of **Repository** like a **warehouse manager**:

**Without Repository**:
- You go directly to warehouse
- You need to know warehouse layout
- You handle storage yourself
- Complex and error-prone

**With Repository**:
- You talk to warehouse manager
- Manager handles storage details
- You just say "store this" or "get that"
- Simple and clean

**Key Points**:
- Repository is the interface (warehouse manager)
- Implementation handles details (warehouse operations)
- You don't need to know how storage works
- Easy to change storage without affecting you

---

## 10. Summary

**Repository Pattern**:
- Abstraction layer for data access
- Separates business logic from database
- Uses interfaces for flexibility
- Enables testing and maintainability

**Key Components**:
- Repository Interface (in Application/Domain)
- Repository Implementation (in Infrastructure)
- Unit of Work (transaction management)

**Key Takeaway**: Repository pattern provides a clean abstraction for data access. It separates business logic from database concerns, making code more testable, maintainable, and flexible. Use repositories to encapsulate data access logic and keep business logic clean.

