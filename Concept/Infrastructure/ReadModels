# Theoretical Concepts: Read Models (CQRS Read Side)

## 1. What are Read Models?

**Read Models** are **optimized data structures** designed specifically for **querying and reading** data, separate from the write-side event store.

**Key Principle**: Different models for reading and writing

### CQRS Separation

```
Write Side (Commands)          Read Side (Queries)
    ↓                                ↓
Event Store                    Read Models
(Domain Events)                (Optimized Views)
    ↓                                ↓
Slow to query                  Fast to query
Complete history               Current state
Event sourcing                 Denormalized
```

---

## 2. Why Read Models?

### Problem: Event Store is Slow for Queries

**Event Store**:
- Optimized for appending events
- Not optimized for complex queries
- Need to replay events to get current state
- Slow for filtering, sorting, pagination

**Example Problem**:
```
Query: "Get all active tanks in Building A"
- Load all tank aggregates from event store
- Replay all events for each tank
- Filter by status and building
- Very slow! ❌
```

### Solution: Read Models

**Read Models**:
- Optimized for queries
- Denormalized (all data in one place)
- Fast filtering, sorting, pagination
- Pre-computed views

**Example Solution**:
```
Query: "Get all active tanks in Building A"
- Query read model table
- Simple SQL: WHERE Status = 'Active' AND Building = 'A'
- Very fast! ✅
```

---

## 3. Read Model Structure

### Denormalized Design

**Read Models are Denormalized**:
- All needed data in one place
- No joins required (usually)
- Optimized for specific queries
- Can duplicate data

**Example: TankReadModel**
```csharp
public class TankReadModel
{
    public Guid Id { get; set; }
    public string Name { get; set; }
    public decimal Capacity { get; set; }
    public string CapacityUnit { get; set; }
    public string Building { get; set; }      // ← Denormalized
    public string Room { get; set; }           // ← Denormalized
    public string TankType { get; set; }       // ← Denormalized
    public string Status { get; set; }          // ← Denormalized
    public DateTime CreatedAt { get; set; }
    // ... all fields needed for queries
}
```

**Why Denormalized?**:
- Fast queries (no joins)
- Simple filtering
- Easy pagination
- Optimized indexes

---

## 4. How Read Models are Updated

### Projection Pattern

**Read Models are Updated by Projecting Events**:

```
1. Domain event occurs
   └─> TankActivatedEvent raised
   
2. Event saved to Event Store
   └─> Event persisted
   
3. Projection handler receives event
   └─> TankProjectionHandler.Handle(TankActivatedEvent)
   
4. Read model updated
   └─> tankReadModel.Status = "Active"
   └─> tankReadModel.UpdatedAt = event.OccurredOn
   └─> Save to ReadModel database
```

### Projection Handler Example

```csharp
public class TankProjectionHandler : INotificationHandler<TankActivatedEvent>
{
    public async Task Handle(TankActivatedEvent notification, CancellationToken ct)
    {
        // Load read model
        var tank = await _context.Tanks
            .FirstOrDefaultAsync(t => t.Id == notification.TankId.Value, ct);
        
        if (tank != null)
        {
            // Update read model from event
            tank.Status = "Active";
            tank.UpdatedAt = notification.OccurredOn;
            tank.Version++;
            
            await _context.SaveChangesAsync(ct);
        }
    }
}
```

---

## 5. Read Model Benefits

### 1. Performance

**Fast Queries**:
- Optimized indexes
- Denormalized structure
- No event replay needed
- Simple SQL queries

### 2. Scalability

**Independent Scaling**:
- Read models can be on separate database
- Can have read replicas
- Can use different database type
- Scale reads independently from writes

### 3. Flexibility

**Multiple Read Models**:
- Different read models for different queries
- Optimized for specific use cases
- Can change without affecting writes

### 4. Simplicity

**Simple Queries**:
- No complex event replay
- Standard SQL queries
- Easy to understand
- Easy to optimize

---

## 6. Read Model Patterns

### Pattern 1: Single Read Model

**One read model for all queries**:
```
TankReadModel
- Contains all tank data
- Used for all tank queries
- Simple but may not be optimal for all queries
```

### Pattern 2: Multiple Read Models

**Different read models for different queries**:
```
TankListReadModel      - For listing tanks
TankDetailReadModel    - For tank details
TankStatisticsReadModel - For statistics
```

### Pattern 3: Materialized Views

**Pre-computed views**:
```
ActiveTanksView        - Only active tanks
TanksByLocationView    - Grouped by location
TankMaintenanceView    - Maintenance information
```

---

## 7. Read Model Consistency

### Eventual Consistency

**Read Models are Eventually Consistent**:
- Events are saved first (write side)
- Read models updated after (read side)
- Small delay between write and read update
- Usually acceptable for most queries

**Timeline**:
```
T1: Command executed → Event saved
T2: Event published
T3: Projection handler updates read model
T4: Query sees updated data

Delay: T4 - T1 (usually milliseconds)
```

### Handling Inconsistency

**Strategies**:

**1. Accept Delay**:
- Most queries don't need immediate consistency
- Small delay is acceptable

**2. Read from Event Store**:
- For critical queries, read from event store
- Slower but consistent

**3. Wait for Projection**:
- Wait for projection to complete
- Synchronous projection (slower)

---

## 8. Read Model Design

### Design Principles

**1. Denormalize**:
- Include all needed data
- Avoid joins when possible
- Duplicate data if needed

**2. Optimize for Queries**:
- Add indexes for common filters
- Structure for common queries
- Pre-compute aggregations

**3. Keep Simple**:
- Simple structure
- Easy to understand
- Easy to maintain

**4. Update from Events**:
- Always update from events
- Never update directly
- Single source of truth (events)

---

## 9. Real-World Analogy

Think of **Read Models** like a **restaurant menu**:

**Event Store (Write Side)**:
- Like the kitchen recipe book
- Complete history of all dishes
- Not optimized for customers to read
- Used by chefs (write operations)

**Read Models (Read Side)**:
- Like the customer menu
- Optimized for customers to read
- Shows current dishes and prices
- Easy to browse and filter
- Updated when recipes change

**Key Points**:
- Menu (read model) is derived from recipes (events)
- Menu is optimized for reading
- Menu is eventually consistent (updated when recipes change)
- Menu is denormalized (all info in one place)

---

## 10. Common Patterns

### Pattern 1: Basic Read Model

```csharp
// Read model matches aggregate structure
public class TankReadModel
{
    public Guid Id { get; set; }
    public string Name { get; set; }
    public string Status { get; set; }
    // ... matches Tank aggregate
}
```

### Pattern 2: Flattened Read Model

```csharp
// Flatten nested structures
public class TankReadModel
{
    public Guid Id { get; set; }
    public string Name { get; set; }
    public string Building { get; set; }      // ← Flattened from Location
    public string Room { get; set; }           // ← Flattened from Location
    public decimal Capacity { get; set; }      // ← Flattened from TankCapacity
    public string CapacityUnit { get; set; }  // ← Flattened from TankCapacity
}
```

### Pattern 3: Aggregated Read Model

```csharp
// Pre-computed aggregations
public class TankStatisticsReadModel
{
    public Guid TankId { get; set; }
    public int TotalSensorReadings { get; set; }
    public decimal AverageTemperature { get; set; }
    public DateTime LastReadingDate { get; set; }
}
```

---

## 11. Summary

**Read Models**:
- Optimized data structures for queries
- Separate from write-side event store
- Denormalized for performance
- Updated by projecting events

**Benefits**:
- Fast queries
- Scalable reads
- Flexible design
- Simple to query

**Key Takeaway**: Read models provide fast, optimized querying by maintaining denormalized views of data. They're updated asynchronously from events, providing eventual consistency. Use read models when you need fast queries and can accept eventual consistency.

