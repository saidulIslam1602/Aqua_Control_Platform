# Theoretical Concepts: CQRS (Command Query Responsibility Segregation)

## 1. What is CQRS?

**CQRS (Command Query Responsibility Segregation)** is an architectural pattern that separates read operations (queries) from write operations (commands).

**Key Principle**: 
- **Commands** change state (write operations)
- **Queries** read state (read operations)
- They are handled **separately** and can have **different models**

### Traditional Approach (CRUD)
```
Controller → Service → Repository → Database
  ↓
Same model for read and write
```

### CQRS Approach
```
Commands (Write)          Queries (Read)
    ↓                          ↓
Command Handler          Query Handler
    ↓                          ↓
Domain Model            Read Model/DTO
    ↓                          ↓
Event Store/DB          Read Database/View
```

---

## 2. Why Use CQRS?

### Problem: Single Model for Everything

**Without CQRS**:
- Same model used for reading and writing
- Read operations need to load entire aggregates
- Write operations expose read-specific properties
- Performance issues (loading unnecessary data)
- Complex queries affect write performance

### Solution: Separate Models

**With CQRS**:
- ✅ Commands use domain models (rich, validated)
- ✅ Queries use DTOs (optimized for reading)
- ✅ Read and write can scale independently
- ✅ Different databases for read/write (optional)
- ✅ Optimized for each use case

---

## 3. Commands vs Queries

### Commands (Write Operations)

**Characteristics**:
- **Intent**: Express what you want to **do**
- **Return**: Usually `Result` or `Result<TId>` (success/failure)
- **Side Effects**: Changes state in the system
- **Validation**: Business rules enforced
- **Example**: `CreateTankCommand`, `UpdateTankCommand`, `DeleteTankCommand`

**Naming Convention**:
- Past tense verbs: `CreateTank`, `UpdateTank`, `ActivateTank`
- Clear intent: What action to perform

### Queries (Read Operations)

**Characteristics**:
- **Intent**: Express what you want to **know**
- **Return**: Data (DTOs, collections, single objects)
- **Side Effects**: None (read-only)
- **Optimization**: Can use views, caches, denormalized data
- **Example**: `GetTanksQuery`, `GetTankByIdQuery`, `GetTankStatisticsQuery`

**Naming Convention**:
- Question format: `GetTanks`, `GetTankById`, `FindTanksByLocation`
- Clear question: What data to retrieve

---

## 4. CQRS in AquaCulture Platform

### Command Example: CreateTankCommand

```csharp
// Command - expresses intent to create a tank
public record CreateTankCommand(
    string Name,
    decimal Capacity,
    string CapacityUnit,
    TankType TankType
) : ICommand<Guid>;

// Handler - executes the command
public class CreateTankCommandHandler : ICommandHandler<CreateTankCommand, Guid>
{
    public async Task<Result<Guid>> Handle(CreateTankCommand command, CancellationToken ct)
    {
        // 1. Validate business rules
        // 2. Create domain aggregate
        // 3. Save to database
        // 4. Return result
    }
}
```

**Flow**:
1. Command received (from API/UI)
2. Handler validates and executes
3. Domain aggregate created
4. Events raised
5. State persisted
6. Result returned

### Query Example: GetTanksQuery

```csharp
// Query - expresses intent to get tanks
public record GetTanksQuery(
    int Page = 1,
    int PageSize = 10,
    string? SearchTerm = null
) : IQuery<PagedResult<TankDto>>;

// Handler - executes the query
public class GetTanksQueryHandler : IQueryHandler<GetTanksQuery, PagedResult<TankDto>>
{
    public async Task<Result<PagedResult<TankDto>>> Handle(GetTanksQuery query, CancellationToken ct)
    {
        // 1. Build specification/filter
        // 2. Query read model (optimized)
        // 3. Map to DTOs
        // 4. Return data
    }
}
```

**Flow**:
1. Query received (from API/UI)
2. Handler builds filter
3. Reads from optimized read model
4. Maps to DTOs
5. Returns data (no state changes)

---

## 5. Benefits of CQRS

### 1. Separation of Concerns
- Commands handle business logic
- Queries handle data retrieval
- Clear boundaries

### 2. Performance Optimization
- Read models optimized for queries
- Write models optimized for validation
- Can use different databases

### 3. Scalability
- Read and write can scale independently
- Read replicas for queries
- Write database for commands

### 4. Flexibility
- Change read model without affecting writes
- Change write model without affecting reads
- Easy to add new queries

### 5. Maintainability
- Clear intent (command vs query)
- Easier to test
- Easier to understand

---

## 6. When to Use CQRS

### ✅ Good Candidates

**Use CQRS when**:
- Read and write patterns differ significantly
- High read/write ratio (many reads, few writes)
- Complex queries affecting write performance
- Need for different data models
- Event sourcing (natural fit)
- Microservices architecture

### ❌ Not Always Needed

**Avoid CQRS when**:
- Simple CRUD operations
- Small applications
- Read and write patterns are similar
- Overhead not justified

---

## 7. CQRS with MediatR

### MediatR Integration

**MediatR** provides the infrastructure for CQRS:
- Commands implement `ICommand<TResponse>`
- Queries implement `IQuery<TResponse>`
- Handlers implement `ICommandHandler` or `IQueryHandler`
- Automatic routing and dependency injection

**Example**:
```csharp
// Send command
var result = await _mediator.Send(new CreateTankCommand(...));

// Send query
var tanks = await _mediator.Send(new GetTanksQuery(...));
```

---

## 8. Real-World Analogy

Think of CQRS like a **restaurant**:

**Commands (Kitchen)**:
- Receive orders (commands)
- Prepare food (execute business logic)
- Change state (food is now ready)
- Return result (order complete)

**Queries (Menu/Display)**:
- Show menu (read data)
- Display specials (read optimized views)
- No state changes
- Just information

**Separation**:
- Kitchen doesn't need to know about menu display
- Menu doesn't need to know about cooking process
- Each optimized for its purpose

---

## 9. Common Patterns

### Pattern 1: Command with Result
```csharp
public record CreateTankCommand(...) : ICommand<Guid>;
// Returns the ID of created tank
```

### Pattern 2: Command without Result
```csharp
public record UpdateTankCommand(...) : ICommand;
// Just success/failure
```

### Pattern 3: Query with Filters
```csharp
public record GetTanksQuery(
    int Page,
    string? SearchTerm
) : IQuery<PagedResult<TankDto>>;
```

### Pattern 4: Query by ID
```csharp
public record GetTankByIdQuery(Guid Id) : IQuery<TankDto>;
```

---

## 10. Summary

**CQRS** separates:
- **Commands**: Write operations that change state
- **Queries**: Read operations that retrieve data

**Benefits**:
- Clear separation of concerns
- Performance optimization
- Independent scaling
- Flexibility

**Key Takeaway**: Use CQRS when read and write patterns differ significantly. It provides clear boundaries and optimization opportunities, but adds complexity - use it when the benefits justify the overhead.

