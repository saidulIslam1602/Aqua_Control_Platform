# Theoretical Concepts: Result Pattern

## 1. What is the Result Pattern?

The **Result Pattern** is a functional programming pattern that explicitly represents **success or failure** instead of throwing exceptions.

**Key Characteristics**:
- **Explicit**: Success/failure is part of the return type
- **Type-Safe**: Compiler enforces error handling
- **No Exceptions**: Errors are values, not exceptions
- **Composable**: Can chain operations
- **Functional**: Follows functional programming principles

### Traditional Approach (Exceptions)
```csharp
public Tank GetTank(Guid id)
{
    var tank = _repository.GetById(id);
    if (tank == null)
        throw new NotFoundException("Tank not found"); // ❌ Exception
    
    return tank;
}
```

### Result Pattern Approach
```csharp
public Result<Tank> GetTank(Guid id)
{
    var tank = _repository.GetById(id);
    if (tank == null)
        return Error.NotFound("Tank.NotFound", "Tank not found"); // ✅ Error value
    
    return Result.Success(tank);
}
```

---

## 2. Why Use Result Pattern?

### Problem: Exceptions for Control Flow

**Issues with Exceptions**:
- Exceptions are expensive (stack unwinding)
- Exceptions are for exceptional cases, not business logic
- Easy to forget to handle exceptions
- No type safety (compiler doesn't enforce handling)
- Exceptions break normal flow

### Solution: Explicit Error Handling

**Benefits of Result Pattern**:
- ✅ Errors are explicit in return type
- ✅ Compiler enforces error handling
- ✅ No performance overhead
- ✅ Errors are values (can be passed around)
- ✅ Composable (can chain operations)

---

## 3. Result Structure

### Basic Result Classes

```csharp
// Result without value (just success/failure)
public class Result
{
    public bool IsSuccess { get; }
    public bool IsFailure => !IsSuccess;
    public Error Error { get; }
    
    public static Result Success() => new(true, Error.None);
    public static Result Failure(Error error) => new(false, error);
}

// Result with value
public class Result<TValue> : Result
{
    public TValue Value { get; } // Only accessible if IsSuccess
    
    public static Result<TValue> Success(TValue value) => new(value, true, Error.None);
    public static Result<TValue> Failure(Error error) => new(default, false, error);
}
```

### Error Model

```csharp
public sealed record Error(string Code, string Description, ErrorType Type)
{
    public static Error NotFound(string code, string description) =>
        new(code, description, ErrorType.NotFound);
    
    public static Error Validation(string code, string description) =>
        new(code, description, ErrorType.Validation);
}

public enum ErrorType
{
    None = 0,
    Validation = 1,
    NotFound = 2,
    Conflict = 3,
    Failure = 4
}
```

---

## 4. Using Result Pattern

### Example: Command Handler

```csharp
public async Task<Result<Guid>> Handle(
    CreateTankCommand command, 
    CancellationToken ct)
{
    // Check if exists
    var existing = await _repository.GetByNameAsync(command.Name, ct);
    if (existing != null)
    {
        return Error.Conflict("Tank.Exists", "Tank already exists");
    }
    
    // Create tank
    var tank = Tank.Create(command.Name, ...);
    await _repository.AddAsync(tank, ct);
    await _unitOfWork.SaveChangesAsync(ct);
    
    // Return success
    return Result.Success(tank.Id.Value);
}
```

### Example: Using Result

```csharp
// Call handler
var result = await _mediator.Send(new CreateTankCommand(...));

// Check result
if (result.IsSuccess)
{
    var tankId = result.Value; // ✅ Access value
    return Ok(tankId);
}
else
{
    // Handle error
    return BadRequest(result.Error.Description);
}
```

---

## 5. Error Types

### Error Categories

**Validation Error**:
- Input validation failed
- Business rule violation
- Example: "Name is required", "Capacity must be positive"

**NotFound Error**:
- Resource doesn't exist
- Example: "Tank with ID 123 not found"

**Conflict Error**:
- Business rule conflict
- Example: "Tank with this name already exists"

**Failure Error**:
- Unexpected error
- System error
- Example: "Database connection failed"

---

## 6. Implicit Conversions

### Convenient Conversions

```csharp
// Implicit conversion from Error to Result
Result result = Error.NotFound("Tank.NotFound", "Not found");
// Equivalent to: Result.Failure(Error.NotFound(...))

// Implicit conversion from TValue to Result<TValue>
Result<Guid> result = Guid.NewGuid();
// Equivalent to: Result.Success(Guid.NewGuid())

// Implicit conversion from Error to Result<TValue>
Result<Guid> result = Error.NotFound("Tank.NotFound", "Not found");
// Equivalent to: Result.Failure<Guid>(Error.NotFound(...))
```

---

## 7. Result Pattern Benefits

### 1. Type Safety

**Compiler Enforces**:
- Must check IsSuccess before accessing Value
- Cannot ignore errors
- Clear error handling

### 2. Performance

**No Exception Overhead**:
- No stack unwinding
- No performance penalty
- Fast error handling

### 3. Explicit Errors

**Clear Intent**:
- Errors are part of the contract
- Easy to see what can fail
- Self-documenting

### 4. Composable

**Chain Operations**:
```csharp
var result = await GetTank(id)
    .Then(tank => UpdateTank(tank, ...))
    .Then(updated => SaveTank(updated));
```

---

## 8. Real-World Analogy

Think of **Result Pattern** like a **vending machine**:

**Traditional (Exceptions)**:
- Put in money
- Press button
- **Exception thrown** if out of stock (unexpected)
- Machine breaks (exception handling needed)

**Result Pattern**:
- Put in money
- Press button
- **Result returned**: Success(soda) or Failure("Out of stock")
- Handle result explicitly (no surprises)

**Key Points**:
- Result is explicit (you know it can fail)
- Result is a value (can be passed around)
- Result is type-safe (compiler helps)
- Result is predictable (no surprises)

---

## 9. Common Patterns

### Pattern 1: Check and Return

```csharp
if (condition)
    return Error.Validation("Error.Code", "Error message");

return Result.Success(value);
```

### Pattern 2: Try-Catch to Result

```csharp
try
{
    var result = await DoSomething();
    return Result.Success(result);
}
catch (Exception ex)
{
    return Error.Failure("Error.Code", ex.Message);
}
```

### Pattern 3: Chain Results

```csharp
var result = await GetTank(id);
if (result.IsFailure)
    return result; // Propagate error

var tank = result.Value;
// Continue with tank...
```

---

## 10. Best Practices

### ✅ Do

1. **Always Return Result**: Use Result for operations that can fail
2. **Use Error Types**: Categorize errors appropriately
3. **Check IsSuccess**: Always check before accessing Value
4. **Propagate Errors**: Return errors from called methods
5. **Use Error Codes**: Use codes for programmatic handling

### ❌ Don't

1. **Don't Throw Exceptions**: Use Result instead
2. **Don't Ignore Errors**: Always handle failures
3. **Don't Access Value Directly**: Check IsSuccess first
4. **Don't Use Generic Errors**: Be specific
5. **Don't Mix Patterns**: Don't mix exceptions and Results

---

## 11. Summary

**Result Pattern** provides:
- **Explicit error handling** (errors are values)
- **Type safety** (compiler enforces handling)
- **Performance** (no exception overhead)
- **Composability** (can chain operations)

**Structure**:
- `Result` - Success/failure without value
- `Result<TValue>` - Success/failure with value
- `Error` - Error information
- `ErrorType` - Error categories

**Key Takeaway**: Use Result Pattern to make errors explicit and type-safe. Errors become values that can be handled predictably, without the performance and complexity overhead of exceptions.

