# Frontend Implementation Patterns

## 1. Application Initialization

### Main Entry Point (main.ts)

The application entry point sets up all global configurations:

```typescript
// Element Plus integration
app.use(ElementPlus)

// Register all Element Plus icons
for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
  app.component(key, component)
}

// Global error handler
app.config.errorHandler = (err, instance, info) => {
  console.error('Global error:', err, info)
}
```

**Key Responsibilities**:
- Initialize Vue app
- Setup Pinia store with persistence plugin
- Configure Vue Router
- Register Element Plus UI library
- Setup global error handling

### Root Component (App.vue)

The root component manages application-level concerns:

**Features**:
- Authentication wrapper (shows LoginView or AppLayout)
- Loading overlay during initialization
- Global notification container
- Real-time connection status indicator
- Global error handling for unhandled promise rejections

**Initialization Flow**:
1. Initialize authentication store
2. Connect to SignalR if authenticated
3. Setup global error handlers
4. Show main application

---

## 2. Authentication Flow

### Authentication Store (authStore.ts)

**State**:
- `token`: JWT authentication token
- `user`: Current user information
- `isAuthenticated`: Authentication status

**Methods**:
- `login()`: Authenticate user and store token
- `logout()`: Clear authentication state
- `initialize()`: Check existing authentication on app start
- `refreshToken()`: Refresh expired tokens

**Persistence**:
- Uses `pinia-plugin-persistedstate` to persist auth state in localStorage

### Login View (LoginView.vue)

**Features**:
- Form validation with Element Plus
- Username and password input
- Loading state during authentication
- Error handling and user feedback
- Enter key support for form submission

### Router Guards

**Authentication Guard**:
```typescript
router.beforeEach(async (to, from, next) => {
  const authStore = useAuthStore()
  
  // Check authentication for protected routes
  if (to.meta.requiresAuth && !authStore.isAuthenticated) {
    // Redirect handled by App.vue showing LoginView
    next({ name: 'Dashboard' })
    return
  }
  
  next()
})
```

**Page Title Management**:
- Automatically sets document title based on route meta
- Format: `{Page Title} - AquaControl`

---

## 3. Layout Architecture

### AppLayout Component

**Structure**:
- **Sidebar**: Collapsible navigation menu
- **Header**: User menu, sidebar toggle, app branding
- **Main Content**: Router view for page content

**Navigation Menu**:
- Dashboard
- Tanks
- Sensors
- Analytics
- Settings

**Features**:
- Responsive sidebar (collapsible)
- Active route highlighting
- User dropdown menu (profile, settings, logout)
- Real-time connection status integration

---

## 4. State Management Patterns

### Store Structure

**Pinia Store Pattern**:
```typescript
export const useTankStore = defineStore('tanks', () => {
  // State (ref/reactive)
  const tanks = ref<Tank[]>([])
  const state = ref<StoreState>({ loading: false, error: null })
  
  // Getters (computed)
  const activeTanks = computed(() => 
    tanks.value.filter(tank => tank.status === 'Active')
  )
  
  // Actions (functions)
  const fetchTanks = async () => {
    state.value.loading = true
    try {
      // API call
    } finally {
      state.value.loading = false
    }
  }
  
  return { tanks, state, activeTanks, fetchTanks }
})
```

### Optimistic Updates

**Pattern**:
1. Immediately update UI with expected result
2. Make API call in background
3. Replace optimistic data with real response
4. Rollback on error

**Example**:
```typescript
const createTank = async (command: CreateTankCommand) => {
  // 1. Optimistic update
  const tempId = `temp-${Date.now()}`
  tanks.value.unshift(optimisticTank)
  
  // 2. API call
  try {
    const response = await tankService.createTank(command)
    // 3. Replace with real data
    tanks.value[index] = response.data
  } catch (error) {
    // 4. Rollback on error
    rollback()
  }
}
```

---

## 5. Real-time Communication

### Real-time Store (realTimeStore.ts)

**Connection Management**:
- `connect()`: Establish SignalR connection
- `disconnect()`: Close connection
- `isConnected`: Connection status
- `isConnecting`: Connection state (Connecting/Reconnecting)

**Event Subscription**:
```typescript
// Subscribe to events
realTimeStore.subscribe('TankUpdates', (event) => {
  // Handle real-time update
})

// Unsubscribe
realTimeStore.unsubscribe('TankUpdates', handler)
```

**Connection States**:
- `Disconnected`: No connection
- `Connecting`: Establishing connection
- `Connected`: Active connection
- `Reconnecting`: Automatic reconnection in progress
- `Disconnecting`: Closing connection

### Connection Status Component

**Features**:
- Visual indicator (green/yellow/red)
- Tooltip with connection status
- Click to reconnect when disconnected
- Pulse animation when connecting

---

## 6. Notification System

### Notification Store (notificationStore.ts)

**Features**:
- Queue management for notifications
- Auto-removal after duration
- Multiple notification types (success, error, warning, info)
- Timestamp tracking

### Notification Container Component

**Features**:
- Fixed position (top-right)
- Transition animations
- Auto-dismiss after duration
- Manual close support
- Stack multiple notifications

---

## 7. Routing Patterns

### Route Configuration

**Lazy Loading**:
```typescript
const DashboardView = () => import('@/views/dashboard/DashboardView.vue')
```

**Route Meta**:
```typescript
{
  path: '/tanks',
  name: 'Tanks',
  component: TanksView,
  meta: { 
    requiresAuth: true, 
    title: 'Tanks' 
  }
}
```

**Route Props**:
```typescript
{
  path: '/tanks/:id',
  props: true  // Pass route params as props
}
```

### Navigation Guards

**Before Each Guard**:
- Check authentication
- Set page title
- Handle redirects

**Scroll Behavior**:
- Restore scroll position on back navigation
- Scroll to top on new route

---

## 8. Composables

### useDebouncedRef

**Purpose**: Debounce reactive values for search inputs

**Usage**:
```typescript
const { debouncedValue, setValue } = useDebouncedRef('', 300)

// Update value
setValue('search term')

// Use debounced value
watch(debouncedValue, (value) => {
  // Perform search after 300ms delay
})
```

**Benefits**:
- Reduces API calls
- Better performance
- Improved UX

---

## 9. Component Communication

### Props Down, Events Up

**Parent to Child**:
```vue
<!-- Parent -->
<TankCard :tank="tank" @edit="handleEdit" />
```

**Child to Parent**:
```vue
<!-- Child -->
<script setup>
const emit = defineEmits<{
  edit: [tank: Tank]
}>()

const handleClick = () => {
  emit('edit', props.tank)
}
</script>
```

### Provide/Inject

**Global Services**:
```typescript
// App.vue
provide('notificationService', notificationStore)

// Child component
const notificationService = inject('notificationService')
```

---

## 10. Error Handling

### Global Error Handler

**Unhandled Promise Rejections**:
```typescript
window.addEventListener('unhandledrejection', (event) => {
  notificationStore.addNotification({
    type: 'error',
    title: 'Application Error',
    message: 'An unexpected error occurred.'
  })
})
```

### Component Error Handling

**Try-Catch in Actions**:
```typescript
const fetchTanks = async () => {
  try {
    // API call
  } catch (error) {
    notificationStore.addNotification({
      type: 'error',
      title: 'Failed to load tanks',
      message: error.message
    })
  }
}
```

---

## 11. Best Practices

### Component Organization

**File Structure**:
```
src/
  components/
    common/        # Shared components
    layout/        # Layout components
    tank/          # Feature-specific components
  views/           # Page components
  stores/          # Pinia stores
  composables/     # Reusable logic
  services/        # API services
  types/           # TypeScript types
```

### TypeScript Usage

**Type Safety**:
- Define interfaces for all data structures
- Type component props and emits
- Type store state and actions
- Use type inference where possible

### Performance Optimization

**Lazy Loading**:
- Route-based code splitting
- Component lazy loading
- Dynamic imports

**Reactivity**:
- Use `ref` for primitives
- Use `reactive` for objects
- Use `computed` for derived state
- Avoid unnecessary reactivity

---

## 12. Summary

**Frontend Implementation Patterns**:

1. **Application Setup**: Element Plus, Pinia, Router in main.ts
2. **Authentication**: Store-based auth with router guards
3. **Layout**: AppLayout with sidebar and header
4. **State Management**: Pinia stores with optimistic updates
5. **Real-time**: SignalR integration with connection management
6. **Notifications**: Global notification system
7. **Routing**: Lazy-loaded routes with authentication guards
8. **Composables**: Reusable logic functions
9. **Error Handling**: Global and component-level error handling
10. **TypeScript**: Full type safety throughout

**Key Takeaway**: The frontend follows Vue.js 3 best practices with Composition API, Pinia for state management, Element Plus for UI components, and comprehensive error handling. The architecture supports optimistic updates, real-time communication, and provides excellent developer and user experience.

