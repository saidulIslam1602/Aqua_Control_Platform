# Theoretical Concepts: Vue.js 3 Architecture

## 1. What is Vue.js 3?

**Vue.js 3** is a progressive JavaScript framework for building user interfaces, known for its **reactivity system**, **component-based architecture**, and **developer-friendly API**.

**Key Features**:
- **Reactive Data**: Automatic UI updates when data changes
- **Component-Based**: Reusable, composable components
- **Composition API**: Flexible way to organize component logic
- **Performance**: Fast rendering with virtual DOM
- **TypeScript Support**: Full TypeScript support

---

## 2. Vue.js 3 Architecture Layers

### Presentation Layer (Components, Views, Layouts)

**Components**:
- Reusable UI pieces (buttons, forms, cards)
- Atomic design (atoms, molecules, organisms)
- Self-contained with props and events

**Views**:
- Full pages (TankList, TankDetail)
- Route-based components
- Composed of multiple components

**Layouts**:
- Shell components (AppLayout, DashboardLayout)
- Common structure for multiple views
- Navigation, headers, footers

### Application Layer (Composables, Stores, Services)

**Composables**:
- Reusable logic functions
- Share stateful logic between components
- Use Composition API

**Stores (Pinia)**:
- Global state management
- Centralized data storage
- Reactive state updates

**Services**:
- API communication
- Business logic
- External integrations

### Infrastructure Layer (HTTP Client, WebSockets, Storage)

**HTTP Client**:
- Axios for API calls
- Request/response interceptors
- Error handling

**WebSockets (SignalR)**:
- Real-time communication
- Event subscriptions
- Connection management

**Storage**:
- LocalStorage/SessionStorage
- IndexedDB
- Cache management

---

## 3. Composition API

### What is Composition API?

**Composition API** is a way to organize component logic using **functions** instead of **options**.

**Traditional Options API**:
```javascript
export default {
  data() {
    return {
      count: 0
    }
  },
  methods: {
    increment() {
      this.count++
    }
  }
}
```

**Composition API**:
```javascript
import { ref } from 'vue'

export default {
  setup() {
    const count = ref(0)
    
    const increment = () => {
      count.value++
    }
    
    return {
      count,
      increment
    }
  }
}
```

### Benefits

**1. Better Organization**:
- Related logic grouped together
- Easier to understand
- Better code splitting

**2. Reusability**:
- Logic extracted to composables
- Share between components
- Test independently

**3. TypeScript Support**:
- Better type inference
- Type safety
- IDE support

---

## 4. Reactivity System

### How Reactivity Works

**Vue's Reactivity** automatically updates the UI when data changes.

**Reactive References**:
```javascript
import { ref, reactive } from 'vue'

// ref for primitives
const count = ref(0)
count.value++  // UI updates automatically

// reactive for objects
const state = reactive({
  name: 'Tank A',
  status: 'Active'
})
state.name = 'Tank B'  // UI updates automatically
```

**Computed Properties**:
```javascript
import { computed } from 'vue'

const activeTanks = computed(() => 
  tanks.value.filter(t => t.status === 'Active')
)
// Automatically recalculates when tanks changes
```

**Watchers**:
```javascript
import { watch } from 'vue'

watch(() => tank.value.status, (newStatus) => {
  console.log('Status changed:', newStatus)
})
```

---

## 5. Component Communication

### Props Down, Events Up

**Props (Parent → Child)**:
```vue
<!-- Parent -->
<TankCard :tank="selectedTank" />

<!-- Child -->
<template>
  <div>{{ tank.name }}</div>
</template>
<script setup>
defineProps<{
  tank: Tank
}>()
</script>
```

**Events (Child → Parent)**:
```vue
<!-- Child -->
<button @click="$emit('update', newData)">Update</button>

<!-- Parent -->
<TankCard @update="handleUpdate" />
```

### Provide/Inject (Deep Communication)

**Provide (Ancestor)**:
```javascript
provide('tankStore', tankStore)
```

**Inject (Descendant)**:
```javascript
const tankStore = inject('tankStore')
```

---

## 6. State Management with Pinia

### What is Pinia?

**Pinia** is Vue's official state management library, replacing Vuex.

**Why Pinia?**:
- Simpler API
- Better TypeScript support
- DevTools integration
- Modular stores

### Store Structure

```typescript
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export const useTankStore = defineStore('tanks', () => {
  // State
  const tanks = ref<Tank[]>([])
  
  // Getters (computed)
  const activeTanks = computed(() => 
    tanks.value.filter(t => t.status === 'Active')
  )
  
  // Actions
  const fetchTanks = async () => {
    // Fetch logic
  }
  
  return {
    tanks,
    activeTanks,
    fetchTanks
  }
})
```

### Using Stores

```vue
<script setup>
import { useTankStore } from '@stores/tankStore'

const tankStore = useTankStore()

// Access state
console.log(tankStore.tanks)

// Use getters
console.log(tankStore.activeTanks)

// Call actions
await tankStore.fetchTanks()
</script>
```

---

## 7. Routing with Vue Router

### Route Configuration

```typescript
import { createRouter, createWebHistory } from 'vue-router'

const routes = [
  {
    path: '/tanks',
    name: 'Tanks',
    component: () => import('@views/TankList.vue')
  },
  {
    path: '/tanks/:id',
    name: 'TankDetail',
    component: () => import('@views/TankDetail.vue')
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})
```

### Navigation

```vue
<script setup>
import { useRouter, useRoute } from 'vue-router'

const router = useRouter()
const route = useRoute()

// Navigate
router.push('/tanks/123')

// Get params
const tankId = route.params.id
</script>
```

---

## 8. HTTP Client Pattern

### Axios Configuration

```typescript
import axios from 'axios'

const client = axios.create({
  baseURL: 'http://api.example.com',
  timeout: 30000
})

// Request interceptor
client.interceptors.request.use((config) => {
  config.headers.Authorization = `Bearer ${token}`
  return config
})

// Response interceptor
client.interceptors.response.use(
  (response) => response,
  (error) => {
    // Handle errors
    return Promise.reject(error)
  }
)
```

### Service Layer

```typescript
export class TankService {
  async getTanks(): Promise<Tank[]> {
    const response = await httpClient.get('/api/tanks')
    return response.data
  }
  
  async createTank(command: CreateTankCommand): Promise<Tank> {
    const response = await httpClient.post('/api/tanks', command)
    return response.data
  }
}
```

---

## 9. Real-time Communication

### SignalR Integration

```typescript
import * as signalR from '@microsoft/signalr'

const connection = new signalR.HubConnectionBuilder()
  .withUrl('/hubs/tanks')
  .withAutomaticReconnect()
  .build()

// Connect
await connection.start()

// Subscribe to events
connection.on('TankUpdated', (data) => {
  // Update UI
})

// Send messages
await connection.invoke('JoinGroup', 'tank-updates')
```

---

## 10. Optimistic Updates

### What are Optimistic Updates?

**Optimistic Updates** show UI changes immediately, before server confirmation.

**Benefits**:
- Instant feedback
- Better UX
- Perceived performance

**Implementation**:
```typescript
const createTank = async (command: CreateTankCommand) => {
  // 1. Optimistically add to UI
  const tempTank = { id: 'temp', ...command }
  tanks.value.push(tempTank)
  
  // 2. Save rollback function
  const rollback = () => {
    const index = tanks.value.findIndex(t => t.id === 'temp')
    tanks.value.splice(index, 1)
  }
  
  try {
    // 3. Call API
    const response = await tankService.createTank(command)
    
    // 4. Replace temp with real
    const index = tanks.value.findIndex(t => t.id === 'temp')
    tanks.value[index] = response.data
  } catch (error) {
    // 5. Rollback on error
    rollback()
  }
}
```

---

## 11. Performance Optimization

### Code Splitting

**Lazy Loading Routes**:
```typescript
{
  path: '/tanks',
  component: () => import('@views/TankList.vue')  // Lazy loaded
}
```

**Dynamic Imports**:
```typescript
const HeavyComponent = defineAsyncComponent(() => 
  import('@components/HeavyComponent.vue')
)
```

### Virtual Scrolling

**For Large Lists**:
```vue
<VirtualList
  :items="tanks"
  :item-height="100"
>
  <template #default="{ item }">
    <TankCard :tank="item" />
  </template>
</VirtualList>
```

### Memoization

**Computed Properties**:
```typescript
const expensiveCalculation = computed(() => {
  // Only recalculates when dependencies change
  return heavyCalculation(tanks.value)
})
```

---

## 12. TypeScript Integration

### Type Safety

**Component Props**:
```typescript
interface Props {
  tank: Tank
  editable?: boolean
}

defineProps<Props>()
```

**Store Types**:
```typescript
export const useTankStore = defineStore('tanks', () => {
  const tanks = ref<Tank[]>([])
  // TypeScript knows tanks is Tank[]
})
```

**API Types**:
```typescript
interface ApiResponse<T> {
  data: T
  success: boolean
}

const response: ApiResponse<Tank> = await httpClient.get('/api/tanks/1')
// TypeScript knows response.data is Tank
```

---

## 13. Summary

**Vue.js 3 Architecture**:

**Key Concepts**:
- **Composition API**: Organize logic with functions
- **Reactivity**: Automatic UI updates
- **Components**: Reusable UI pieces
- **Pinia**: State management
- **Vue Router**: Navigation
- **TypeScript**: Type safety

**Best Practices**:
- Use Composition API for complex components
- Extract logic to composables
- Use Pinia for global state
- Implement optimistic updates
- Optimize with code splitting
- Use TypeScript for type safety

**Key Takeaway**: Vue.js 3 provides a flexible, performant framework for building modern web applications. The Composition API, Pinia, and TypeScript integration create a powerful, maintainable architecture for enterprise applications.

