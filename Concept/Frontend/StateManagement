# Theoretical Concepts: State Management with Pinia

## 1. What is State Management?

**State Management** is the practice of **centralizing application state** and managing how it changes over time.

**Problem Without State Management**:
- State scattered across components
- Difficult to share data
- Hard to track changes
- Prop drilling (passing props through many components)

**Solution: Centralized State**:
- Single source of truth
- Easy to share between components
- Predictable state updates
- Better debugging

---

## 2. Why Pinia?

### Pinia vs Vuex

**Pinia** is Vue's official state management library, designed to replace Vuex.

**Advantages**:
- **Simpler API**: Less boilerplate
- **TypeScript**: Better type inference
- **DevTools**: Built-in support
- **Modular**: Multiple stores
- **Composition API**: Native support

---

## 3. Store Structure

### Basic Store

```typescript
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export const useTankStore = defineStore('tanks', () => {
  // State (reactive refs)
  const tanks = ref<Tank[]>([])
  const selectedTank = ref<Tank | null>(null)
  const loading = ref(false)
  
  // Getters (computed)
  const activeTanks = computed(() => 
    tanks.value.filter(t => t.status === 'Active')
  )
  
  // Actions (functions)
  const fetchTanks = async () => {
    loading.value = true
    try {
      const response = await tankService.getTanks()
      tanks.value = response.data
    } finally {
      loading.value = false
    }
  }
  
  return {
    // State
    tanks,
    selectedTank,
    loading,
    // Getters
    activeTanks,
    // Actions
    fetchTanks
  }
})
```

---

## 4. State (Reactive Data)

### Using ref()

**ref()** creates reactive references for primitive values or objects.

```typescript
// Primitive
const count = ref(0)
count.value++  // Reactive

// Array
const tanks = ref<Tank[]>([])
tanks.value.push(newTank)  // Reactive

// Object
const state = ref({
  loading: false,
  error: null
})
state.value.loading = true  // Reactive
```

### Using reactive()

**reactive()** creates reactive objects (for objects only).

```typescript
const state = reactive({
  tanks: [],
  selectedTank: null,
  loading: false
})

state.tanks.push(newTank)  // Reactive (no .value needed)
```

**Note**: Prefer `ref()` for flexibility, use `reactive()` for object-only state.

---

## 5. Getters (Computed Properties)

### What are Getters?

**Getters** are **computed properties** that derive state from other state.

**Benefits**:
- Automatic caching
- Only recalculates when dependencies change
- Clean, declarative code

### Examples

```typescript
// Simple getter
const activeTanks = computed(() => 
  tanks.value.filter(t => t.status === 'Active')
)

// Complex getter
const tanksByType = computed(() => {
  const grouped = new Map<string, Tank[]>()
  tanks.value.forEach(tank => {
    const type = tank.tankType
    if (!grouped.has(type)) {
      grouped.set(type, [])
    }
    grouped.get(type)!.push(tank)
  })
  return grouped
})

// Getter with parameters (using function)
const getTankById = (id: string) => {
  return computed(() => 
    tanks.value.find(t => t.id === id)
  )
}
```

---

## 6. Actions (Methods)

### What are Actions?

**Actions** are **functions** that modify state or perform side effects.

**Types of Actions**:
- **Synchronous**: Direct state updates
- **Asynchronous**: API calls, async operations

### Synchronous Actions

```typescript
const setSelectedTank = (tank: Tank | null) => {
  selectedTank.value = tank
}

const clearError = () => {
  error.value = null
}
```

### Asynchronous Actions

```typescript
const fetchTanks = async () => {
  loading.value = true
  error.value = null
  
  try {
    const response = await tankService.getTanks()
    tanks.value = response.data
  } catch (err: any) {
    error.value = err.message
  } finally {
    loading.value = false
  }
}
```

---

## 7. Optimistic Updates

### What are Optimistic Updates?

**Optimistic Updates** update the UI **immediately**, before server confirmation.

**Flow**:
1. Update UI immediately (optimistic)
2. Call API
3. Replace optimistic data with real data
4. Rollback if error

### Implementation

```typescript
const createTank = async (command: CreateTankCommand) => {
  // 1. Create optimistic tank
  const tempId = `temp-${Date.now()}`
  const optimisticTank: Tank = {
    id: tempId,
    ...command,
    status: 'Inactive'
  }
  
  // 2. Add to UI immediately
  tanks.value.unshift(optimisticTank)
  
  // 3. Save rollback function
  const rollback = () => {
    const index = tanks.value.findIndex(t => t.id === tempId)
    if (index !== -1) {
      tanks.value.splice(index, 1)
    }
  }
  
  try {
    // 4. Call API
    const response = await tankService.createTank(command)
    const createdTank = response.data
    
    // 5. Replace optimistic with real
    const index = tanks.value.findIndex(t => t.id === tempId)
    if (index !== -1) {
      tanks.value[index] = createdTank
    }
  } catch (error) {
    // 6. Rollback on error
    rollback()
    throw error
  }
}
```

**Benefits**:
- Instant feedback
- Better UX
- Perceived performance

---

## 8. Store Composition

### Using Other Stores

**Stores can use other stores**:

```typescript
import { useNotificationStore } from './notificationStore'

export const useTankStore = defineStore('tanks', () => {
  const notificationStore = useNotificationStore()
  
  const createTank = async (command: CreateTankCommand) => {
    try {
      const tank = await tankService.createTank(command)
      
      // Use notification store
      notificationStore.addNotification({
        type: 'success',
        title: 'Tank created',
        message: `Tank "${tank.name}" created successfully`
      })
      
      return tank
    } catch (error) {
      notificationStore.addNotification({
        type: 'error',
        title: 'Failed to create tank',
        message: error.message
      })
      throw error
    }
  }
})
```

---

## 9. Persistence

### Persisting State

**Pinia Persisted State Plugin** saves state to localStorage.

```typescript
export const useTankStore = defineStore('tanks', () => {
  // ... store definition
}, {
  persist: {
    key: 'aquacontrol-tanks',
    storage: localStorage,
    paths: ['filters', 'pagination.pageSize']  // Only persist these
  }
})
```

**Benefits**:
- State survives page refresh
- Better UX
- User preferences saved

---

## 10. Real-time Updates

### Integrating with SignalR

**Stores can subscribe to real-time events**:

```typescript
import { useRealTimeStore } from './realTimeStore'
import { watch } from 'vue'

export const useTankStore = defineStore('tanks', () => {
  const realTimeStore = useRealTimeStore()
  
  const handleRealTimeUpdate = (event: RealTimeEvent) => {
    switch (event.eventType) {
      case 'TankCreated':
        if (!tanks.value.find(t => t.id === event.data.id)) {
          tanks.value.push(event.data)
        }
        break
        
      case 'TankUpdated':
        const index = tanks.value.findIndex(t => t.id === event.data.id)
        if (index !== -1) {
          tanks.value[index] = event.data
        }
        break
        
      case 'TankDeleted':
        const deleteIndex = tanks.value.findIndex(t => t.id === event.data.id)
        if (deleteIndex !== -1) {
          tanks.value.splice(deleteIndex, 1)
        }
        break
    }
  }
  
  // Subscribe when connected
  watch(() => realTimeStore.isConnected, (isConnected) => {
    if (isConnected) {
      realTimeStore.subscribe('TankUpdates', handleRealTimeUpdate)
    }
  }, { immediate: true })
})
```

---

## 11. Using Stores in Components

### Accessing Store

```vue
<script setup>
import { useTankStore } from '@stores/tankStore'

const tankStore = useTankStore()

// Access state
console.log(tankStore.tanks)

// Use getters
console.log(tankStore.activeTanks)

// Call actions
await tankStore.fetchTanks()
</script>

<template>
  <div v-if="tankStore.loading">Loading...</div>
  <div v-else>
    <TankCard 
      v-for="tank in tankStore.activeTanks" 
      :key="tank.id"
      :tank="tank"
    />
  </div>
</template>
```

### Destructuring

**⚠️ Warning**: Don't destructure reactive state directly (loses reactivity).

```typescript
// ❌ WRONG - Loses reactivity
const { tanks, loading } = useTankStore()

// ✅ CORRECT - Use storeToRefs
import { storeToRefs } from 'pinia'
const { tanks, loading } = storeToRefs(useTankStore())

// ✅ CORRECT - Use store directly
const tankStore = useTankStore()
tankStore.tanks  // Reactive
```

---

## 12. Best Practices

### ✅ Do

1. **Single Responsibility**: One store per domain
2. **Use Getters**: For derived state
3. **Async Actions**: Handle errors properly
4. **Optimistic Updates**: For better UX
5. **TypeScript**: Type everything
6. **Persistence**: Save user preferences

### ❌ Don't

1. **Don't Mutate State Directly**: Use actions
2. **Don't Store UI State**: Keep in components
3. **Don't Over-fetch**: Only load what's needed
4. **Don't Forget Error Handling**: Always handle errors
5. **Don't Store Sensitive Data**: In persisted state

---

## 13. Summary

**State Management with Pinia**:

**Key Concepts**:
- **State**: Reactive data (ref, reactive)
- **Getters**: Computed properties
- **Actions**: Functions that modify state
- **Optimistic Updates**: Instant UI feedback
- **Persistence**: Save state to localStorage
- **Real-time**: Integrate with SignalR

**Benefits**:
- Centralized state
- Predictable updates
- Better debugging
- Type safety
- Better UX

**Key Takeaway**: Pinia provides a simple, powerful way to manage application state. Use stores for global state, composables for reusable logic, and components for UI. Optimistic updates and real-time integration create a responsive, modern user experience.

