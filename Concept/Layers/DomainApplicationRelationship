# Theoretical Concepts: Domain, Application, Infrastructure, and Frontend Layer Relationships

## 1. Overview: Four Layers, One Complete System

The **Domain Layer**, **Application Layer**, **Infrastructure Layer**, and **Frontend Layer** work together to implement a complete, full-stack system, each with **different responsibilities** and **different concerns**.

**Domain Layer**:
- Contains **core business logic**
- Defines **business rules**
- Models **domain concepts**
- **Independent** of infrastructure and application

**Application Layer**:
- **Orchestrates** domain operations
- **Coordinates** between domain and infrastructure
- Implements **use cases**
- **Depends on** Domain layer
- Uses Infrastructure via interfaces

**Infrastructure Layer**:
- **Implements** data persistence
- **Provides** external service integration
- **Realizes** domain and application interfaces
- **Depends on** Domain layer (implements interfaces)
- **Depends on** Application layer (implements interfaces)

**Frontend Layer**:
- **Provides** user interface and user experience
- **Manages** client-side state and UI logic
- **Communicates** with backend via HTTP/WebSocket
- **Depends on** Backend API (Application layer)
- **Independent** of backend implementation details

---

## 2. Dependency Direction

### The Golden Rule

```
Frontend Layer → Backend API (Application Layer)
     (depends on, HTTP/WebSocket communication)
     
Application Layer → Domain Layer
     (depends on)
     
Infrastructure Layer → Domain Layer
     (depends on, implements interfaces)
     
Infrastructure Layer → Application Layer
     (depends on, implements interfaces)
```

**Key Principles**: 
- ✅ Frontend Layer **depends on** Backend API (Application layer) via HTTP/WebSocket
- ✅ Application Layer **depends on** Domain Layer
- ✅ Infrastructure Layer **depends on** Domain Layer (implements interfaces)
- ✅ Infrastructure Layer **depends on** Application Layer (implements interfaces)
- ❌ Domain Layer **never depends on** Application, Infrastructure, or Frontend layers
- ❌ Application Layer **never depends on** Infrastructure or Frontend layers directly (uses interfaces)
- ❌ Frontend Layer **never depends on** Domain or Infrastructure layers directly (uses API)
- ✅ Domain Layer has **zero dependencies** on other layers (except interfaces it defines)

### Why This Direction?

**Domain Layer is the Core**:
- Contains the most important business logic
- Should be independent and reusable
- Should not know about application concerns
- Should not know about infrastructure

**Application Layer Orchestrates**:
- Uses domain models to implement use cases
- Coordinates domain operations
- Handles application-specific concerns
- Can depend on domain (it's the foundation)

---

## 3. What Each Layer Contains

### Domain Layer Contents

```
Domain Layer
├── Aggregates (Tank, Sensor)
├── Entities (base classes)
├── Value Objects (TankCapacity, Location)
├── Domain Events (TankCreatedEvent)
├── Enums (TankType, TankStatus)
├── Business Rules (validation logic)
└── Domain Services (if needed)
```

**Characteristics**:
- Pure business logic
- No infrastructure dependencies
- No framework dependencies (except MediatR for events)
- Self-contained and testable

### Application Layer Contents

```
Application Layer
├── Commands (CreateTankCommand)
├── Queries (GetTanksQuery)
├── Handlers (CreateTankCommandHandler)
├── DTOs (TankDto)
├── Validators (FluentValidation)
├── Specifications (TankFilterSpecification)
├── Behaviors (ValidationBehavior)
└── Interfaces (ITankRepository, IUnitOfWork)
```

**Characteristics**:
- Orchestrates domain operations
- Handles application concerns
- Depends on Domain layer
- Defines interfaces for Infrastructure

### Infrastructure Layer Contents

```
Infrastructure Layer
├── Event Store (EventStoreDbContext, EventStoreRepository)
├── Read Models (ReadModelDbContext, TankReadModel)
├── Repositories (TankRepository)
├── Projections (TankProjectionHandler)
├── Unit of Work (UnitOfWork)
├── External Services (AWS, S3, SQS, SNS)
└── Database Contexts
```

**Characteristics**:
- Implements data persistence
- Provides external service integration
- Implements Domain and Application interfaces
- Depends on Domain and Application layers

### Frontend Layer Contents

```
Frontend Layer
├── Components (TankCard, TankForm)
├── Views (TankList, TankDetail)
├── Layouts (AppLayout, DashboardLayout)
├── Stores (TankStore, AuthStore, NotificationStore)
├── Services (TankService, HttpClient)
├── Composables (useTank, useAuth)
├── Router (Vue Router configuration)
└── Types (TypeScript definitions)
```

**Characteristics**:
- Provides user interface
- Manages client-side state
- Communicates with backend via API
- Independent of backend implementation

---

## 4. How They Work Together

### Example: Creating a Tank (Complete Flow)

**Step 1: Application Layer Receives Command**
```csharp
// Application Layer
public class CreateTankCommandHandler
{
    private readonly ITankRepository _repository;  // Interface from Application
    private readonly IUnitOfWork _unitOfWork;      // Interface from Application
    
    public async Task<Result<Guid>> Handle(CreateTankCommand command)
    {
        // Step 2: Application creates Domain value objects
        var capacity = TankCapacity.Create(command.Capacity, command.CapacityUnit);
        var location = Location.Create(command.Building, command.Room);
        
        // Step 3: Application calls Domain factory method
        var tank = Tank.Create(command.Name, capacity, location, command.TankType);
        // Domain validates, creates aggregate, raises TankCreatedEvent
        
        // Step 4: Application saves via repository (Infrastructure implements interface)
        await _repository.AddAsync(tank);  // Infrastructure: TankRepository.AddAsync()
        await _unitOfWork.SaveChangesAsync();  // Infrastructure: UnitOfWork.SaveChangesAsync()
        
        // Step 5: Infrastructure saves events to Event Store
        // Step 6: Infrastructure projection handler updates Read Models
        // Step 7: Application returns result
        return Result.Success(tank.Id.Value);
    }
}
```

**Step 2: Domain Layer Creates Aggregate**
```csharp
// Domain Layer
public sealed class Tank : AggregateRoot<TankId>
{
    public static Tank Create(string name, TankCapacity capacity, Location location, TankType tankType)
    {
        // Domain validates business rules
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Tank name cannot be empty");
        
        // Domain creates aggregate
        var tankId = TankId.Create();
        var tank = new Tank(tankId, name, capacity, location, tankType);
        
        // Domain raises event
        tank.Apply(new TankCreatedEvent(tankId, name, capacity, location, tankType));
        
        return tank;
    }
}
```

**Flow Diagram**:
```
Frontend Layer    Application Layer    Domain Layer    Infrastructure Layer
     │                    │                  │                  │
     │ 1. User Action     │                  │                  │
     │    Create Tank     │                  │                  │
     │    Button Click    │                  │                  │
     │         │           │                  │                  │
     │ 2. Calls Service   │                  │                  │
     │    tankService.    │                  │                  │
     │    createTank()────>│                  │                  │
     │         │           │                  │                  │
     │         │           │ 3. Receives      │                  │
     │         │           │    CreateTankCommand│              │
     │         │           │         │        │                  │
     │         │           │ 4. Creates Value Objects│          │
     │         │           │    TankCapacity.Create()──────────>│
     │         │           │    Location.Create()──────────────>│
     │         │           │         │        │                  │
     │         │           │ 5. Calls Domain Factory│            │
     │         │           │    Tank.Create()──────>│            │
     │         │           │         │        │                  │
     │         │           │         │        │ 6. Domain validates│
     │         │           │         │        │    and creates aggregate│
     │         │           │         │        │    raises TankCreatedEvent│
     │         │           │         │        │                  │
     │         │           │         │<───────│ 7. Returns Tank │
     │         │           │         │        │                  │
     │         │           │ 8. Saves via Repository│            │
     │         │           │    _repository.AddAsync()───────────>│
     │         │           │         │        │                  │
     │         │           │         │        │                  │ 9. Infrastructure saves
     │         │           │         │        │                  │    events to Event Store
     │         │           │         │        │                  │
     │         │           │ 10. Unit of Work │                  │
     │         │           │    _unitOfWork.Save()───────────────>│
     │         │           │         │        │                  │
     │         │           │         │        │                  │ 11. Infrastructure updates
     │         │           │         │        │                  │    Read Models (projection)
     │         │           │         │        │                  │
     │         │<──────────│ 12. Returns Result│                  │
     │         │           │                  │                  │
     │ 13. Updates UI      │                  │                  │
     │    (Optimistic)     │                  │                  │
     │         │           │                  │                  │
     │ 14. Real-time Update│                  │                  │
     │    (SignalR)        │                  │                  │
```

---

## 5. Dependency Flow

### Clean Architecture Dependency Rule

```
┌─────────────────────────────────────┐
│      Presentation Layer              │
│  (API Controllers, GraphQL)         │
└──────────────┬──────────────────────┘
               │ depends on
               ▼
┌─────────────────────────────────────┐
│      Application Layer              │
│  (Commands, Queries, Handlers)      │
└──────────────┬──────────────────────┘
               │ depends on
               ▼
┌─────────────────────────────────────┐
│        Domain Layer                 │
│  (Aggregates, Entities, Events)     │
└─────────────────────────────────────┘
               ▲
               │ depends on
┌──────────────┴──────────────────────┐
│     Infrastructure Layer            │
│  (Repositories, Event Store, DB)    │
└─────────────────────────────────────┘
```

**Key Points**:
- Dependencies point **inward** (toward Domain)
- Domain has **no dependencies** on other layers
- Application depends on Domain
- Infrastructure depends on Domain (implements interfaces)

---

## 6. Communication Patterns

### Pattern 1: Application Calls Domain

**Application orchestrates, Domain executes**:

```csharp
// Application Layer
public class UpdateTankCommandHandler
{
    public async Task<Result> Handle(UpdateTankCommand command)
    {
        // Application loads domain aggregate
        var tank = await _repository.GetByIdAsync(tankId);
        
        // Application calls domain method
        tank.UpdateName(command.Name);        // ← Domain method
        tank.UpdateCapacity(capacity);        // ← Domain method
        tank.Relocate(location);              // ← Domain method
        
        // Application saves
        await _repository.UpdateAsync(tank);
        return Result.Success();
    }
}
```

### Pattern 2: Domain Raises Events

**Domain raises events, Application handles them**:

```csharp
// Domain Layer
public sealed class Tank : AggregateRoot<TankId>
{
    public void Activate()
    {
        if (Status == TankStatus.Active) return;
        
        // Domain validates business rule
        if (!_sensors.Any(s => s.IsActive))
            throw new InvalidOperationException("Must have active sensor");
        
        Status = TankStatus.Active;
        
        // Domain raises event
        Apply(new TankActivatedEvent(Id));  // ← Event raised
    }
}

// Application Layer
public class TankActivatedEventHandler : INotificationHandler<TankActivatedEvent>
{
    public async Task Handle(TankActivatedEvent notification, CancellationToken ct)
    {
        // Application reacts to domain event
        _logger.LogInformation("Tank activated: {TankId}", notification.TankId);
        // Could send notifications, update read models, etc.
    }
}
```

### Pattern 3: Application Uses Domain Value Objects

**Application creates value objects, Domain validates**:

```csharp
// Application Layer
public class CreateTankCommandHandler
{
    public async Task<Result<Guid>> Handle(CreateTankCommand command)
    {
        // Application creates value objects (Domain validates)
        var capacity = TankCapacity.Create(
            command.Capacity, 
            command.CapacityUnit);  // ← Domain validates
        
        var location = Location.Create(
            command.Building,
            command.Room,
            command.Zone);  // ← Domain validates
        
        // Use validated value objects
        var tank = Tank.Create(command.Name, capacity, location, tankType);
    }
}
```

---

## 7. Responsibilities Separation

### Domain Layer Responsibilities

**✅ Domain Layer Should**:
- Define business rules
- Validate business logic
- Enforce invariants
- Raise domain events
- Model domain concepts
- Define interfaces for Infrastructure (IEventStore, etc.)

**❌ Domain Layer Should NOT**:
- Know about databases
- Know about APIs
- Know about external services
- Handle HTTP requests
- Know about DTOs
- Implement persistence logic

### Application Layer Responsibilities

**✅ Application Layer Should**:
- Orchestrate domain operations
- Handle use cases
- Map between DTOs and domain models
- Define interfaces for Infrastructure (ITankRepository, IUnitOfWork)
- Handle application-level validation
- Coordinate between Domain and Infrastructure

**❌ Application Layer Should NOT**:
- Contain business rules (belongs in Domain)
- Directly access databases (use repositories)
- Know about HTTP (belongs in Presentation)
- Contain domain logic (belongs in Domain)
- Implement persistence (belongs in Infrastructure)

### Infrastructure Layer Responsibilities

**✅ Infrastructure Layer Should**:
- Implement data persistence (Event Store, Read Models)
- Implement repository interfaces
- Provide external service integration (AWS, messaging)
- Handle database contexts
- Implement projection handlers
- Provide file storage services

**❌ Infrastructure Layer Should NOT**:
- Contain business rules (belongs in Domain)
- Contain use case logic (belongs in Application)
- Define domain models (belongs in Domain)
- Know about HTTP (belongs in Presentation)

### Frontend Layer Responsibilities

**✅ Frontend Layer Should**:
- Provide user interface and user experience
- Manage client-side state (Pinia stores)
- Handle user interactions and form validation
- Communicate with backend via HTTP/WebSocket
- Implement optimistic updates for better UX
- Handle routing and navigation
- Manage real-time updates (SignalR)

**❌ Frontend Layer Should NOT**:
- Contain business rules (belongs in Domain)
- Contain use case logic (belongs in Application)
- Know about database structure (uses API)
- Know about backend implementation details
- Store sensitive data in client-side storage

---

## 8. Example: Complete Flow

### Creating a Tank - Full Flow with All Layers

```
1. Frontend: User clicks "Create Tank" button
   └─> TankForm component collects data
   └─> Calls tankStore.createTank(command)

2. Frontend: TankStore (Optimistic Update)
   └─> Immediately adds tank to UI (optimistic)
   └─> Calls tankService.createTank(command)

3. Frontend: TankService
   └─> HTTP POST /api/tanks
   └─> HttpClient sends request with auth token

4. Backend: API Controller (Presentation Layer)
   └─> Receives HTTP POST /api/tanks
   └─> Creates CreateTankCommand
   └─> Sends to MediatR

5. Backend: MediatR (Application Layer)
   └─> Routes to CreateTankCommandHandler

6. Backend: ValidationBehavior (Application Layer)
   └─> Validates CreateTankCommand
   └─> Uses FluentValidation

7. Backend: CreateTankCommandHandler (Application Layer)
   └─> Checks if tank exists (via ITankRepository interface)
       └─> Infrastructure: TankRepository.GetByNameAsync()
           └─> Queries Read Model database
   └─> Creates TankCapacity value object (Domain)
   └─> Creates Location value object (Domain)
   └─> Calls Tank.Create() (Domain)
       └─> Domain validates business rules
       └─> Domain creates aggregate
       └─> Domain raises TankCreatedEvent
   └─> Saves tank (via ITankRepository interface)
       └─> Infrastructure: TankRepository.AddAsync()
           └─> Saves events to Event Store
   └─> Commits changes (via IUnitOfWork interface)
       └─> Infrastructure: UnitOfWork.SaveChangesAsync()
           └─> Commits Event Store transaction
           └─> Commits Read Model transaction

8. Backend: TankProjectionHandler (Infrastructure Layer)
   └─> Receives TankCreatedEvent
   └─> Updates Read Model (TankReadModel)
   └─> Saves to Read Model database

9. Backend: SignalR Hub (Infrastructure Layer)
   └─> Publishes TankCreatedEvent to connected clients

10. Backend: TankCreatedEventHandler (Application Layer)
    └─> Reacts to domain event
    └─> Logs, sends notifications, etc.

11. Backend: API Controller
    └─> Returns HTTP 201 Created with tank ID

12. Frontend: HttpClient receives response
    └─> TankService returns created tank
    └─> TankStore replaces optimistic tank with real tank

13. Frontend: Real-time Update (SignalR)
    └─> RealTimeStore receives TankCreatedEvent
    └─> TankStore updates UI with real-time data
    └─> Notification shown to user
```

---

## 9. Benefits of This Separation

### 1. Testability

**Domain Layer**:
- Can test business logic in isolation
- No infrastructure needed
- Fast unit tests

**Application Layer**:
- Can test use cases
- Can mock domain and infrastructure
- Integration tests possible

### 2. Maintainability

**Clear Boundaries**:
- Know where to find business rules (Domain)
- Know where to find use cases (Application)
- Easy to locate code

**Independent Changes**:
- Can change application without affecting domain
- Can change domain (carefully) without breaking application
- Clear impact analysis

### 3. Reusability

**Domain Layer**:
- Can be reused in different applications
- Can be used in different contexts
- Business logic is portable

**Application Layer**:
- Use cases are clear and documented
- Can be reused in different presentations
- Easy to understand

---

## 10. Common Mistakes

### ❌ Mistake 1: Domain Depends on Application

```csharp
// ❌ BAD - Domain depends on Application
public class Tank : AggregateRoot<TankId>
{
    public void Activate()
    {
        // ❌ Domain shouldn't know about DTOs
        var dto = new TankDto { ... };
        
        // ❌ Domain shouldn't call application services
        _notificationService.SendAlert(dto);
    }
}
```

**✅ CORRECT - Application depends on Domain**

```csharp
// ✅ GOOD - Domain is independent
public class Tank : AggregateRoot<TankId>
{
    public void Activate()
    {
        Status = TankStatus.Active;
        Apply(new TankActivatedEvent(Id));  // Raise event
    }
}

// Application handles the event
public class TankActivatedEventHandler
{
    public async Task Handle(TankActivatedEvent e)
    {
        _notificationService.SendAlert(e.TankId);  // Application reacts
    }
}
```

### ❌ Mistake 2: Business Logic in Application

```csharp
// ❌ BAD - Business logic in Application
public class CreateTankCommandHandler
{
    public async Task<Result<Guid>> Handle(CreateTankCommand command)
    {
        // ❌ Business rule in Application layer
        if (command.Capacity <= 0)
            return Error.Validation("Invalid capacity");
        
        // ❌ Business logic in Application
        if (command.Name.Length > 100)
            return Error.Validation("Name too long");
    }
}
```

**✅ CORRECT - Business Logic in Domain**

```csharp
// ✅ GOOD - Business logic in Domain
public static TankCapacity Create(decimal value, string unit)
{
    // ✅ Domain validates business rules
    if (value <= 0)
        throw new ArgumentException("Capacity must be positive");
    
    return new TankCapacity(value, unit);
}

// Application just uses domain
public class CreateTankCommandHandler
{
    public async Task<Result<Guid>> Handle(CreateTankCommand command)
    {
        // ✅ Application delegates to Domain
        var capacity = TankCapacity.Create(command.Capacity, command.CapacityUnit);
    }
}
```

---

## 11. Real-World Analogy

Think of **Domain and Application** like a **restaurant**:

**Domain Layer (Kitchen/Recipes)**:
- Contains recipes (business rules)
- Defines how to cook (domain logic)
- Independent of restaurant type
- Can be used in any restaurant

**Application Layer (Restaurant Operations)**:
- Takes orders (commands)
- Follows recipes (uses domain)
- Coordinates kitchen (orchestrates)
- Handles customer service (application concerns)

**Relationship**:
- Restaurant (Application) uses recipes (Domain)
- Recipes (Domain) don't know about restaurant (Application)
- Restaurant (Application) depends on recipes (Domain)
- Recipes (Domain) are independent and reusable

---

## 12. Summary

**Domain, Application, Infrastructure, and Frontend Layers**:

**Domain Layer**:
- Core business logic
- Independent and reusable
- No dependencies on other layers (except interfaces it defines)
- Contains aggregates, entities, value objects, domain events

**Application Layer**:
- Orchestrates domain operations
- Implements use cases
- Depends on Domain layer
- Defines interfaces for Infrastructure
- Contains commands, queries, handlers, DTOs
- Exposes API endpoints for Frontend

**Infrastructure Layer**:
- Implements data persistence
- Provides external service integration
- Implements Domain and Application interfaces
- Depends on Domain and Application layers
- Contains repositories, event store, read models, projections

**Frontend Layer**:
- Provides user interface and experience
- Manages client-side state
- Communicates with backend via HTTP/WebSocket
- Independent of backend implementation
- Contains components, stores, services, views

**Relationships**:
- Frontend **depends on** Backend API (Application layer)
- Application **depends on** Domain
- Infrastructure **depends on** Domain (implements interfaces)
- Infrastructure **depends on** Application (implements interfaces)
- Domain is **independent** (defines interfaces only)
- They **work together** to implement complete full-stack system
- Clear **separation of concerns**

**Key Takeaway**: Domain layer is the foundation containing pure business logic. Application layer orchestrates domain operations and exposes APIs. Infrastructure layer provides concrete implementations. Frontend layer provides user interface and communicates with backend via APIs. The dependency always flows inward toward Domain, ensuring business logic remains independent, testable, and reusable. Frontend is decoupled from backend implementation details, communicating only through well-defined APIs.

