# Theoretical Concepts: Four-Layer Architecture (Domain, Application, Infrastructure, Frontend)

## 1. Overview: Complete Full-Stack System Architecture

The **Domain**, **Application**, **Infrastructure**, and **Frontend** layers form a complete, production-ready full-stack system following Clean Architecture principles.

**Four-Layer Model**:
```
┌─────────────────────────────────────┐
│        Frontend Layer               │
│  (User Interface & Client State)  │
└──────────────┬──────────────────────┘
               │ HTTP/WebSocket
               │ (API Communication)
               ▼
┌─────────────────────────────────────┐
│      Application Layer              │
│  (Orchestration & Use Cases)        │
│  (API Endpoints)                    │
└──────────────┬──────────────────────┘
               │ uses
               ▼
┌─────────────────────────────────────┐
│        Domain Layer                  │
│  (Business Logic & Rules)           │
└─────────────────────────────────────┘
               ▲
               │ implements
┌──────────────┴──────────────────────┐
│     Infrastructure Layer             │
│  (Persistence & External Services)  │
└─────────────────────────────────────┘
```

---

## 2. Layer Responsibilities

### Frontend Layer (User Interface)

**What It Does**:
- Provides user interface and user experience
- Manages client-side state (Pinia stores)
- Handles user interactions and form validation
- Communicates with backend via HTTP/WebSocket
- Implements optimistic updates
- Handles routing and navigation
- Manages real-time updates (SignalR)

**What It Doesn't Do**:
- Contain business rules (belongs in Domain)
- Contain use case logic (belongs in Application)
- Know about database structure (uses API)
- Know about backend implementation details

**Key Principle**: User interface layer, communicates with backend via APIs

### Domain Layer (Core)

**What It Does**:
- Defines business rules
- Models domain concepts
- Validates business logic
- Raises domain events
- Defines interfaces for Infrastructure

**What It Doesn't Do**:
- Know about databases
- Know about APIs
- Know about external services
- Handle HTTP requests
- Implement persistence

**Key Principle**: Pure business logic, completely independent

### Application Layer (Orchestration)

**What It Does**:
- Orchestrates domain operations
- Implements use cases
- Maps between DTOs and domain models
- Defines interfaces for Infrastructure
- Exposes API endpoints (REST/GraphQL)
- Handles HTTP requests

**What It Doesn't Do**:
- Contain business rules (belongs in Domain)
- Directly access databases (uses repositories)
- Know about UI frameworks (belongs in Frontend)
- Implement persistence (belongs in Infrastructure)

**Key Principle**: Use case orchestration, defines what Infrastructure should provide

### Infrastructure Layer (Implementation)

**What It Does**:
- Implements data persistence (Event Store, Read Models)
- Implements repository interfaces
- Provides external service integration (AWS, messaging)
- Handles database contexts
- Implements projection handlers
- Provides file storage services

**What It Doesn't Do**:
- Contain business rules (belongs in Domain)
- Contain use case logic (belongs in Application)
- Define domain models (belongs in Domain)
- Know about HTTP (belongs in Application/Presentation)

**Key Principle**: Technical implementation, realizes Domain and Application interfaces

---

## 3. Dependency Flow

### The Complete Dependency Graph

```
Frontend Layer
    │
    │ HTTP/WebSocket (API)
    │ depends on
    ▼
Application Layer (API)
    │
    │ uses
    │ depends on
    ▼
Domain Layer ←──────────────────┐
    ▲                           │
    │ implements interfaces     │
    │                           │
Infrastructure Layer ───────────┘
    │
    │ also implements
    │ Application interfaces
    │
    └───────────────────────────┐
                                │
Application Layer (interfaces)  │
```

**Key Points**:
- Frontend depends on Backend API (Application layer)
- All backend dependencies point toward Domain
- Infrastructure implements interfaces from both Domain and Application
- Domain defines interfaces but doesn't depend on Infrastructure
- Application defines interfaces but doesn't depend on Infrastructure directly
- Frontend is completely decoupled from backend implementation

---

## 4. Complete Request Flow

### Creating a Tank - All Layers Working Together

```
┌─────────────────────────────────────────────────────────────┐
│ 1. Frontend Layer (User Interaction)                       │
│    - User fills form and clicks "Create Tank"              │
│    - TankForm component collects data                      │
│    - Calls tankStore.createTank(command)                   │
│    - Optimistic update: immediately shows tank in UI       │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. Frontend Layer (Service Call)                          │
│    - TankService.createTank(command)                       │
│    - HttpClient sends HTTP POST /api/tanks                 │
│    - Includes authentication token                        │
│    - Includes correlation ID for tracing                  │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    │ HTTP POST /api/tanks
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. Backend: Application Layer (API Controller)            │
│    - Receives HTTP POST /api/tanks                         │
│    - Creates CreateTankCommand                             │
│    - Sends to MediatR                                      │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. Backend: Application Layer (MediatR)                   │
│    - Routes to CreateTankCommandHandler                    │
│    - ValidationBehavior validates command                  │
│    - LoggingBehavior logs request                          │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 5. Backend: Application Layer (Handler)                   │
│    - Checks if tank exists (via ITankRepository)          │
│      └─> Infrastructure: Queries Read Model               │
│    - Creates Domain value objects                          │
│      └─> TankCapacity.Create() (Domain validates)         │
│      └─> Location.Create() (Domain validates)             │
│    - Calls Domain factory                                  │
│      └─> Tank.Create() (Domain creates, raises event)     │
│    - Saves via Infrastructure                              │
│      └─> ITankRepository.AddAsync()                       │
│          └─> Infrastructure: Saves events to Event Store  │
│    - Commits via Unit of Work                              │
│      └─> IUnitOfWork.SaveChangesAsync()                   │
│          └─> Infrastructure: Commits transactions         │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 6. Backend: Infrastructure Layer (Event Store)           │
│    - EventStoreRepository saves events                      │
│    - Events serialized and stored                           │
│    - Version checked for concurrency                       │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 7. Backend: Infrastructure Layer (Projections)            │
│    - TankProjectionHandler receives TankCreatedEvent       │
│    - Updates TankReadModel                                 │
│    - Saves to Read Model database                          │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 8. Backend: Infrastructure Layer (SignalR)                │
│    - Publishes TankCreatedEvent to connected clients       │
│    - Real-time update sent to Frontend                     │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    │ HTTP 201 Created + Tank Data
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 9. Frontend Layer (Response Handling)                      │
│    - HttpClient receives response                          │
│    - TankService returns created tank                      │
│    - TankStore replaces optimistic tank with real tank     │
│    - Notification shown to user                            │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    │ SignalR Event
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 10. Frontend Layer (Real-time Update)                     │
│     - RealTimeStore receives TankCreatedEvent              │
│     - TankStore updates UI with real-time data            │
│     - UI automatically reflects changes                     │
└─────────────────────────────────────────────────────────────┘
```

---

## 5. Communication Patterns

### Frontend to Backend Communication

**HTTP REST API**:
```typescript
// Frontend
const response = await tankService.createTank(command)
// HTTP POST /api/tanks
// Backend: Application Layer handles request
```

**WebSocket (SignalR)**:
```typescript
// Frontend
realTimeStore.subscribe('TankUpdates', (event) => {
  // Handle real-time updates
})
// Backend: Infrastructure Layer publishes events
```

### Backend Internal Communication

**Direct Method Calls**:
```csharp
// Application Layer
var tank = Tank.Create(...);  // Direct call to Domain
await _repository.AddAsync(tank);  // Interface call to Infrastructure
```

**Domain Events**:
```csharp
// Domain Layer
Apply(new TankCreatedEvent(...));  // Raises event

// Infrastructure Layer
public class TankProjectionHandler : INotificationHandler<TankCreatedEvent>
{
    // Handles event
}
```

---

## 6. Data Flow Patterns

### Write Flow (Command)

```
1. Frontend: User action
2. Frontend: Optimistic update (immediate UI feedback)
3. Frontend: HTTP POST to backend
4. Backend: Application receives command
5. Backend: Application calls Domain
6. Backend: Domain validates and creates aggregate
7. Backend: Application saves via Infrastructure
8. Backend: Infrastructure saves to Event Store
9. Backend: Infrastructure updates Read Models
10. Backend: Infrastructure publishes event (SignalR)
11. Backend: HTTP response to Frontend
12. Frontend: Replace optimistic with real data
13. Frontend: Real-time update received
```

### Read Flow (Query)

```
1. Frontend: User navigates to page
2. Frontend: HTTP GET to backend
3. Backend: Application receives query
4. Backend: Application queries via Infrastructure
5. Backend: Infrastructure queries Read Models (fast)
6. Backend: Infrastructure returns data
7. Backend: Application maps to DTOs
8. Backend: HTTP response to Frontend
9. Frontend: Store updates state
10. Frontend: UI renders data
```

---

## 7. Benefits of Four-Layer Architecture

### 1. Separation of Concerns

**Clear Boundaries**:
- Frontend: User interface
- Application: Use cases and APIs
- Domain: Business logic
- Infrastructure: Technical implementation

**Easy to Locate Code**:
- UI component? → Frontend
- Business rule? → Domain
- Use case? → Application
- Database access? → Infrastructure

### 2. Independent Development

**Frontend and Backend**:
- Can be developed independently
- Can use different technologies
- Can be deployed separately
- Can be scaled independently

**Backend Layers**:
- Domain can be tested independently
- Application can be tested with mocked Infrastructure
- Infrastructure can be swapped without affecting Domain

### 3. Flexibility

**Change Frontend**:
- Only Frontend changes
- Backend unchanged
- Can have multiple frontends (web, mobile, desktop)

**Change Backend**:
- Only backend changes
- Frontend unchanged (if API contract maintained)
- Can swap Infrastructure implementations

**Change Business Rules**:
- Only Domain changes
- Application adapts to new Domain API
- Frontend and Infrastructure unchanged

### 4. Testability

**Frontend**:
- Mock backend API
- Test UI components
- Test state management
- E2E tests

**Backend**:
- Domain: Pure unit tests
- Application: Integration tests with mocked Infrastructure
- Infrastructure: Integration tests with database

---

## 8. Real-World Analogy

Think of **Four-Layer Architecture** like a **restaurant with delivery**:

**Frontend Layer (Customer App)**:
- Like a food delivery app
- User places order (user action)
- Shows order status (UI state)
- Communicates with restaurant (API)

**Application Layer (Restaurant Operations)**:
- Like restaurant staff
- Takes orders (API endpoints)
- Coordinates kitchen (orchestrates)
- Manages service (use cases)

**Domain Layer (Recipes)**:
- Like recipes
- Contains cooking instructions (business rules)
- Independent of restaurant type
- Can be used anywhere

**Infrastructure Layer (Kitchen Equipment)**:
- Like kitchen equipment
- Provides stoves, ovens (databases)
- Provides storage (event store)
- Implements what recipes need

**Working Together**:
- Customer (Frontend) orders via app (API)
- Staff (Application) uses recipes (Domain)
- Equipment (Infrastructure) provides what recipes need
- Complete system delivers food (use case)

---

## 9. Summary

**Four-Layer Architecture**:

**Frontend Layer**:
- User interface and client-side state
- Communicates with backend via HTTP/WebSocket
- Independent of backend implementation

**Domain Layer**:
- Core business logic
- Independent and reusable
- Defines interfaces

**Application Layer**:
- Orchestrates domain operations
- Implements use cases
- Exposes APIs for Frontend

**Infrastructure Layer**:
- Implements data persistence
- Provides external services
- Implements Domain and Application interfaces

**Key Takeaway**: The four-layer architecture provides complete separation of concerns, making the system testable, maintainable, and flexible. Frontend is decoupled from backend, communicating only through well-defined APIs. Backend follows Clean Architecture with dependencies flowing inward toward Domain. This creates a robust, scalable, and maintainable full-stack system.

