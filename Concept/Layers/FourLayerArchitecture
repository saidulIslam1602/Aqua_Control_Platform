# Theoretical Concepts: Complete System Architecture (Domain, Application, Infrastructure, Frontend, Data Engineering)

## 1. Overview: Complete Full-Stack System Architecture

The **Domain**, **Application**, **Infrastructure**, **Frontend**, and **Data Engineering** layers form a complete, production-ready full-stack system following Clean Architecture principles with real-time analytics and ML capabilities.

**Complete System Architecture**:
```
┌─────────────────────────────────────┐
│        Frontend Layer               │
│  (User Interface & Client State)     │
└──────────────┬──────────────────────┘
               │ HTTP/WebSocket
               ▼
┌─────────────────────────────────────┐
│    API/Presentation Layer           │
│  (REST Controllers, SignalR Hubs)    │
│  (Middleware, Error Handling)       │
└──────────────┬──────────────────────┘
               │ MediatR (Commands/Queries)
               ▼
┌─────────────────────────────────────┐
│      Application Layer              │
│  (Orchestration & Use Cases)        │
│  (Handlers, DTOs, Validation)        │
└──────────────┬──────────────────────┘
               │ uses
               ▼
┌─────────────────────────────────────┐
│        Domain Layer                  │
│  (Business Logic & Rules)           │
└─────────────────────────────────────┘
               ▲
               │ implements
┌──────────────┴──────────────────────┐
│     Infrastructure Layer             │
│  (Persistence & External Services)   │
└─────────────────────────────────────┘
               │
               │ Domain Events
               │ (Kafka)
               ▼
┌─────────────────────────────────────┐
│     Data Engineering Layer           │
│  (Real-time Analytics & ML)         │
│  - Kafka (Event Streaming)          │
│  - TimescaleDB (Time-series)        │
│  - Kafka Streams (Processing)       │
│  - ML Feature Engineering           │
└─────────────────────────────────────┘
```

---

## 2. Layer Responsibilities

### Frontend Layer (User Interface)

**What It Does**:
- Provides user interface and user experience
- Manages client-side state (Pinia stores)
- Handles user interactions and form validation
- Communicates with backend via HTTP/WebSocket
- Implements optimistic updates
- Handles routing and navigation
- Manages real-time updates (SignalR)

**What It Doesn't Do**:
- Contain business rules (belongs in Domain)
- Contain use case logic (belongs in Application)
- Know about database structure (uses API)
- Know about backend implementation details

**Key Principle**: User interface layer, communicates with backend via APIs

### Domain Layer (Core)

**What It Does**:
- Defines business rules
- Models domain concepts
- Validates business logic
- Raises domain events
- Defines interfaces for Infrastructure

**What It Doesn't Do**:
- Know about databases
- Know about APIs
- Know about external services
- Handle HTTP requests
- Implement persistence

**Key Principle**: Pure business logic, completely independent

### Application Layer (Orchestration)

**What It Does**:
- Orchestrates domain operations
- Implements use cases
- Maps between DTOs and domain models
- Defines interfaces for Infrastructure
- Contains command/query handlers (CQRS)
- Handles validation and business coordination

**What It Doesn't Do**:
- Contain business rules (belongs in Domain)
- Directly access databases (uses repositories)
- Know about UI frameworks (belongs in Frontend)
- Implement persistence (belongs in Infrastructure)
- Handle HTTP requests (belongs in API/Presentation)

**Key Principle**: Use case orchestration, defines what Infrastructure should provide

### API/Presentation Layer (Entry Point)

**What It Does**:
- Handles HTTP requests (REST API)
- Handles WebSocket connections (SignalR)
- Exposes API endpoints (REST/GraphQL)
- Transforms HTTP requests to commands/queries
- Transforms Application results to HTTP responses
- Provides API documentation (Swagger)
- Handles authentication and authorization
- Global error handling and logging
- Health checks and monitoring

**What It Doesn't Do**:
- Contain business rules (belongs in Domain)
- Contain use case logic (belongs in Application)
- Know about database structure (uses Application layer)
- Make direct database calls (uses Application layer via MediatR)

**Key Principle**: Thin entry point layer that delegates to Application layer, handles protocol-specific concerns

### Infrastructure Layer (Implementation)

**What It Does**:
- Implements data persistence (Event Store, Read Models)
- Implements repository interfaces
- Provides external service integration (AWS, messaging)
- Handles database contexts
- Implements projection handlers
- Provides file storage services

**What It Doesn't Do**:
- Contain business rules (belongs in Domain)
- Contain use case logic (belongs in Application)
- Define domain models (belongs in Domain)
- Know about HTTP (belongs in Application/Presentation)

**Key Principle**: Technical implementation, realizes Domain and Application interfaces

### Data Engineering Layer (Analytics & ML)

**What It Does**:
- Consumes domain events from Infrastructure (via Kafka)
- Processes events in real-time (Kafka Streams)
- Stores time-series data (TimescaleDB)
- Engineers ML features
- Provides analytics and predictions
- Monitors data quality

**What It Doesn't Do**:
- Contain business rules (belongs in Domain)
- Contain use case logic (belongs in Application)
- Know about HTTP (belongs in Application)
- Modify domain state (read-only analytics)

**Key Principle**: Parallel data processing layer for analytics and ML, consumes events from backend

---

## 3. Dependency Flow

### The Complete Dependency Graph

```
Frontend Layer
    │
    │ HTTP/WebSocket
    │ depends on
    ▼
API/Presentation Layer
    │
    │ MediatR (Commands/Queries)
    │ depends on
    ▼
Application Layer
    │
    │ uses
    │ depends on
    ▼
Domain Layer ←──────────────────┐
    ▲                           │
    │ implements interfaces     │
    │                           │
Infrastructure Layer ────────────┘
    │
    │ also implements
    │ Application interfaces
    │
    │ Domain Events (Kafka)
    │ consumes
    ▼
Data Engineering Layer
    │
    │ (Independent parallel layer)
    │ - Kafka (Event Streaming)
    │ - TimescaleDB (Time-series)
    │ - Kafka Streams (Processing)
    │ - ML Pipeline (Features)
```

**Key Points**:
- Frontend depends on Backend API (Application layer)
- All backend dependencies point toward Domain
- Infrastructure implements interfaces from both Domain and Application
- Domain defines interfaces but doesn't depend on Infrastructure
- Application defines interfaces but doesn't depend on Infrastructure directly
- Frontend is completely decoupled from backend implementation
- Data Engineering consumes events from Infrastructure (via Kafka)
- Data Engineering is a parallel, independent analytics layer

---

## 4. Data Engineering Integration

### How Data Engineering Fits

**Data Engineering Layer**:
- **Consumes** domain events from Infrastructure (via Kafka)
- **Processes** events in real-time (Kafka Streams)
- **Stores** time-series data (TimescaleDB)
- **Engineers** ML features
- **Provides** analytics and predictions

**Integration Points**:
```
Infrastructure Layer
    │
    │ Publishes domain events
    │
    ▼
Kafka Topics
    │
    │ Consumed by
    ▼
Data Engineering Layer
    ├─> Kafka Streams (Real-time processing)
    ├─> TimescaleDB (Time-series storage)
    └─> ML Pipeline (Feature engineering)
```

**Key Characteristics**:
- **Read-Only**: Doesn't modify domain state
- **Asynchronous**: Processes events asynchronously
- **Independent**: Can be scaled independently
- **Analytics Focus**: Optimized for analytics and ML

---

## 5. Complete Request Flow

### Creating a Tank - All Layers Working Together

```
┌─────────────────────────────────────────────────────────────┐
│ 1. Frontend Layer (User Interaction)                       │
│    - User fills form and clicks "Create Tank"              │
│    - TankForm component collects data                      │
│    - Calls tankStore.createTank(command)                   │
│    - Optimistic update: immediately shows tank in UI       │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. Frontend Layer (Service Call)                          │
│    - TankService.createTank(command)                       │
│    - HttpClient sends HTTP POST /api/tanks                 │
│    - Includes authentication token                        │
│    - Includes correlation ID for tracing                  │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    │ HTTP POST /api/tanks
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. Backend: API/Presentation Layer (Controller)          │
│    - TanksController.CreateTank() receives request        │
│    - Creates CreateTankCommand from request                │
│    - Sends to MediatR                                      │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    │ MediatR
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. Backend: Application Layer (MediatR)                   │
│    - Routes to CreateTankCommandHandler                    │
│    - ValidationBehavior validates command                  │
│    - LoggingBehavior logs request                          │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 5. Backend: Application Layer (Handler)                   │
│    - CreateTankCommandHandler.Handle()                     │
│    - Checks if tank exists (via ITankRepository)          │
│      └─> Infrastructure: Queries Read Model               │
│    - Creates Domain value objects                          │
│      └─> TankCapacity.Create() (Domain validates)         │
│      └─> Location.Create() (Domain validates)             │
│    - Calls Domain factory                                  │
│      └─> Tank.Create() (Domain creates, raises event)     │
│    - Saves via Infrastructure                              │
│      └─> ITankRepository.AddAsync()                       │
│          └─> Infrastructure: Saves events to Event Store  │
│    - Commits via Unit of Work                              │
│      └─> IUnitOfWork.SaveChangesAsync()                   │
│          └─> Infrastructure: Commits transactions         │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 6. Backend: Infrastructure Layer (Event Store)           │
│    - EventStoreRepository saves events                      │
│    - Events serialized and stored                           │
│    - Version checked for concurrency                       │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 7. Backend: Infrastructure Layer (Projections)            │
│    - TankProjectionHandler receives TankCreatedEvent       │
│    - Updates TankReadModel                                 │
│    - Saves to Read Model database                          │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 8. Backend: Infrastructure Layer (SignalR)                │
│    - ISignalRService publishes TankCreatedEvent            │
│    - TankDataHub broadcasts to connected clients          │
│    - Real-time update sent to Frontend                     │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    │ HTTP 201 Created + Tank Data
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 9. Backend: API/Presentation Layer (Response)            │
│    - TanksController returns HTTP 201 Created             │
│    - Includes location header and tank data                │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    │ HTTP Response
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 10. Frontend Layer (Response Handling)                     │
│     - HttpClient receives response                          │
│     - TankService returns created tank                      │
│     - TankStore replaces optimistic tank with real tank     │
│     - Notification shown to user                            │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    │ SignalR Event
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 11. Frontend Layer (Real-time Update)                     │
│     - RealTimeStore receives TankCreatedEvent              │
│     - TankStore updates UI with real-time data            │
│     - UI automatically reflects changes                     │
└─────────────────────────────────────────────────────────────┘
                    │
                    │ Domain Events (Kafka)
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 12. Data Engineering Layer (Event Consumption)            │
│     - Kafka receives TankCreatedEvent                      │
│     - Kafka Streams processes event                        │
│     - Updates TimescaleDB time-series data                 │
│     - Triggers ML feature engineering                      │
│     - Updates analytics aggregations                       │
└─────────────────────────────────────────────────────────────┘
```

---

## 5. Communication Patterns

### Frontend to Backend Communication

**HTTP REST API**:
```typescript
// Frontend
const response = await tankService.createTank(command)
// HTTP POST /api/tanks
// Backend: Application Layer handles request
```

**WebSocket (SignalR)**:
```typescript
// Frontend
realTimeStore.subscribe('TankUpdates', (event) => {
  // Handle real-time updates
})
// Backend: Infrastructure Layer publishes events
```

### Backend Internal Communication

**Direct Method Calls**:
```csharp
// Application Layer
var tank = Tank.Create(...);  // Direct call to Domain
await _repository.AddAsync(tank);  // Interface call to Infrastructure
```

**Domain Events**:
```csharp
// Domain Layer
Apply(new TankCreatedEvent(...));  // Raises event

// Infrastructure Layer
public class TankProjectionHandler : INotificationHandler<TankCreatedEvent>
{
    // Handles event
}
```

---

## 6. Data Flow Patterns

### Write Flow (Command)

```
1. Frontend: User action
2. Frontend: Optimistic update (immediate UI feedback)
3. Frontend: HTTP POST to backend
4. Backend: Application receives command
5. Backend: Application calls Domain
6. Backend: Domain validates and creates aggregate
7. Backend: Application saves via Infrastructure
8. Backend: Infrastructure saves to Event Store
9. Backend: Infrastructure updates Read Models
10. Backend: Infrastructure publishes event (SignalR)
11. Backend: HTTP response to Frontend
12. Frontend: Replace optimistic with real data
13. Frontend: Real-time update received
```

### Read Flow (Query)

```
1. Frontend: User navigates to page
2. Frontend: HTTP GET to backend
3. Backend: Application receives query
4. Backend: Application queries via Infrastructure
5. Backend: Infrastructure queries Read Models (fast)
6. Backend: Infrastructure returns data
7. Backend: Application maps to DTOs
8. Backend: HTTP response to Frontend
9. Frontend: Store updates state
10. Frontend: UI renders data
```

---

## 7. Benefits of Four-Layer Architecture

### 1. Separation of Concerns

**Clear Boundaries**:
- Frontend: User interface
- Application: Use cases and APIs
- Domain: Business logic
- Infrastructure: Technical implementation

**Easy to Locate Code**:
- UI component? → Frontend
- Business rule? → Domain
- Use case? → Application
- Database access? → Infrastructure

### 2. Independent Development

**Frontend and Backend**:
- Can be developed independently
- Can use different technologies
- Can be deployed separately
- Can be scaled independently

**Backend Layers**:
- Domain can be tested independently
- Application can be tested with mocked Infrastructure
- Infrastructure can be swapped without affecting Domain

### 3. Flexibility

**Change Frontend**:
- Only Frontend changes
- Backend unchanged
- Can have multiple frontends (web, mobile, desktop)

**Change Backend**:
- Only backend changes
- Frontend unchanged (if API contract maintained)
- Can swap Infrastructure implementations

**Change Business Rules**:
- Only Domain changes
- Application adapts to new Domain API
- Frontend and Infrastructure unchanged

### 4. Testability

**Frontend**:
- Mock backend API
- Test UI components
- Test state management
- E2E tests

**Backend**:
- Domain: Pure unit tests
- Application: Integration tests with mocked Infrastructure
- Infrastructure: Integration tests with database

---

## 8. Real-World Analogy

Think of **Four-Layer Architecture** like a **restaurant with delivery**:

**Frontend Layer (Customer App)**:
- Like a food delivery app
- User places order (user action)
- Shows order status (UI state)
- Communicates with restaurant (API)

**Application Layer (Restaurant Operations)**:
- Like restaurant staff
- Takes orders (API endpoints)
- Coordinates kitchen (orchestrates)
- Manages service (use cases)

**Domain Layer (Recipes)**:
- Like recipes
- Contains cooking instructions (business rules)
- Independent of restaurant type
- Can be used anywhere

**Infrastructure Layer (Kitchen Equipment)**:
- Like kitchen equipment
- Provides stoves, ovens (databases)
- Provides storage (event store)
- Implements what recipes need

**Working Together**:
- Customer (Frontend) orders via app (API)
- Staff (Application) uses recipes (Domain)
- Equipment (Infrastructure) provides what recipes need
- Complete system delivers food (use case)

---

## 9. Summary

**Complete System Architecture**:

**Frontend Layer**:
- User interface and client-side state
- Communicates with backend via HTTP/WebSocket
- Independent of backend implementation

**Domain Layer**:
- Core business logic
- Independent and reusable
- Defines interfaces
- Raises domain events

**API/Presentation Layer**:
- Handles HTTP requests (REST API)
- Handles WebSocket connections (SignalR)
- Transforms HTTP ↔ Application layer
- Provides API documentation
- Global error handling and logging

**Application Layer**:
- Orchestrates domain operations
- Implements use cases
- Contains command/query handlers (CQRS)
- Maps between DTOs and domain models

**Infrastructure Layer**:
- Implements data persistence
- Provides external services
- Implements Domain and Application interfaces
- Publishes events to Kafka
- Cloud infrastructure deployment (AWS EKS, RDS, ElastiCache, S3)
- Container orchestration (Kubernetes)
- Monitoring and observability (CloudWatch, Prometheus, Grafana)

**Data Engineering Layer**:
- Consumes domain events (via Kafka)
- Real-time stream processing (Kafka Streams)
- Time-series data storage (TimescaleDB)
- ML feature engineering
- Analytics and predictions

**Key Takeaway**: The complete architecture provides separation of concerns with a main application stack (Frontend, API/Presentation, Application, Domain, Infrastructure) and a parallel data engineering layer for analytics and ML. The main stack follows Clean Architecture with dependencies flowing inward toward Domain. The API/Presentation layer is a thin entry point that handles HTTP and WebSocket protocols, delegates to the Application layer via MediatR, and provides consistent error handling and logging. The Application layer orchestrates use cases using CQRS patterns. Infrastructure layer includes both application infrastructure (Event Store, Read Models, repositories) and cloud infrastructure (AWS EKS, RDS, ElastiCache, S3) deployed via Infrastructure as Code (Terraform). Data Engineering consumes events asynchronously, enabling real-time analytics and ML without affecting the main application flow. This creates a robust, scalable, and maintainable full-stack system with advanced analytics capabilities and enterprise-grade cloud infrastructure.

