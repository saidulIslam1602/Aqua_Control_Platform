# Theoretical Concepts: Three-Layer Architecture (Domain, Application, Infrastructure)

## 1. Overview: Complete System Architecture

The **Domain**, **Application**, and **Infrastructure** layers form a complete, production-ready system following Clean Architecture principles.

**Three-Layer Model**:
```
┌─────────────────────────────────────┐
│      Application Layer              │
│  (Orchestration & Use Cases)        │
└──────────────┬──────────────────────┘
               │ uses
               ▼
┌─────────────────────────────────────┐
│        Domain Layer                  │
│  (Business Logic & Rules)            │
└─────────────────────────────────────┘
               ▲
               │ implements
┌──────────────┴──────────────────────┐
│     Infrastructure Layer             │
│  (Persistence & External Services)   │
└─────────────────────────────────────┘
```

---

## 2. Layer Responsibilities

### Domain Layer (Core)

**What It Does**:
- Defines business rules
- Models domain concepts
- Validates business logic
- Raises domain events
- Defines interfaces for Infrastructure

**What It Doesn't Do**:
- Know about databases
- Know about APIs
- Know about external services
- Handle HTTP requests
- Implement persistence

**Key Principle**: Pure business logic, completely independent

### Application Layer (Orchestration)

**What It Does**:
- Orchestrates domain operations
- Implements use cases
- Maps between DTOs and domain models
- Defines interfaces for Infrastructure
- Coordinates between Domain and Infrastructure

**What It Doesn't Do**:
- Contain business rules (belongs in Domain)
- Directly access databases (uses repositories)
- Know about HTTP (belongs in Presentation)
- Implement persistence (belongs in Infrastructure)

**Key Principle**: Use case orchestration, defines what Infrastructure should provide

### Infrastructure Layer (Implementation)

**What It Does**:
- Implements data persistence (Event Store, Read Models)
- Implements repository interfaces
- Provides external service integration (AWS, messaging)
- Handles database contexts
- Implements projection handlers
- Provides file storage services

**What It Doesn't Do**:
- Contain business rules (belongs in Domain)
- Contain use case logic (belongs in Application)
- Define domain models (belongs in Domain)
- Know about HTTP (belongs in Presentation)

**Key Principle**: Technical implementation, realizes Domain and Application interfaces

---

## 3. Dependency Flow

### The Complete Dependency Graph

```
Presentation Layer
    │
    │ depends on
    ▼
Application Layer
    │
    │ depends on
    ▼
Domain Layer ←──────────────────┐
    ▲                           │
    │ implements interfaces     │
    │                           │
Infrastructure Layer ───────────┘
    │
    │ also implements
    │ Application interfaces
    │
    └───────────────────────────┐
                                │
Application Layer (interfaces)  │
```

**Key Points**:
- All dependencies point toward Domain
- Infrastructure implements interfaces from both Domain and Application
- Domain defines interfaces but doesn't depend on Infrastructure
- Application defines interfaces but doesn't depend on Infrastructure directly

---

## 4. Complete Request Flow

### Creating a Tank - All Layers Working Together

```
┌─────────────────────────────────────────────────────────────┐
│ 1. Presentation Layer                                       │
│    - Receives HTTP POST /api/tanks                         │
│    - Creates CreateTankCommand                             │
│    - Sends to MediatR                                       │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. Application Layer (MediatR)                             │
│    - Routes to CreateTankCommandHandler                     │
│    - ValidationBehavior validates command                   │
│    - LoggingBehavior logs request                           │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. Application Layer (Handler)                             │
│    - Checks if tank exists                                  │
│      └─> Calls ITankRepository.GetByNameAsync()            │
│          └─> Infrastructure: Queries Read Model            │
│    - Creates Domain value objects                           │
│      └─> TankCapacity.Create() (Domain validates)           │
│      └─> Location.Create() (Domain validates)              │
│    - Calls Domain factory                                   │
│      └─> Tank.Create() (Domain creates, raises event)       │
│    - Saves via repository                                   │
│      └─> ITankRepository.AddAsync()                        │
│          └─> Infrastructure: Saves events to Event Store    │
│    - Commits via Unit of Work                               │
│      └─> IUnitOfWork.SaveChangesAsync()                    │
│          └─> Infrastructure: Commits transactions          │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. Infrastructure Layer (Event Store)                      │
│    - EventStoreRepository saves events                      │
│    - Events serialized and stored                           │
│    - Version checked for concurrency                       │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 5. Infrastructure Layer (Projections)                      │
│    - TankProjectionHandler receives TankCreatedEvent        │
│    - Updates TankReadModel                                  │
│    - Saves to Read Model database                           │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 6. Application Layer (Event Handlers)                      │
│    - TankCreatedEventHandler receives event                 │
│    - Logs, sends notifications, etc.                       │
└──────────────────┬──────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│ 7. Presentation Layer                                       │
│    - Returns HTTP 201 Created with tank ID                  │
└─────────────────────────────────────────────────────────────┘
```

---

## 5. Interface Contracts

### Domain Defines Interfaces

**Domain Layer Interfaces**:
```csharp
// Domain Layer
namespace AquaControl.Domain.Common;

public interface IEventStore
{
    Task SaveEventsAsync<T>(Guid aggregateId, IEnumerable<IDomainEvent> events, long expectedVersion);
    Task<IEnumerable<IDomainEvent>> GetEventsAsync(Guid aggregateId, long fromVersion = 0);
}
```

**Infrastructure Implements**:
```csharp
// Infrastructure Layer
namespace AquaControl.Infrastructure.EventStore;

public class EventStoreRepository : IEventStore
{
    // Implements Domain interface
}
```

### Application Defines Interfaces

**Application Layer Interfaces**:
```csharp
// Application Layer
namespace AquaControl.Application.Common.Interfaces;

public interface ITankRepository
{
    Task<Tank?> GetByIdAsync(TankId id, CancellationToken ct = default);
    Task AddAsync(Tank tank, CancellationToken ct = default);
}

public interface IUnitOfWork
{
    Task<int> SaveChangesAsync(CancellationToken ct = default);
}
```

**Infrastructure Implements**:
```csharp
// Infrastructure Layer
namespace AquaControl.Infrastructure.Persistence;

public class TankRepository : ITankRepository
{
    // Implements Application interface
}

public class UnitOfWork : IUnitOfWork
{
    // Implements Application interface
}
```

---

## 6. Data Flow Patterns

### Write Flow (Command)

```
1. Application receives command
2. Application validates input
3. Application calls Domain methods
   └─> Domain validates business rules
   └─> Domain creates/changes aggregate
   └─> Domain raises events
4. Application saves via Infrastructure
   └─> Infrastructure saves events to Event Store
5. Infrastructure updates Read Models
   └─> Projection handlers process events
6. Application returns result
```

### Read Flow (Query)

```
1. Application receives query
2. Application builds specification
3. Application queries via Infrastructure
   └─> Infrastructure queries Read Models (fast)
4. Infrastructure returns data
5. Application maps to DTOs
6. Application returns result
```

---

## 7. Benefits of Three-Layer Architecture

### 1. Separation of Concerns

**Clear Boundaries**:
- Domain: Business logic
- Application: Use cases
- Infrastructure: Technical implementation

**Easy to Locate Code**:
- Business rule? → Domain
- Use case? → Application
- Database access? → Infrastructure

### 2. Testability

**Domain Layer**:
- Pure business logic
- No dependencies
- Fast unit tests

**Application Layer**:
- Mock Domain and Infrastructure
- Test orchestration logic
- Integration tests

**Infrastructure Layer**:
- Test implementations
- Integration tests with database
- Test external service integrations

### 3. Flexibility

**Change Database**:
- Only Infrastructure changes
- Domain and Application unchanged

**Change Business Rules**:
- Only Domain changes
- Application adapts to new Domain API
- Infrastructure unchanged

**Change Use Cases**:
- Only Application changes
- Domain and Infrastructure unchanged

### 4. Maintainability

**Clear Structure**:
- Know where to find code
- Know what depends on what
- Easy to understand impact

**Independent Development**:
- Teams can work on different layers
- Clear interfaces between layers
- Reduced conflicts

---

## 8. Real-World Analogy

Think of **Three-Layer Architecture** like a **restaurant**:

**Domain Layer (Recipes)**:
- Contains recipes (business rules)
- Defines how to cook (domain logic)
- Independent of restaurant type
- Can be used anywhere

**Application Layer (Restaurant Operations)**:
- Takes orders (commands)
- Follows recipes (uses domain)
- Coordinates kitchen (orchestrates)
- Manages service (use cases)

**Infrastructure Layer (Kitchen Equipment)**:
- Provides stoves, ovens (databases)
- Provides storage (event store)
- Provides tools (external services)
- Implements what recipes need

**Working Together**:
- Operations (Application) uses recipes (Domain)
- Equipment (Infrastructure) provides what recipes need
- Recipes (Domain) don't know about equipment
- Operations (Application) coordinates everything

---

## 9. Common Patterns

### Pattern 1: Event Sourcing

**Domain**:
- Raises domain events
- Defines IEventStore interface

**Application**:
- Uses ITankRepository interface
- Coordinates event saving

**Infrastructure**:
- Implements IEventStore
- Saves events to Event Store
- Implements ITankRepository with event sourcing

### Pattern 2: CQRS Read Models

**Domain**:
- Raises domain events

**Application**:
- Queries via ITankRepository
- Gets optimized data

**Infrastructure**:
- Implements ITankRepository
- Queries Read Models (fast)
- Updates Read Models via projections

### Pattern 3: External Services

**Domain**:
- Defines IFileStorageService interface (if needed)

**Application**:
- Uses IFileStorageService interface

**Infrastructure**:
- Implements IFileStorageService
- Uses AWS S3, etc.

---

## 10. Summary

**Three-Layer Architecture**:

**Domain Layer**:
- Core business logic
- Independent and reusable
- Defines interfaces
- Contains aggregates, entities, value objects

**Application Layer**:
- Orchestrates domain operations
- Implements use cases
- Defines infrastructure interfaces
- Contains commands, queries, handlers

**Infrastructure Layer**:
- Implements data persistence
- Provides external services
- Implements Domain and Application interfaces
- Contains repositories, event store, read models

**Key Takeaway**: The three-layer architecture provides clear separation of concerns, making the system testable, maintainable, and flexible. Domain is the independent core, Application orchestrates, and Infrastructure provides the technical foundation. All dependencies flow inward toward Domain, ensuring business logic remains pure and reusable.

