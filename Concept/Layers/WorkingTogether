# Theoretical Concepts: How Domain and Application Layers Work Together

## 1. The Collaboration Model

Domain and Application layers work together like **orchestra and musicians**:

- **Domain Layer** = Musicians (perform the music/business logic)
- **Application Layer** = Conductor (orchestrates the performance)
- **Together** = Beautiful symphony (complete use case)

---

## 2. The Orchestration Pattern

### Application Orchestrates, Domain Executes

**Application Layer Role**:
- Receives request (command/query)
- Coordinates operations
- Calls domain methods
- Handles infrastructure
- Returns result

**Domain Layer Role**:
- Contains business logic
- Validates business rules
- Enforces invariants
- Raises events
- Maintains consistency

### Example: Complete Orchestration

```csharp
// APPLICATION LAYER - Orchestrates
public class CreateTankCommandHandler
{
    public async Task<Result<Guid>> Handle(CreateTankCommand command)
    {
        // 1. APPLICATION: Check preconditions
        var existing = await _repository.GetByNameAsync(command.Name);
        if (existing != null)
            return Error.Conflict("Tank.Exists", "Tank already exists");
        
        // 2. APPLICATION: Create Domain value objects
        var capacity = TankCapacity.Create(command.Capacity, command.CapacityUnit);
        var location = Location.Create(command.Building, command.Room);
        
        // 3. APPLICATION: Call Domain factory
        var tank = Tank.Create(command.Name, capacity, location, command.TankType);
        //     ↑ DOMAIN: Validates, creates aggregate, raises event
        
        // 4. APPLICATION: Persist via infrastructure
        await _repository.AddAsync(tank);
        await _unitOfWork.SaveChangesAsync();
        
        // 5. APPLICATION: Return result
        return Result.Success(tank.Id.Value);
    }
}

// DOMAIN LAYER - Executes business logic
public sealed class Tank : AggregateRoot<TankId>
{
    public static Tank Create(string name, TankCapacity capacity, Location location, TankType tankType)
    {
        // DOMAIN: Business rule validation
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Tank name cannot be empty");
        
        // DOMAIN: Create aggregate
        var tankId = TankId.Create();
        var tank = new Tank(tankId, name, capacity, location, tankType);
        
        // DOMAIN: Raise domain event
        tank.Apply(new TankCreatedEvent(tankId, name, capacity, location, tankType));
        
        return tank;
    }
}
```

---

## 3. Communication Mechanisms

### Mechanism 1: Direct Method Calls

**Application calls Domain methods directly**:

```csharp
// Application Layer
public class UpdateTankCommandHandler
{
    public async Task<Result> Handle(UpdateTankCommand command)
    {
        var tank = await _repository.GetByIdAsync(tankId);
        
        // Direct call to Domain method
        tank.UpdateName(command.Name);        // ← Domain method
        tank.UpdateCapacity(capacity);         // ← Domain method
        tank.Relocate(location);              // ← Domain method
        
        await _repository.UpdateAsync(tank);
        return Result.Success();
    }
}
```

**Characteristics**:
- Synchronous communication
- Direct method invocation
- Immediate execution
- Used for state changes

### Mechanism 2: Domain Events

**Domain raises events, Application handles them**:

```csharp
// Domain Layer - Raises event
public sealed class Tank : AggregateRoot<TankId>
{
    public void Activate()
    {
        if (Status == TankStatus.Active) return;
        
        if (!_sensors.Any(s => s.IsActive))
            throw new InvalidOperationException("Must have active sensor");
        
        Status = TankStatus.Active;
        Apply(new TankActivatedEvent(Id));  // ← Event raised
    }
}

// Application Layer - Handles event
public class TankActivatedEventHandler : INotificationHandler<TankActivatedEvent>
{
    public async Task Handle(TankActivatedEvent notification, CancellationToken ct)
    {
        // Application reacts to Domain event
        _logger.LogInformation("Tank activated: {TankId}", notification.TankId);
        
        // Could trigger:
        // - Notifications
        // - Read model updates
        // - External integrations
        // - Audit logging
    }
}
```

**Characteristics**:
- Asynchronous communication
- Decoupled handlers
- Multiple handlers possible
- Used for side effects

### Mechanism 3: Value Objects

**Application creates, Domain validates**:

```csharp
// Application Layer - Creates value object
public class CreateTankCommandHandler
{
    public async Task<Result<Guid>> Handle(CreateTankCommand command)
    {
        // Application creates value object
        // Domain validates during creation
        var capacity = TankCapacity.Create(
            command.Capacity,      // ← Application provides data
            command.CapacityUnit   // ← Application provides data
        );
        // ↑ Domain validates: capacity > 0, valid unit, etc.
        
        var tank = Tank.Create(command.Name, capacity, location, tankType);
    }
}

// Domain Layer - Validates value object
public sealed class TankCapacity : ValueObject
{
    public static TankCapacity Create(decimal value, string unit)
    {
        // Domain validates business rules
        if (value <= 0)
            throw new ArgumentException("Capacity must be positive");
        
        if (string.IsNullOrWhiteSpace(unit))
            throw new ArgumentException("Unit cannot be empty");
        
        return new TankCapacity(value, unit);
    }
}
```

**Characteristics**:
- Validation at creation
- Immutable after creation
- Self-validating
- Used for domain concepts

---

## 4. Data Flow

### Command Flow (Write Operation)

```
1. Presentation Layer
   └─> HTTP POST /api/tanks
   └─> Creates CreateTankCommand
   └─> Sends to MediatR

2. Application Layer (MediatR)
   └─> Routes to CreateTankCommandHandler

3. Application Layer (Handler)
   └─> Validates command (FluentValidation)
   └─> Checks repository (infrastructure)
   └─> Creates value objects (Domain validates)
   └─> Calls Tank.Create() (Domain)
       └─> Domain validates business rules
       └─> Domain creates aggregate
       └─> Domain raises TankCreatedEvent
   └─> Saves to repository (infrastructure)
   └─> Commits changes (Unit of Work)

4. Application Layer (Event Handler)
   └─> Reacts to TankCreatedEvent
   └─> Logs, sends notifications, etc.

5. Presentation Layer
   └─> Returns HTTP 201 Created with tank ID
```

### Query Flow (Read Operation)

```
1. Presentation Layer
   └─> HTTP GET /api/tanks?page=1
   └─> Creates GetTanksQuery
   └─> Sends to MediatR

2. Application Layer (MediatR)
   └─> Routes to GetTanksQueryHandler

3. Application Layer (Handler)
   └─> Builds specification (filter)
   └─> Queries repository (infrastructure)
       └─> Repository loads Domain aggregates
   └─> Maps Domain to DTOs
   └─> Returns PagedResult<TankDto>

4. Presentation Layer
   └─> Returns HTTP 200 OK with JSON data
```

---

## 5. Responsibility Matrix

### Who Does What?

| Responsibility | Domain Layer | Application Layer |
|----------------|--------------|-------------------|
| **Business Rules** | ✅ Yes | ❌ No |
| **Validation** | ✅ Business rules | ✅ Input validation |
| **State Changes** | ✅ Methods | ❌ No (calls Domain) |
| **Orchestration** | ❌ No | ✅ Yes |
| **Persistence** | ❌ No | ✅ Coordinates |
| **Event Handling** | ✅ Raises events | ✅ Handles events |
| **DTO Mapping** | ❌ No | ✅ Yes |
| **Use Cases** | ❌ No | ✅ Yes |
| **Error Handling** | ✅ Exceptions | ✅ Result pattern |

---

## 6. Example: Complete Use Case

### Use Case: Create and Activate Tank

```csharp
// STEP 1: Application receives command
public class CreateTankCommandHandler
{
    public async Task<Result<Guid>> Handle(CreateTankCommand command)
    {
        // STEP 2: Application validates input
        var existing = await _repository.GetByNameAsync(command.Name);
        if (existing != null)
            return Error.Conflict("Tank.Exists", "Tank already exists");
        
        // STEP 3: Application creates Domain value objects
        var capacity = TankCapacity.Create(command.Capacity, command.CapacityUnit);
        var location = Location.Create(command.Building, command.Room);
        
        // STEP 4: Application calls Domain factory
        var tank = Tank.Create(command.Name, capacity, location, command.TankType);
        // Domain validates, creates, raises TankCreatedEvent
        
        // STEP 5: Application saves
        await _repository.AddAsync(tank);
        await _unitOfWork.SaveChangesAsync();
        
        // STEP 6: Application activates tank (if sensors exist)
        if (command.AutoActivate && tank.Sensors.Any())
        {
            tank.Activate();  // Domain validates, changes state, raises TankActivatedEvent
            await _repository.UpdateAsync(tank);
            await _unitOfWork.SaveChangesAsync();
        }
        
        return Result.Success(tank.Id.Value);
    }
}

// Domain Layer - Business logic
public sealed class Tank : AggregateRoot<TankId>
{
    public static Tank Create(string name, TankCapacity capacity, Location location, TankType tankType)
    {
        // Domain validates business rules
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Tank name cannot be empty");
        
        var tankId = TankId.Create();
        var tank = new Tank(tankId, name, capacity, location, tankType);
        tank.Apply(new TankCreatedEvent(tankId, name, capacity, location, tankType));
        return tank;
    }
    
    public void Activate()
    {
        // Domain enforces business rule
        if (Status == TankStatus.Active) return;
        
        if (!_sensors.Any(s => s.IsActive))
            throw new InvalidOperationException("Tank must have at least one active sensor");
        
        Status = TankStatus.Active;
        Apply(new TankActivatedEvent(Id));
    }
}
```

---

## 7. Error Handling Collaboration

### Domain Throws Exceptions

```csharp
// Domain Layer
public static TankCapacity Create(decimal value, string unit)
{
    if (value <= 0)
        throw new ArgumentException("Capacity must be positive");  // ← Domain throws
    
    return new TankCapacity(value, unit);
}
```

### Application Catches and Converts

```csharp
// Application Layer
public async Task<Result<Guid>> Handle(CreateTankCommand command)
{
    try
    {
        var capacity = TankCapacity.Create(command.Capacity, command.CapacityUnit);
        // Domain might throw exception
    }
    catch (ArgumentException ex)
    {
        // Application converts exception to Result
        return Error.Validation("Tank.ValidationError", ex.Message);
    }
}
```

**Why This Works**:
- Domain uses exceptions (standard .NET)
- Application converts to Result pattern (API-friendly)
- Clear separation of concerns

---

## 8. Event-Driven Collaboration

### Domain Raises, Application Reacts

```csharp
// Domain Layer - Raises event
public void ScheduleMaintenance(DateTime maintenanceDate)
{
    if (maintenanceDate <= DateTime.UtcNow)
        throw new ArgumentException("Maintenance date must be in the future");
    
    NextMaintenanceDate = maintenanceDate;
    Apply(new TankMaintenanceScheduledEvent(Id, maintenanceDate));  // ← Event raised
}

// Application Layer - Multiple handlers react
public class MaintenanceScheduledEventHandler : INotificationHandler<TankMaintenanceScheduledEvent>
{
    public async Task Handle(TankMaintenanceScheduledEvent notification, CancellationToken ct)
    {
        // Handler 1: Send notification
        await _notificationService.SendMaintenanceReminder(notification.TankId, notification.ScheduledDate);
    }
}

public class MaintenanceCalendarHandler : INotificationHandler<TankMaintenanceScheduledEvent>
{
    public async Task Handle(TankMaintenanceScheduledEvent notification, CancellationToken ct)
    {
        // Handler 2: Update calendar
        await _calendarService.AddMaintenanceEvent(notification.TankId, notification.ScheduledDate);
    }
}
```

**Benefits**:
- Domain doesn't know about handlers
- Multiple handlers can react
- Easy to add new handlers
- Decoupled collaboration

---

## 9. Real-World Analogy

Think of **Domain and Application** like a **construction project**:

**Domain Layer (Architect/Engineer)**:
- Designs the building (business rules)
- Ensures structural integrity (validation)
- Defines requirements (interfaces)
- Independent of construction method

**Application Layer (Project Manager)**:
- Coordinates construction (orchestrates)
- Hires contractors (infrastructure)
- Follows architect's plans (uses Domain)
- Manages the process (use cases)

**Working Together**:
- Architect (Domain) designs
- Project Manager (Application) coordinates
- Contractors (Infrastructure) build
- Result: Complete building (use case)

---

## 10. Summary

**How They Work Together**:

1. **Application Orchestrates**:
   - Receives requests
   - Coordinates operations
   - Calls Domain methods
   - Handles infrastructure

2. **Domain Executes**:
   - Validates business rules
   - Enforces invariants
   - Changes state
   - Raises events

3. **Communication Mechanisms**:
   - Direct method calls (synchronous)
   - Domain events (asynchronous)
   - Value objects (validation)

4. **Clear Responsibilities**:
   - Domain: Business logic
   - Application: Use cases and orchestration

**Key Takeaway**: Application layer is the conductor, Domain layer is the orchestra. Application orchestrates and coordinates, Domain performs the business logic. They work together seamlessly, with clear boundaries and responsibilities, to implement complete use cases.

