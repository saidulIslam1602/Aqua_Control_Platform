# Theoretical Concepts: How All Layers Work Together

## 1. The Collaboration Model

All layers work together like **orchestra, conductor, stage crew, audience, and recording studio**:

- **Domain Layer** = Musicians (perform the music/business logic)
- **Application Layer** = Conductor (orchestrates the performance)
- **Infrastructure Layer** = Stage Crew (provides equipment, records performance)
- **Frontend Layer** = Audience (experiences the performance)
- **Data Engineering Layer** = Recording Studio (analyzes and processes recordings)
- **Together** = Complete system (full-stack application with analytics and ML)

---

## 2. The Orchestration Pattern

### Application Orchestrates, Domain Executes, Infrastructure Provides

**Application Layer Role**:
- Receives request (command/query)
- Coordinates operations
- Calls domain methods
- Uses infrastructure via interfaces
- Returns result

**Domain Layer Role**:
- Contains business logic
- Validates business rules
- Enforces invariants
- Raises events
- Maintains consistency
- Defines interfaces for Infrastructure

**Infrastructure Layer Role**:
- Implements data persistence
- Provides external services
- Implements Domain and Application interfaces
- Handles database operations
- Updates read models
- Manages transactions
- Publishes domain events to Kafka

**Data Engineering Layer Role**:
- Consumes domain events from Infrastructure (via Kafka)
- Processes events in real-time (Kafka Streams)
- Stores time-series data (TimescaleDB)
- Engineers ML features
- Provides analytics and predictions
- Monitors data quality

### Example: Complete Orchestration with All Layers

```csharp
// APPLICATION LAYER - Orchestrates
public class CreateTankCommandHandler
{
    private readonly ITankRepository _repository;  // Interface from Application
    private readonly IUnitOfWork _unitOfWork;      // Interface from Application
    
    public async Task<Result<Guid>> Handle(CreateTankCommand command)
    {
        // 1. APPLICATION: Check preconditions (uses Infrastructure via interface)
        var existing = await _repository.GetByNameAsync(command.Name);
        // Infrastructure: TankRepository queries Read Model database
        if (existing != null)
            return Error.Conflict("Tank.Exists", "Tank already exists");
        
        // 2. APPLICATION: Create Domain value objects
        var capacity = TankCapacity.Create(command.Capacity, command.CapacityUnit);
        // Domain: Validates capacity > 0, valid unit
        var location = Location.Create(command.Building, command.Room);
        // Domain: Validates building and room not empty
        
        // 3. APPLICATION: Call Domain factory
        var tank = Tank.Create(command.Name, capacity, location, command.TankType);
        // Domain: Validates name, creates aggregate, raises TankCreatedEvent
        
        // 4. APPLICATION: Persist via Infrastructure (via interface)
        await _repository.AddAsync(tank);
        // Infrastructure: TankRepository saves events to Event Store
        
        await _unitOfWork.SaveChangesAsync();
        // Infrastructure: UnitOfWork commits transactions, publishes events
        
        // 5. Infrastructure: Projection handler updates Read Models
        // (automatically triggered by domain event)
        
        // 6. APPLICATION: Return result
        return Result.Success(tank.Id.Value);
    }
}

// DOMAIN LAYER - Executes business logic
public sealed class Tank : AggregateRoot<TankId>
{
    public static Tank Create(string name, TankCapacity capacity, Location location, TankType tankType)
    {
        // DOMAIN: Business rule validation
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Tank name cannot be empty");
        
        // DOMAIN: Create aggregate
        var tankId = TankId.Create();
        var tank = new Tank(tankId, name, capacity, location, tankType);
        
        // DOMAIN: Raise domain event
        tank.Apply(new TankCreatedEvent(tankId, name, capacity, location, tankType));
        
        return tank;
    }
}
```

---

## 3. Communication Mechanisms

### Mechanism 1: Direct Method Calls

**Application calls Domain methods directly**:

```csharp
// Application Layer
public class UpdateTankCommandHandler
{
    public async Task<Result> Handle(UpdateTankCommand command)
    {
        var tank = await _repository.GetByIdAsync(tankId);
        
        // Direct call to Domain method
        tank.UpdateName(command.Name);        // ← Domain method
        tank.UpdateCapacity(capacity);         // ← Domain method
        tank.Relocate(location);              // ← Domain method
        
        await _repository.UpdateAsync(tank);
        return Result.Success();
    }
}
```

**Characteristics**:
- Synchronous communication
- Direct method invocation
- Immediate execution
- Used for state changes

### Mechanism 2: Domain Events

**Domain raises events, Application handles them**:

```csharp
// Domain Layer - Raises event
public sealed class Tank : AggregateRoot<TankId>
{
    public void Activate()
    {
        if (Status == TankStatus.Active) return;
        
        if (!_sensors.Any(s => s.IsActive))
            throw new InvalidOperationException("Must have active sensor");
        
        Status = TankStatus.Active;
        Apply(new TankActivatedEvent(Id));  // ← Event raised
    }
}

// Application Layer - Handles event
public class TankActivatedEventHandler : INotificationHandler<TankActivatedEvent>
{
    public async Task Handle(TankActivatedEvent notification, CancellationToken ct)
    {
        // Application reacts to Domain event
        _logger.LogInformation("Tank activated: {TankId}", notification.TankId);
        
        // Could trigger:
        // - Notifications
        // - Read model updates
        // - External integrations
        // - Audit logging
    }
}
```

**Characteristics**:
- Asynchronous communication
- Decoupled handlers
- Multiple handlers possible
- Used for side effects

### Mechanism 3: Value Objects

**Application creates, Domain validates**:

```csharp
// Application Layer - Creates value object
public class CreateTankCommandHandler
{
    public async Task<Result<Guid>> Handle(CreateTankCommand command)
    {
        // Application creates value object
        // Domain validates during creation
        var capacity = TankCapacity.Create(
            command.Capacity,      // ← Application provides data
            command.CapacityUnit   // ← Application provides data
        );
        // ↑ Domain validates: capacity > 0, valid unit, etc.
        
        var tank = Tank.Create(command.Name, capacity, location, tankType);
    }
}

// Domain Layer - Validates value object
public sealed class TankCapacity : ValueObject
{
    public static TankCapacity Create(decimal value, string unit)
    {
        // Domain validates business rules
        if (value <= 0)
            throw new ArgumentException("Capacity must be positive");
        
        if (string.IsNullOrWhiteSpace(unit))
            throw new ArgumentException("Unit cannot be empty");
        
        return new TankCapacity(value, unit);
    }
}
```

**Characteristics**:
- Validation at creation
- Immutable after creation
- Self-validating
- Used for domain concepts

---

## 4. Data Flow

### Command Flow (Write Operation) - All Layers

```
1. Frontend Layer
   └─> User clicks "Create Tank" button
   └─> Calls tankStore.createTank(command)

2. Frontend Layer (Service)
   └─> HTTP POST /api/tanks
   └─> HttpClient sends request

3. Backend: Application Layer (API Controller)
   └─> Receives HTTP POST /api/tanks
   └─> Creates CreateTankCommand
   └─> Sends to MediatR

4. Backend: Application Layer (MediatR)
   └─> Routes to CreateTankCommandHandler

5. Backend: Application Layer (ValidationBehavior)
   └─> Validates CreateTankCommand (FluentValidation)

6. Backend: Application Layer (Handler)
   └─> Checks repository (via ITankRepository interface)
       └─> Infrastructure: TankRepository.GetByNameAsync()
           └─> Queries Read Model database
   └─> Creates value objects (Domain validates)
   └─> Calls Tank.Create() (Domain)
       └─> Domain validates business rules
       └─> Domain creates aggregate
       └─> Domain raises TankCreatedEvent
   └─> Saves to repository (via ITankRepository interface)
       └─> Infrastructure: TankRepository.AddAsync()
           └─> Collects domain events
           └─> Prepares to save to Event Store
   └─> Commits changes (via IUnitOfWork interface)
       └─> Infrastructure: UnitOfWork.SaveChangesAsync()
           └─> Saves events to Event Store database
           └─> Commits Event Store transaction
           └─> Publishes domain events to Kafka

7. Backend: Infrastructure Layer (Projection Handler)
   └─> TankProjectionHandler receives TankCreatedEvent
   └─> Updates Read Model (TankReadModel)
   └─> Saves to Read Model database

8. Backend: Infrastructure Layer (Kafka Publisher)
   └─> Publishes TankCreatedEvent to Kafka topic

9. Data Engineering Layer (Kafka Consumer)
   └─> Kafka receives TankCreatedEvent
   └─> Kafka Streams processes event
   └─> Updates TimescaleDB time-series data
   └─> Triggers ML feature engineering
   └─> Updates analytics aggregations

10. Backend: Application Layer (Event Handler)
    └─> TankCreatedEventHandler receives event
    └─> Logs, sends notifications, etc.

11. Backend: Infrastructure Layer (SignalR)
    └─> Publishes TankCreatedEvent to connected clients

12. Frontend Layer
    └─> RealTimeStore receives TankCreatedEvent
    └─> TankStore updates UI
    └─> Returns HTTP 201 Created with tank ID
```

### Query Flow (Read Operation) - All Layers

```
1. Presentation Layer
   └─> HTTP GET /api/tanks?page=1
   └─> Creates GetTanksQuery
   └─> Sends to MediatR

2. Application Layer (MediatR)
   └─> Routes to GetTanksQueryHandler

3. Application Layer (Handler)
   └─> Builds specification (filter)
   └─> Queries repository (via ITankRepository interface)
       └─> Infrastructure: TankRepository.GetPagedAsync()
           └─> Queries Read Model database (fast, optimized)
           └─> Gets TankReadModel entities
           └─> Converts to Domain aggregates (if needed)
   └─> Maps Domain to DTOs
   └─> Returns PagedResult<TankDto>

4. Presentation Layer
   └─> Returns HTTP 200 OK with JSON data
```

---

## 5. Responsibility Matrix

### Who Does What?

| Responsibility | Domain | Application | Infrastructure | Frontend | Data Engineering |
|----------------|--------|-------------|----------------|----------|------------------|
| **Business Rules** | ✅ Yes | ❌ No | ❌ No | ❌ No | ❌ No |
| **Validation** | ✅ Business rules | ✅ Input validation | ❌ No | ✅ Form validation | ❌ No |
| **State Changes** | ✅ Methods | ❌ No (calls Domain) | ❌ No | ❌ No | ❌ No |
| **Orchestration** | ❌ No | ✅ Yes | ❌ No | ❌ No | ❌ No |
| **Persistence** | ❌ No | ❌ No (defines interfaces) | ✅ Yes (implements) | ❌ No | ✅ Yes (TimescaleDB) |
| **Event Storage** | ❌ No | ❌ No | ✅ Yes (Event Store) | ❌ No | ❌ No |
| **Read Models** | ❌ No | ❌ No | ✅ Yes (maintains) | ❌ No | ❌ No |
| **Projections** | ❌ No | ❌ No | ✅ Yes (updates read models) | ❌ No | ❌ No |
| **Event Handling** | ✅ Raises events | ✅ Handles events | ✅ Projects events | ✅ Receives events | ✅ Consumes events |
| **DTO Mapping** | ❌ No | ✅ Yes | ❌ No | ✅ Yes | ❌ No |
| **Use Cases** | ❌ No | ✅ Yes | ❌ No | ❌ No | ❌ No |
| **Error Handling** | ✅ Exceptions | ✅ Result pattern | ✅ Logging | ✅ Error UI | ✅ Logging |
| **External Services** | ❌ No | ❌ No | ✅ Yes (AWS, etc.) | ❌ No | ❌ No |
| **Database Access** | ❌ No | ❌ No | ✅ Yes (EF Core) | ❌ No | ✅ Yes (TimescaleDB) |
| **Stream Processing** | ❌ No | ❌ No | ❌ No | ❌ No | ✅ Yes (Kafka Streams) |
| **ML Features** | ❌ No | ❌ No | ❌ No | ❌ No | ✅ Yes (Feature Engineering) |
| **Analytics** | ❌ No | ❌ No | ❌ No | ❌ No | ✅ Yes (Analytics Functions) |
| **User Interface** | ❌ No | ❌ No | ❌ No | ✅ Yes | ❌ No |
| **Client State** | ❌ No | ❌ No | ❌ No | ✅ Yes (Pinia) | ❌ No |

---

## 6. Example: Complete Use Case

### Use Case: Create and Activate Tank

```csharp
// STEP 1: Application receives command
public class CreateTankCommandHandler
{
    public async Task<Result<Guid>> Handle(CreateTankCommand command)
    {
        // STEP 2: Application validates input
        var existing = await _repository.GetByNameAsync(command.Name);
        if (existing != null)
            return Error.Conflict("Tank.Exists", "Tank already exists");
        
        // STEP 3: Application creates Domain value objects
        var capacity = TankCapacity.Create(command.Capacity, command.CapacityUnit);
        var location = Location.Create(command.Building, command.Room);
        
        // STEP 4: Application calls Domain factory
        var tank = Tank.Create(command.Name, capacity, location, command.TankType);
        // Domain validates, creates, raises TankCreatedEvent
        
        // STEP 5: Application saves
        await _repository.AddAsync(tank);
        await _unitOfWork.SaveChangesAsync();
        
        // STEP 6: Application activates tank (if sensors exist)
        if (command.AutoActivate && tank.Sensors.Any())
        {
            tank.Activate();  // Domain validates, changes state, raises TankActivatedEvent
            await _repository.UpdateAsync(tank);
            await _unitOfWork.SaveChangesAsync();
        }
        
        return Result.Success(tank.Id.Value);
    }
}

// Domain Layer - Business logic
public sealed class Tank : AggregateRoot<TankId>
{
    public static Tank Create(string name, TankCapacity capacity, Location location, TankType tankType)
    {
        // Domain validates business rules
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Tank name cannot be empty");
        
        var tankId = TankId.Create();
        var tank = new Tank(tankId, name, capacity, location, tankType);
        tank.Apply(new TankCreatedEvent(tankId, name, capacity, location, tankType));
        return tank;
    }
    
    public void Activate()
    {
        // Domain enforces business rule
        if (Status == TankStatus.Active) return;
        
        if (!_sensors.Any(s => s.IsActive))
            throw new InvalidOperationException("Tank must have at least one active sensor");
        
        Status = TankStatus.Active;
        Apply(new TankActivatedEvent(Id));
    }
}
```

---

## 7. Error Handling Collaboration

### Domain Throws Exceptions

```csharp
// Domain Layer
public static TankCapacity Create(decimal value, string unit)
{
    if (value <= 0)
        throw new ArgumentException("Capacity must be positive");  // ← Domain throws
    
    return new TankCapacity(value, unit);
}
```

### Application Catches and Converts

```csharp
// Application Layer
public async Task<Result<Guid>> Handle(CreateTankCommand command)
{
    try
    {
        var capacity = TankCapacity.Create(command.Capacity, command.CapacityUnit);
        // Domain might throw exception
    }
    catch (ArgumentException ex)
    {
        // Application converts exception to Result
        return Error.Validation("Tank.ValidationError", ex.Message);
    }
}
```

**Why This Works**:
- Domain uses exceptions (standard .NET)
- Application converts to Result pattern (API-friendly)
- Clear separation of concerns

---

## 8. Event-Driven Collaboration

### Domain Raises, Application Reacts

```csharp
// Domain Layer - Raises event
public void ScheduleMaintenance(DateTime maintenanceDate)
{
    if (maintenanceDate <= DateTime.UtcNow)
        throw new ArgumentException("Maintenance date must be in the future");
    
    NextMaintenanceDate = maintenanceDate;
    Apply(new TankMaintenanceScheduledEvent(Id, maintenanceDate));  // ← Event raised
}

// Application Layer - Multiple handlers react
public class MaintenanceScheduledEventHandler : INotificationHandler<TankMaintenanceScheduledEvent>
{
    public async Task Handle(TankMaintenanceScheduledEvent notification, CancellationToken ct)
    {
        // Handler 1: Send notification
        await _notificationService.SendMaintenanceReminder(notification.TankId, notification.ScheduledDate);
    }
}

public class MaintenanceCalendarHandler : INotificationHandler<TankMaintenanceScheduledEvent>
{
    public async Task Handle(TankMaintenanceScheduledEvent notification, CancellationToken ct)
    {
        // Handler 2: Update calendar
        await _calendarService.AddMaintenanceEvent(notification.TankId, notification.ScheduledDate);
    }
}
```

**Benefits**:
- Domain doesn't know about handlers
- Multiple handlers can react
- Easy to add new handlers
- Decoupled collaboration

---

## 9. Real-World Analogy

Think of **Domain and Application** like a **construction project**:

**Domain Layer (Architect/Engineer)**:
- Designs the building (business rules)
- Ensures structural integrity (validation)
- Defines requirements (interfaces)
- Independent of construction method

**Application Layer (Project Manager)**:
- Coordinates construction (orchestrates)
- Hires contractors (infrastructure)
- Follows architect's plans (uses Domain)
- Manages the process (use cases)

**Working Together**:
- Architect (Domain) designs
- Project Manager (Application) coordinates
- Contractors (Infrastructure) build
- Result: Complete building (use case)

---

## 10. Summary

**How All Layers Work Together**:

1. **Application Orchestrates**:
   - Receives requests
   - Coordinates operations
   - Calls Domain methods
   - Uses Infrastructure via interfaces
   - Exposes APIs for Frontend

2. **Domain Executes**:
   - Validates business rules
   - Enforces invariants
   - Changes state
   - Raises events
   - Defines interfaces

3. **Infrastructure Provides**:
   - Implements data persistence
   - Provides external services
   - Implements Domain and Application interfaces
   - Updates read models
   - Manages transactions
   - Publishes events to Kafka
   - Cloud infrastructure deployment (AWS EKS, RDS, ElastiCache)
   - Container orchestration (Kubernetes)
   - Monitoring and observability (CloudWatch, Prometheus, Grafana)

4. **Frontend Provides**:
   - User interface and experience
   - Client-side state management
   - Communicates with backend via API
   - Real-time updates via SignalR

5. **Data Engineering Analyzes**:
   - Consumes domain events (via Kafka)
   - Processes events in real-time
   - Stores time-series data
   - Engineers ML features
   - Provides analytics and predictions

6. **Communication Mechanisms**:
   - Direct method calls (Application → Domain)
   - Interface calls (Application → Infrastructure)
   - HTTP/WebSocket (Frontend → Backend API)
   - Domain events (Domain → Infrastructure → Kafka → Data Engineering)
   - Real-time events (Infrastructure → SignalR → Frontend)
   - Value objects (validation at Domain level)

7. **Clear Responsibilities**:
   - Domain: Business logic and interfaces
   - Application: Use cases, orchestration, and APIs
   - Infrastructure: Persistence, external services, event publishing, cloud deployment
   - Frontend: User interface and client state
   - Data Engineering: Analytics, ML features, time-series processing

8. **Infrastructure Deployment (AWS DevOps)**:
   - Infrastructure as Code (Terraform) for reproducible deployments
   - EKS cluster for container orchestration
   - RDS PostgreSQL with TimescaleDB for time-series data
   - ElastiCache Redis for caching and session storage
   - S3 and EFS for scalable storage
   - VPC networking with security groups
   - CloudWatch, Prometheus, and Grafana for monitoring
   - Multi-environment support (dev, staging, prod)

**Key Takeaway**: Application layer is the conductor, Domain layer is the orchestra, Infrastructure layer is the stage crew, Frontend layer is the audience, and Data Engineering layer is the recording studio. Application orchestrates and coordinates, Domain performs the business logic, Infrastructure provides the technical foundation and publishes events, Frontend provides the user experience, and Data Engineering analyzes events for analytics and ML. They work together seamlessly, with clear boundaries and responsibilities, to implement a complete, production-ready system with advanced analytics capabilities.

