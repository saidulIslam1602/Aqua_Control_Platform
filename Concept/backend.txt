# Theoretical Concepts: Entity.cs Base Class

## 1. What is an Entity in Domain-Driven Design (DDD)?

An **Entity** is a domain object that has:
- **Identity**: A unique identifier that distinguishes it from other entities
- **Lifecycle**: Can be created, modified, and potentially deleted
- **Mutable State**: Properties can change over time, but identity remains constant

**Key Principle**: Two entities are considered equal if they have the same ID, regardless of other property values.

### Example in AquaCulture Platform:
- A `Tank` entity with ID `tank-123` is the same tank even if its water level changes
- A `Sensor` entity with ID `sensor-456` remains the same sensor even if its readings update

---

## 2. The Entity Base Class Pattern

### Why Use a Base Class?

**Code Reusability**: Instead of implementing identity, equality, and event tracking in every entity, we create a base class that provides:
- Common identity management
- Consistent equality comparison
- Domain event tracking infrastructure
- Standardized behavior across all entities

**Benefits**:
- **DRY Principle**: Don't Repeat Yourself - write once, use everywhere
- **Consistency**: All entities behave the same way
- **Maintainability**: Fix bugs or add features in one place
- **Type Safety**: Compiler enforces correct usage

---

## 3. Generic Type Parameter (TId)

### What is `<TId>`?

The `Entity<TId>` uses a **generic type parameter** to allow flexible ID types:

```csharp
Entity<Guid>     // For entities with GUID IDs
Entity<int>      // For entities with integer IDs
Entity<string>   // For entities with string IDs
```

### Why Generic?

**Flexibility**: Different entities might need different ID types:
- `Tank` might use `Guid` for globally unique IDs
- `SensorReading` might use `long` for sequential IDs
- `User` might use `string` for email-based IDs

**Type Safety**: The compiler ensures you use the correct ID type for each entity.

**Constraint**: `where TId : notnull` ensures IDs can never be null, preventing null reference errors.

---

## 4. Abstract Class Concept

### What Does "Abstract" Mean?

An **abstract class**:
- Cannot be instantiated directly: `new Entity<Guid>()` ❌ (compiler error)
- Must be inherited: `class Tank : Entity<Guid>` ✅
- Provides common functionality to derived classes
- Can have both implemented and abstract members

### Why Abstract for Entity?

**Design Intent**: We don't want to create "just an entity" - we want specific entities like `Tank`, `Sensor`, etc.

**Enforcement**: Forces developers to create concrete entity classes with meaningful names and behavior.

---

## 5. Entity Identity and Equality

### Identity-Based Equality

**Core Principle**: Two entities are equal if and only if they have the same ID.

**Why?**
- An entity's identity is its most fundamental characteristic
- Properties can change, but identity remains constant
- This matches real-world understanding: "This is the same tank, even though the water level changed"

### Implementation Strategy

1. **IEquatable<T>**: Provides type-safe comparison
2. **Object.Equals**: Provides compatibility with older code
3. **GetHashCode**: Required for hash-based collections (Dictionary, HashSet)
4. **Operator Overloading**: Allows `==` and `!=` operators

**Important**: All four must be implemented together for correct behavior.

---

## 6. Domain Events Pattern

### What are Domain Events?

**Domain Events** represent something significant that happened in the domain:
- "Tank water level dropped below threshold"
- "Sensor reading exceeded maximum value"
- "Tank maintenance scheduled"

### Why Track Events in Entities?

**Event-Driven Architecture**: 
- Entities raise events when important things happen
- Other parts of the system can react to these events
- Decouples the entity from event handlers

**Example Flow**:
1. Entity changes state: `tank.UpdateWaterLevel(50)`
2. Entity raises event: `tank.AddDomainEvent(new WaterLevelLowEvent(...))`
3. Entity is saved to database
4. Events are published: `eventPublisher.Publish(tank.DomainEvents)`
5. Event handlers react: Send alert, update dashboard, etc.

### [NotMapped] Attribute

**Purpose**: Tells Entity Framework Core "don't store this in the database"

**Why?**: Domain events are:
- Temporary (published and cleared after persistence)
- Not part of the entity's persistent state
- Used for communication, not storage

---

## 7. Protected Members and Encapsulation

### Protected Access Modifier

**Protected** means:
- Accessible within the class itself
- Accessible in derived classes (like `Tank : Entity<Guid>`)
- **NOT** accessible from outside the class hierarchy

### Why Protected?

**Encapsulation**: 
- `Id` setter is protected: Only the entity itself or derived classes can set it
- Prevents external code from changing IDs incorrectly
- Maintains data integrity

**Example**:
```csharp
var tank = new Tank(Guid.NewGuid());
tank.Id = Guid.NewGuid(); // ❌ Compiler error - setter is protected
```

---

## 8. Constructor Pattern

### Two Constructors - Why?

1. **Parameterized Constructor**: `Entity(TId id)`
   - Used when creating new entities
   - Ensures every entity has an ID from the start
   - Enforces business rule: "Every entity must have an identity"

2. **Parameterless Constructor**: `Entity()`
   - Required by Entity Framework Core
   - EF Core uses reflection to create instances from database rows
   - EF Core will set the ID from the database after construction

**Note**: This is a common pattern when using ORMs with DDD.

---

## 9. Read-Only Collections Pattern

### IReadOnlyList<T>

**Why not return `List<IDomainEvent>` directly?**

**Encapsulation**: 
- Prevents external code from modifying the internal list
- External code can read events but cannot add/remove directly
- Forces use of controlled methods: `AddDomainEvent()`, `ClearDomainEvents()`

**Benefits**:
- Maintains control over when events are added
- Prevents accidental modifications
- Allows validation or logging in `AddDomainEvent()`

---

## 10. Nullable Reference Types

### The `?` Symbol

`Entity<TId>?` means "this can be null"

**Why?**
- Allows comparison with null values
- Prevents null reference exceptions
- Makes nullability explicit in the code

**Example**:
```csharp
Entity<Guid>? entity = null;
if (entity != null) { ... } // Safe null check
```

---

## 11. Architecture Role

### Where Entity Fits in Clean Architecture

```
┌─────────────────────────────────────┐
│   Presentation Layer (API)          │
├─────────────────────────────────────┤
│   Application Layer (Use Cases)     │
├─────────────────────────────────────┤
│   Domain Layer ← Entity.cs is HERE  │  ← Core business logic
├─────────────────────────────────────┤
│   Infrastructure Layer (Database)   │
└─────────────────────────────────────┘
```

**Domain Layer**:
- Contains business rules and domain logic
- Independent of databases, APIs, or frameworks
- `Entity.cs` provides the foundation for all domain entities

**Dependency Rule**: 
- Domain layer has NO dependencies on other layers
- All other layers depend on Domain layer
- This ensures business logic is never contaminated by technical concerns

---

## 12. Design Patterns Used

### 1. Template Method Pattern
- Base class defines structure (identity, equality, events)
- Derived classes provide specific behavior

### 2. Identity Map Pattern
- Each entity has a unique identity
- Same ID = same entity instance

### 3. Domain Events Pattern
- Entities raise events for significant domain occurrences
- Enables event-driven architecture

### 4. Value Object vs Entity
- **Entity**: Has identity, mutable, compared by ID
- **Value Object**: No identity, immutable, compared by all properties

---

## 13. Real-World Analogy

Think of `Entity<TId>` like a **birth certificate**:

- **ID**: Like a social security number - unique and permanent
- **Properties**: Like address, name - can change over time
- **Equality**: Two people with the same SSN are the same person
- **Events**: Like life events (birth, marriage) - significant occurrences
- **Base Class**: Like a standard form - all birth certificates have the same structure

---

## Summary

The `Entity<TId>` base class provides:

1. **Identity Management**: Every entity has a unique, non-null ID
2. **Equality Comparison**: Type-safe, ID-based equality
3. **Domain Events**: Infrastructure for event-driven architecture
4. **Consistency**: Standardized behavior across all entities
5. **Type Safety**: Generic types ensure correct ID usage
6. **Encapsulation**: Protected members maintain data integrity
7. **Framework Integration**: Works with EF Core and .NET collections

**In Simple Terms**: It's the foundation that makes all your domain entities (Tank, Sensor, etc.) work consistently and correctly, following Domain-Driven Design principles.

---

## Additional Notes

### [NotMapped] Attribute
The `[NotMapped]` attribute tells Entity Framework Core not to map a property to a database column.

### IEquatable<T> - Short Explanation

**IEquatable<T>** is an interface that lets a type compare itself to another instance of the same type in a type-safe way.

**Purpose**:
- Defines a type-safe equality method
- Avoids casting to `object`
- Improves performance by avoiding boxing

**In Your Entity Class**:
- Implements `IEquatable<Entity<TId>>`
- Provides `Equals(Entity<TId>? other)` that compares by ID
- Enables direct comparisons like `tank1.Equals(tank2)`

**Benefits**:
1. Type safety: compiler ensures you compare the right types
2. Performance: no boxing or casting
3. Cleaner code: direct comparison without casts
4. Framework support: works well with collections and LINQ

**Real-World Analogy**: Like a contract: "I can compare myself to another entity of my type." It makes comparisons straightforward and efficient.

**In simple terms**: It lets your entities compare themselves to each other in a type-safe, efficient way.
