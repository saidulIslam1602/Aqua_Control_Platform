# Theoretical Concepts: Domain Events in Domain-Driven Design (DDD)

## 1. What is a Domain Event?

A **Domain Event** represents something significant that happened in the domain - a fact that occurred in the past.

**Key Characteristics**:
- **Immutable**: Once created, an event cannot be changed (it's a fact)
- **Past Tense**: Events describe what happened (e.g., "TankCreated", not "CreateTank")
- **Significant**: Only important occurrences become events, not every property change
- **Decoupled**: Events allow different parts of the system to react without knowing about each other

### Example in AquaCulture Platform:
- ✅ `TankCreatedEvent` - A new tank was created
- ✅ `TankActivatedEvent` - A tank was activated and became operational
- ✅ `SensorAddedToTankEvent` - A sensor was installed in a tank
- ❌ `TankNameChangedEvent` - Minor change, might not need an event (depends on business requirements)

---

## 2. Why Domain Events?

### Problem: Tight Coupling

**Without Events**:
```csharp
// Tank entity directly calls notification service
tank.UpdateWaterLevel(50);
notificationService.SendAlert("Water level low");  // ❌ Tight coupling
dashboardService.UpdateDisplay(tank);              // ❌ Tight coupling
```

**Issues**:
- Tank entity knows about notification and dashboard services
- Hard to add new features (must modify Tank class)
- Difficult to test (need to mock multiple services)
- Violates Single Responsibility Principle

### Solution: Domain Events

**With Events**:
```csharp
// Tank entity raises event
tank.UpdateWaterLevel(50);
tank.AddDomainEvent(new WaterLevelLowEvent(tank.Id, 50));

// Later, after saving...
// Event handlers react independently
eventHandler1.SendAlert(event);      // ✅ Decoupled
eventHandler2.UpdateDashboard(event); // ✅ Decoupled
eventHandler3.LogToDatabase(event);   // ✅ Easy to add
```

**Benefits**:
- ✅ Tank entity doesn't know about handlers
- ✅ Easy to add new handlers (just register them)
- ✅ Easy to test (test entity separately from handlers)
- ✅ Follows Open/Closed Principle

---

## 3. The IDomainEvent Interface

### Purpose

`IDomainEvent` is a **contract** that all domain events must follow. It ensures:
- All events have consistent structure
- Events can be handled uniformly
- Events integrate with MediatR for publishing

### Interface Members

1. **EventId (Guid)**: Unique identifier for each event instance
2. **OccurredOn (DateTime)**: When the event happened
3. **EventType (string)**: Type name for serialization/routing

### Why These Properties?

**EventId**:
- Uniquely identifies each event instance
- Enables event deduplication (prevent processing same event twice)
- Allows event correlation and tracking
- Required for event sourcing

**OccurredOn**:
- Records when the event actually happened
- Important for audit trails and debugging
- Used for event ordering in event stores
- UTC timezone ensures consistency across servers

**EventType**:
- Identifies the event type for serialization
- Used to route events to correct handlers
- Enables polymorphic event handling
- Required for event store persistence

---

## 4. The DomainEvent Base Record

### Why a Record Type?

**Records** in C# provide:
- **Immutability**: Properties are read-only by default
- **Value Equality**: Two events with same data are equal
- **Concise Syntax**: Less boilerplate code
- **Deconstruction**: Easy to extract values

**Perfect for Events**:
- Events are immutable facts (can't change what happened)
- Events should be compared by value (same event = same data)
- Events are data containers (records are ideal)

### Automatic Property Initialization

**EventId = Guid.NewGuid()**:
- Automatically generates unique ID for each event instance
- Developers don't need to remember to set it
- Ensures every event has an ID
- Prevents duplicate IDs from manual assignment

**OccurredOn = DateTime.UtcNow**:
- Automatically captures when event occurred
- UTC ensures consistency across different server timezones
- No daylight saving time issues
- Standard practice for distributed systems

**EventType (Abstract)**:
- Forces each event class to specify its type name
- Type safety: Compiler ensures it's implemented
- Self-documenting: Event type is explicit
- Prevents mistakes: Can't forget to set it

### Implementation Pattern

```csharp
public sealed record TankCreatedEvent(
    TankId TankId,
    string Name,
    TankCapacity Capacity,
    Location Location,
    TankType TankType
) : DomainEvent
{
    public override string EventType => nameof(TankCreatedEvent);
}
```

**Why `nameof()`?**
- Type-safe: Refactoring tools update it automatically
- No magic strings: Compiler catches typos
- Self-documenting: Clearly shows the type name

---

## 5. Event-Driven Architecture Flow

### Complete Event Lifecycle

```
1. Domain Action
   └─> tank.Activate()
   
2. Entity Raises Event
   └─> tank.Apply(new TankActivatedEvent(tank.Id))
   
3. Entity Persisted
   └─> repository.Save(tank)
   
4. Events Extracted
   └─> var events = tank.DomainEvents
   
5. Events Published
   └─> await mediator.Publish(domainEvent)
   
6. Handlers Invoked (in parallel)
   ├─> AlertHandler.Handle(event)
   ├─> DashboardHandler.Handle(event)
   └─> LoggingHandler.Handle(event)
   
7. Events Cleared
   └─> tank.ClearDomainEvents()
```

### Key Points

- Events are raised **before** persistence
- Events are published **after** successful persistence
- Events are cleared **after** publishing
- Multiple handlers can process same event
- Handlers run independently (decoupled)

---

## 6. Tank Events in AquaCulture Platform

### Lifecycle Events

**TankCreatedEvent**:
- Raised when a new tank is created
- Captures initial state: ID, name, capacity, location, type
- Enables: Initialization of monitoring systems, inventory tracking, audit trail

**TankActivatedEvent**:
- Raised when tank becomes operational
- Simple event with just TankId
- Enables: Start monitoring, activate sensors, update dashboards

**TankDeactivatedEvent**:
- Raised when tank is taken out of service
- Includes reason for deactivation
- Enables: Stop monitoring, schedule maintenance, update status displays

### Property Change Events

**TankNameChangedEvent**:
- Raised when tank name is modified
- Captures both old and new values
- Enables: Audit trail, history tracking, UI updates

**TankCapacityChangedEvent**:
- Raised when tank capacity is modified
- Captures both old and new capacity value objects
- Enables: Capacity validation, monitoring adjustments, reporting updates

**TankRelocatedEvent**:
- Raised when tank is moved to different location
- Captures both old and new location value objects
- Enables: Inventory management, location-based routing, facility planning

### Configuration Events

**TankOptimalParametersSetEvent**:
- Raised when optimal water quality parameters are configured
- Contains WaterQualityParameters value object
- Enables: Alert threshold configuration, monitoring setup, compliance tracking

### Maintenance Events

**TankMaintenanceScheduledEvent**:
- Raised when maintenance is scheduled
- Contains scheduled date/time
- Enables: Calendar integration, reminder notifications, resource planning

**TankMaintenanceCompletedEvent**:
- Raised when maintenance is finished
- Contains completion date and notes
- Enables: Maintenance history, compliance reporting, next maintenance calculation

### Sensor Management Events

**SensorAddedToTankEvent**:
- Raised when sensor is installed in tank
- Contains TankId, SensorId, and SensorType
- Enables: Sensor inventory tracking, monitoring setup, dashboard updates

**SensorRemovedFromTankEvent**:
- Raised when sensor is removed from tank
- Contains TankId and SensorId
- Enables: Inventory updates, monitoring cleanup, alert configuration updates

---

## 7. Event Naming Conventions

### Best Practices

**Past Tense**: Events describe what happened
- ✅ `TankCreatedEvent`
- ✅ `TankActivatedEvent`
- ✅ `SensorAddedToTankEvent`
- ❌ `CreateTankEvent` (present tense)
- ❌ `TankCreationEvent` (noun, not past tense)

**Descriptive**: Name clearly indicates what occurred
- ✅ `TankOptimalParametersSetEvent`
- ✅ `SensorRemovedFromTankEvent`
- ❌ `TankEvent` (too vague)
- ❌ `ParameterEvent` (unclear what happened)

**Domain Language**: Use domain terminology
- ✅ `TankMaintenanceScheduledEvent`
- ✅ `TankRelocatedEvent`
- ❌ `TankMovedEvent` (technical term, not domain term)

**Consistent Patterns**:
- `[Entity][Action]Event` - e.g., `TankCreatedEvent`
- `[Entity][Property][Action]Event` - e.g., `TankNameChangedEvent`
- `[Entity][Relationship][Action]Event` - e.g., `SensorAddedToTankEvent`

---

## 8. Event Properties Design

### What Should Events Contain?

**Include**:
- ✅ Entity ID (which entity raised the event)
- ✅ Relevant data (what changed)
- ✅ Context (when, where, why)
- ✅ Old/New values for change events (for audit trail)

**Don't Include**:
- ❌ Entire entity state (too much data)
- ❌ Database-specific fields (breaks domain purity)
- ❌ Computed values (can be calculated from data)
- ❌ Sensitive information (unless necessary)

### Example: Good Event Design

```csharp
public sealed record TankCapacityChangedEvent(
    TankId TankId,
    TankCapacity OldCapacity,
    TankCapacity NewCapacity
) : DomainEvent
{
    public override string EventType => nameof(TankCapacityChangedEvent);
}
```

**Why Good?**
- Contains only necessary data
- Clear and descriptive
- Immutable (record type)
- Self-contained (all context included)
- Includes both old and new values for audit

### Example: Bad Event Design

```csharp
// ❌ Bad - includes entire entity
public sealed record TankUpdatedEvent(Tank Tank) : DomainEvent;

// ❌ Bad - missing context
public sealed record CapacityChangedEvent(decimal Capacity) : DomainEvent;

// ❌ Bad - present tense
public sealed record CreateTankEvent(...) : DomainEvent;
```

---

## 9. Event Sourcing Integration

### How Events Enable Event Sourcing

**Event Sourcing** stores events as the source of truth:

```
Event Store:
  Event 1: TankCreated (TankId: 123, Name: "Tank A", Capacity: 1000L)
  Event 2: TankActivated (TankId: 123)
  Event 3: SensorAddedToTank (TankId: 123, SensorId: 456, Type: Temperature)
  Event 4: TankCapacityChanged (TankId: 123, Old: 1000L, New: 2000L)
```

**Rebuilding State**:
1. Load all events for aggregate
2. Apply each event sequentially
3. Reconstruct current state

**Benefits**:
- Complete audit trail
- Time travel (see state at any point)
- Debugging (replay events to find issues)
- Analytics (analyze event patterns)

### IDomainEvent Requirements

For event sourcing, events need:
- ✅ Unique ID (EventId) - for deduplication
- ✅ Timestamp (OccurredOn) - for ordering
- ✅ Type (EventType) - for deserialization
- ✅ Serializable data - for persistence

All provided by `IDomainEvent` interface!

---

## 10. Event Handlers

### What are Event Handlers?

**Event Handlers** are classes that react to domain events. They implement `INotificationHandler<TEvent>` from MediatR.

### Handler Example

```csharp
public class TankActivatedEventHandler : INotificationHandler<TankActivatedEvent>
{
    private readonly IMonitoringService _monitoringService;
    private readonly IDashboardService _dashboardService;
    
    public TankActivatedEventHandler(
        IMonitoringService monitoringService,
        IDashboardService dashboardService)
    {
        _monitoringService = monitoringService;
        _dashboardService = dashboardService;
    }
    
    public async Task Handle(TankActivatedEvent notification, CancellationToken cancellationToken)
    {
        // Start monitoring the tank
        await _monitoringService.StartMonitoring(notification.TankId);
        
        // Update dashboard
        await _dashboardService.UpdateTankStatus(notification.TankId, TankStatus.Active);
        
        // Log the activation
        _logger.LogInformation("Tank {TankId} was activated", notification.TankId);
    }
}
```

### Multiple Handlers

Multiple handlers can process the same event:

```csharp
// Handler 1: Send notification
public class TankActivatedNotificationHandler : INotificationHandler<TankActivatedEvent>
{
    public async Task Handle(TankActivatedEvent notification, CancellationToken cancellationToken)
    {
        await _emailService.SendActivationEmail(notification.TankId);
    }
}

// Handler 2: Update dashboard
public class TankActivatedDashboardHandler : INotificationHandler<TankActivatedEvent>
{
    public async Task Handle(TankActivatedEvent notification, CancellationToken cancellationToken)
    {
        await _dashboardService.RefreshTankDisplay(notification.TankId);
    }
}

// Handler 3: Log to audit trail
public class TankActivatedAuditHandler : INotificationHandler<TankActivatedEvent>
{
    public async Task Handle(TankActivatedEvent notification, CancellationToken cancellationToken)
    {
        await _auditService.LogActivation(notification.TankId, notification.OccurredOn);
    }
}
```

All three handlers will be invoked when `TankActivatedEvent` is published!

---

## 11. Event Publishing Pattern

### Where Events are Published

**In Application Layer** (after persistence):

```csharp
public class ActivateTankCommandHandler : IRequestHandler<ActivateTankCommand>
{
    private readonly ITankRepository _repository;
    private readonly IMediator _mediator;
    
    public async Task Handle(ActivateTankCommand request, CancellationToken cancellationToken)
    {
        // Load aggregate
        var tank = await _repository.GetByIdAsync(request.TankId);
        
        // Perform domain action (raises event internally)
        tank.Activate();
        
        // Persist aggregate
        await _repository.SaveAsync(tank);
        
        // Publish events (after successful persistence)
        var events = tank.DomainEvents;
        foreach (var domainEvent in events)
        {
            await _mediator.Publish(domainEvent, cancellationToken);
        }
        
        // Clear events
        tank.ClearDomainEvents();
    }
}
```

### Why After Persistence?

**Transaction Safety**:
- Only publish events if persistence succeeds
- Prevents handlers from processing events for non-existent entities
- Ensures data consistency

**Order Matters**:
1. Domain action (raises event)
2. Persist entity
3. Publish events
4. Clear events

---

## 12. Design Patterns Used

### 1. Observer Pattern
- Entities (observables) raise events
- Handlers (observers) react to events
- Loose coupling between components

### 2. Publish-Subscribe Pattern
- Events are published to a mediator (MediatR)
- Multiple subscribers (handlers) receive events
- No direct coupling between publisher and subscribers

### 3. Event Sourcing Pattern
- Events are the source of truth
- State is derived from events
- Complete history is maintained

### 4. Immutability Pattern
- Events are immutable (record type)
- Once created, cannot be changed
- Represents a fact that occurred

---

## 13. Real-World Analogy

Think of `Domain Events` like **newspaper articles**:

- **EventId**: Like article ID - unique identifier
- **OccurredOn**: Like publication date - when it happened
- **EventType**: Like article category - "Sports", "News", etc.
- **Data**: Like article content - what actually happened
- **Immutable**: Like a printed article - can't change it once published
- **Facts**: Like news - describes what happened, not what to do

**The Newspaper (Event Store)**:
- Stores all articles (events)
- Can replay history (read old articles)
- Complete record (nothing is lost)

**The Readers (Event Handlers)**:
- Different people read the same article
- Each person reacts differently
- No one needs to know about the others

---

## 14. Common Mistakes to Avoid

### ❌ Don't: Include Too Much Data

```csharp
// ❌ Bad - includes entire entity
public sealed record TankUpdatedEvent(Tank Tank) : DomainEvent;
```

### ✅ Do: Include Only Relevant Data

```csharp
// ✅ Good - only what changed
public sealed record TankNameChangedEvent(
    TankId TankId, 
    string OldName, 
    string NewName
) : DomainEvent;
```

### ❌ Don't: Use Present Tense

```csharp
// ❌ Bad - present tense
public sealed record CreateTankEvent(...) : DomainEvent;
```

### ✅ Do: Use Past Tense

```csharp
// ✅ Good - past tense
public sealed record TankCreatedEvent(...) : DomainEvent;
```

### ❌ Don't: Forget EventType

```csharp
// ❌ Bad - missing EventType
public sealed record TankEvent(...) : DomainEvent
{
    // Missing: public override string EventType => ...
}
```

### ✅ Do: Always Implement EventType

```csharp
// ✅ Good - EventType specified
public sealed record TankCreatedEvent(...) : DomainEvent
{
    public override string EventType => nameof(TankCreatedEvent);
}
```

### ❌ Don't: Publish Events Before Persistence

```csharp
// ❌ Bad - events published before save
tank.Activate();
await mediator.Publish(tank.DomainEvents);  // What if save fails?
await repository.Save(tank);
```

### ✅ Do: Publish Events After Persistence

```csharp
// ✅ Good - events published after save
tank.Activate();
await repository.Save(tank);
await mediator.Publish(tank.DomainEvents);  // Safe - entity is persisted
tank.ClearDomainEvents();
```

### ❌ Don't: Forget to Clear Events

```csharp
// ❌ Bad - events accumulate
tank.Activate();
await repository.Save(tank);
await mediator.Publish(tank.DomainEvents);
// Missing: tank.ClearDomainEvents();
// Next time, old events will be published again!
```

### ✅ Do: Always Clear Events After Publishing

```csharp
// ✅ Good - events cleared
tank.Activate();
await repository.Save(tank);
await mediator.Publish(tank.DomainEvents);
tank.ClearDomainEvents();  // ✅ Prevents re-publishing
```

---

## 15. Benefits Summary

### 1. Decoupling
- Entities don't know about handlers
- Handlers don't know about entities
- Easy to add/remove handlers

### 2. Scalability
- Multiple handlers can process events in parallel
- Easy to add new features (just add handler)
- No need to modify existing code

### 3. Testability
- Test entities without handlers
- Test handlers without entities
- Mock events easily

### 4. Audit Trail
- Complete history of domain occurrences
- Know what happened and when
- Enables debugging and compliance

### 5. Event Sourcing
- Events are source of truth
- Can rebuild state from events
- Time travel and analytics

### 6. Flexibility
- Add new handlers without changing domain code
- Remove handlers without breaking domain logic
- Swap implementations easily

---

## 16. Tank Events Reference

### Lifecycle Events

**TankCreatedEvent**:
```csharp
public sealed record TankCreatedEvent(
    TankId TankId,
    string Name,
    TankCapacity Capacity,
    Location Location,
    TankType TankType
) : DomainEvent;
```
- **When**: New tank is created
- **Contains**: Initial tank configuration
- **Use Cases**: Initialize monitoring, inventory tracking, audit trail

**TankActivatedEvent**:
```csharp
public sealed record TankActivatedEvent(TankId TankId) : DomainEvent;
```
- **When**: Tank becomes operational
- **Contains**: Tank ID only
- **Use Cases**: Start monitoring, activate sensors, update dashboards

**TankDeactivatedEvent**:
```csharp
public sealed record TankDeactivatedEvent(
    TankId TankId,
    string Reason
) : DomainEvent;
```
- **When**: Tank is taken out of service
- **Contains**: Tank ID and deactivation reason
- **Use Cases**: Stop monitoring, schedule maintenance, compliance tracking

### Property Change Events

**TankNameChangedEvent**:
```csharp
public sealed record TankNameChangedEvent(
    TankId TankId,
    string OldName,
    string NewName
) : DomainEvent;
```
- **When**: Tank name is modified
- **Contains**: Old and new name values
- **Use Cases**: Audit trail, history tracking, UI updates

**TankCapacityChangedEvent**:
```csharp
public sealed record TankCapacityChangedEvent(
    TankId TankId,
    TankCapacity OldCapacity,
    TankCapacity NewCapacity
) : DomainEvent;
```
- **When**: Tank capacity is modified
- **Contains**: Old and new capacity value objects
- **Use Cases**: Capacity validation, monitoring adjustments, reporting

**TankRelocatedEvent**:
```csharp
public sealed record TankRelocatedEvent(
    TankId TankId,
    Location OldLocation,
    Location NewLocation
) : DomainEvent;
```
- **When**: Tank is moved to different location
- **Contains**: Old and new location value objects
- **Use Cases**: Inventory management, location-based routing, facility planning

### Configuration Events

**TankOptimalParametersSetEvent**:
```csharp
public sealed record TankOptimalParametersSetEvent(
    TankId TankId,
    WaterQualityParameters Parameters
) : DomainEvent;
```
- **When**: Optimal water quality parameters are configured
- **Contains**: WaterQualityParameters value object
- **Use Cases**: Alert threshold configuration, monitoring setup, compliance

### Maintenance Events

**TankMaintenanceScheduledEvent**:
```csharp
public sealed record TankMaintenanceScheduledEvent(
    TankId TankId,
    DateTime ScheduledDate
) : DomainEvent;
```
- **When**: Maintenance is scheduled
- **Contains**: Scheduled date/time
- **Use Cases**: Calendar integration, reminders, resource planning

**TankMaintenanceCompletedEvent**:
```csharp
public sealed record TankMaintenanceCompletedEvent(
    TankId TankId,
    DateTime CompletionDate,
    string Notes
) : DomainEvent;
```
- **When**: Maintenance is completed
- **Contains**: Completion date and notes
- **Use Cases**: Maintenance history, compliance reporting, next maintenance calculation

### Sensor Management Events

**SensorAddedToTankEvent**:
```csharp
public sealed record SensorAddedToTankEvent(
    TankId TankId,
    SensorId SensorId,
    SensorType SensorType
) : DomainEvent;
```
- **When**: Sensor is installed in tank
- **Contains**: Tank ID, Sensor ID, and sensor type
- **Use Cases**: Sensor inventory tracking, monitoring setup, dashboard updates

**SensorRemovedFromTankEvent**:
```csharp
public sealed record SensorRemovedFromTankEvent(
    TankId TankId,
    SensorId SensorId
) : DomainEvent;
```
- **When**: Sensor is removed from tank
- **Contains**: Tank ID and Sensor ID
- **Use Cases**: Inventory updates, monitoring cleanup, alert configuration

---

## 17. Event Testing

### Testing Event Creation

```csharp
[Fact]
public void TankCreatedEvent_WithValidData_CreatesEvent()
{
    // Arrange
    var tankId = TankId.Create();
    var capacity = TankCapacity.Create(1000, "L");
    var location = Location.Create("Building A", "Room 101");
    
    // Act
    var @event = new TankCreatedEvent(
        tankId,
        "Tank A",
        capacity,
        location,
        TankType.Freshwater
    );
    
    // Assert
    Assert.NotNull(@event.EventId);
    Assert.NotEqual(Guid.Empty, @event.EventId);
    Assert.True(@event.OccurredOn <= DateTime.UtcNow);
    Assert.Equal(nameof(TankCreatedEvent), @event.EventType);
    Assert.Equal(tankId, @event.TankId);
    Assert.Equal("Tank A", @event.Name);
}
```

### Testing Event Handlers

```csharp
[Fact]
public async Task TankActivatedEventHandler_HandlesEvent_StartsMonitoring()
{
    // Arrange
    var tankId = TankId.Create();
    var @event = new TankActivatedEvent(tankId);
    var monitoringService = new Mock<IMonitoringService>();
    var handler = new TankActivatedEventHandler(monitoringService.Object, ...);
    
    // Act
    await handler.Handle(@event, CancellationToken.None);
    
    // Assert
    monitoringService.Verify(s => s.StartMonitoring(tankId), Times.Once);
}
```

---

## 18. Event Versioning

### Why Version Events?

As the domain evolves, event structures may change. Versioning allows:
- Backward compatibility
- Gradual migration
- Multiple event versions in event store

### Versioning Strategy

**Option 1: Add Version Property**:
```csharp
public sealed record TankCreatedEventV2(
    TankId TankId,
    string Name,
    TankCapacity Capacity,
    Location Location,
    TankType TankType,
    string? Description  // New field
) : DomainEvent
{
    public override string EventType => nameof(TankCreatedEventV2);
    public int Version => 2;
}
```

**Option 2: Separate Event Types**:
```csharp
// Old version
public sealed record TankCreatedEvent(...) : DomainEvent;

// New version
public sealed record TankCreatedEventV2(...) : DomainEvent;
```

---

## 19. Event Store Integration

### Storing Events

Events are stored in an event store for:
- Event sourcing
- Audit trail
- Replay capabilities
- Analytics

### Event Store Structure

```
Event Store:
  - EventId (Guid)
  - AggregateId (TankId)
  - EventType (string)
  - EventData (JSON)
  - OccurredOn (DateTime)
  - Version (int)
```

### Replaying Events

```csharp
// Load all events for a tank
var events = eventStore.GetEvents(tankId);

// Rebuild tank state
var tank = new Tank(tankId);
foreach (var @event in events)
{
    tank.ApplyEvent(@event);
}
```

---

## 20. Summary

**Domain Events** in Domain-Driven Design provide:

1. **Decoupling**: Entities and handlers don't know about each other
2. **Scalability**: Multiple handlers can process events independently
3. **Testability**: Test entities and handlers separately
4. **Audit Trail**: Complete history of domain occurrences
5. **Event Sourcing**: Events as source of truth
6. **Flexibility**: Easy to add/remove handlers

**The Tank Events** demonstrate:
- ✅ Proper event naming (past tense, descriptive)
- ✅ Appropriate data inclusion (only what's needed)
- ✅ Immutability (record types)
- ✅ Type safety (EventType property)
- ✅ Clear domain language

**In Simple Terms**: Domain events are like "news reports" of what happened in your domain. They allow different parts of your system to react to important occurrences without being tightly coupled. The Tank events track all significant changes to tanks, enabling monitoring, notifications, audit trails, and more.

**Key Takeaways**:
1. Events describe what happened (past tense)
2. Events are immutable facts
3. Events contain only necessary data
4. Events are published after persistence
5. Events enable decoupled, scalable architectures
6. Events support event sourcing and audit trails

---

## 21. Best Practices Checklist

When creating domain events, ensure:

- ✅ Event name is in past tense
- ✅ Event name is descriptive and clear
- ✅ Event contains only necessary data
- ✅ Event includes entity ID
- ✅ Event includes old/new values for change events
- ✅ Event implements EventType property
- ✅ Event is immutable (record type)
- ✅ Event uses domain language
- ✅ Event is published after persistence
- ✅ Events are cleared after publishing
- ✅ Event handlers are registered in DI container
- ✅ Event handlers are idempotent (can be safely retried)

---

This completes the comprehensive guide to Domain Events in Domain-Driven Design for the AquaCulture Platform!

