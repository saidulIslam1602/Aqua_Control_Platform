# Theoretical Concepts: ValueObject.cs Base Class

## 1. What is a Value Object in Domain-Driven Design (DDD)?

A **Value Object** is a domain object that:
- **No Identity**: Distinguished by its attributes, not an ID
- **Immutable**: Cannot be changed after creation (must create new instance)
- **Value-Based Equality**: Two value objects are equal if all their properties are equal
- **Self-Contained**: Encapsulates related values that belong together

**Key Principle**: Two value objects are considered equal if they have the same attribute values, regardless of whether they are the same instance.

### Example in AquaCulture Platform:
- `TankCapacity` (1000 L) equals another `TankCapacity` (1000 L) - same value, same unit
- `Location` (Building A, Room 101) equals another `Location` (Building A, Room 101) - same attributes
- If you need to change a value object, you create a NEW one - you don't modify the existing one

---

## 2. Value Object vs Entity

### Key Differences

| Aspect | Entity | Value Object |
|--------|--------|--------------|
| **Identity** | Has unique ID | No identity |
| **Equality** | Compared by ID | Compared by all properties |
| **Mutability** | Can be modified | Immutable (create new instance) |
| **Lifecycle** | Tracked over time | Replaced when changed |
| **Example** | `Tank` (ID: tank-123) | `TankCapacity` (1000 L) |

### Real-World Analogy

**Entity** = A person (has SSN/ID, can change address but remains same person)
**Value Object** = An address (no ID, if you move, you get a NEW address object)

### When to Use Each

**Use Entity when**:
- The object has a unique identity that matters
- The object needs to be tracked over time
- The object can change but remains the same thing
- Example: `Tank`, `Sensor`, `User`

**Use Value Object when**:
- The object is defined by its attributes
- The object doesn't need to be tracked individually
- Changing the object means creating a new one
- Example: `TankCapacity`, `Location`, `Money`, `EmailAddress`

---

## 3. Immutability - The Core Principle

### What Does "Immutable" Mean?

**Immutable** = Cannot be changed after creation. Once created, a value object's properties never change.

### Why Immutability?

**Thread Safety**: 
- Multiple threads can safely read the same value object
- No risk of concurrent modification
- No need for locks or synchronization

**Predictability**:
- Value object always has the same value
- No unexpected changes
- Easier to reason about code

**Value Semantics**:
- Can be freely copied and shared
- No side effects from sharing
- Behaves like primitive types (int, string)

### How Immutability Works

```csharp
// Create a value object
var capacity = TankCapacity.Create(1000, "L");

// ‚ùå CANNOT modify - properties are read-only
// capacity.Value = 2000; // Compiler error!

// ‚úÖ MUST create new instance to "change"
var newCapacity = capacity.ConvertTo("GAL"); // Returns NEW instance
// Original capacity is unchanged
```

---

## 4. Value-Based Equality

### How Value Objects Compare

**Core Principle**: Two value objects are equal if ALL their properties are equal.

### Implementation Strategy

The `ValueObject` base class provides:
1. **GetEqualityComponents()**: Abstract method - derived classes specify which properties to compare
2. **Equals()**: Compares all equality components
3. **GetHashCode()**: Computes hash from all equality components
4. **Operator Overloading**: `==` and `!=` operators

### Example Comparison

```csharp
var capacity1 = TankCapacity.Create(1000, "L");
var capacity2 = TankCapacity.Create(1000, "L");

bool areEqual = capacity1 == capacity2; // true - same value and unit
bool areSame = ReferenceEquals(capacity1, capacity2); // false - different instances

// Even though they're different instances, they're equal because values match
```

---

## 5. The ValueObject Base Class

### Purpose

Provides a **standardized foundation** for all value objects:
- Consistent equality comparison
- Proper hash code generation
- Operator overloading support
- Reduces boilerplate code

### Key Methods

**GetEqualityComponents()** (Abstract):
- Must be implemented by derived classes
- Returns all properties that define equality
- Used for both equality and hash code

**Equals()**:
- Compares type and all equality components
- Returns true if all components match

**GetHashCode()**:
- Combines hash codes of all equality components
- Ensures equal objects have same hash code
- Required for Dictionary, HashSet, etc.

---

## 6. TankCapacity Example - Deep Dive

### Structure

```csharp
public sealed class TankCapacity : ValueObject
{
    public decimal Value { get; }      // Read-only property
    public string Unit { get; }        // Read-only property
    
    private TankCapacity(...) { }      // Private constructor
    
    public static TankCapacity Create(...) { }  // Factory method
    public TankCapacity ConvertTo(...) { }      // Returns NEW instance
}
```

### Why Private Constructor?

**Encapsulation**: 
- Forces use of `Create()` factory method
- Ensures validation happens before creation
- Prevents invalid instances

**Example**:
```csharp
// ‚ùå Cannot do this - constructor is private
var capacity = new TankCapacity(-100, "L"); // Compiler error!

// ‚úÖ Must use factory method - validation happens
var capacity = TankCapacity.Create(1000, "L"); // Valid
var invalid = TankCapacity.Create(-100, "L"); // Throws exception
```

### Factory Method Pattern

**Why `Create()` instead of constructor?**

1. **Validation**: Can validate before creating instance
2. **Default Values**: Can provide sensible defaults
3. **Naming**: `Create()` is more descriptive than constructor
4. **Flexibility**: Can have multiple factory methods

### Immutability in Action

```csharp
var capacity = TankCapacity.Create(1000, "L");

// Convert to gallons - returns NEW instance
var inGallons = capacity.ConvertTo("GAL");

// Original is unchanged
Console.WriteLine(capacity);     // "1000.00 L"
Console.WriteLine(inGallons);    // "264.17 GAL"

// They are different instances
bool areSame = ReferenceEquals(capacity, inGallons); // false
```

---

## 7. Location Example - Deep Dive

### Structure

```csharp
public sealed class Location : ValueObject
{
    public string Building { get; }           // Read-only property
    public string Room { get; }               // Read-only property
    public string? Zone { get; }              // Optional read-only property
    public decimal? Latitude { get; }         // Optional GPS coordinate
    public decimal? Longitude { get; }        // Optional GPS coordinate
    
    private Location(...) { }                  // Private constructor
    
    public static Location Create(...) { }     // Factory method
    public string GetFullAddress() { }         // Business logic method
    public double? DistanceTo(Location other) { }  // Business logic method
}
```

### Key Features

**Required Fields**:
- Building and Room are mandatory
- Ensures every location has minimum identifying information

**Optional Fields**:
- Zone: For facilities with zone-based organization
- Latitude/Longitude: For GPS-based location tracking

**Business Logic**:
- `GetFullAddress()`: Formats location as readable string
- `DistanceTo()`: Calculates distance using Haversine formula

### Usage Examples

```csharp
// Create basic location
var location1 = Location.Create("Building A", "Room 101");
Console.WriteLine(location1); // "Building A, Room 101"

// Create with zone
var location2 = Location.Create("Building A", "Room 101", "Zone 1");
Console.WriteLine(location2.GetFullAddress()); // "Building A, Room 101, Zone 1"

// Create with GPS coordinates
var location3 = Location.Create("Building A", "Room 101", null, 40.7128m, -74.0060m);

// Calculate distance between locations
var location4 = Location.Create("Building B", "Room 202", null, 40.7589m, -73.9851m);
var distance = location3.DistanceTo(location4); // Returns distance in meters

// Equality comparison
var loc1 = Location.Create("Building A", "Room 101");
var loc2 = Location.Create("building a", "room 101"); // lowercase
bool equal = loc1 == loc2; // true (case-insensitive)
```

### Validation

```csharp
// ‚úÖ Valid locations
Location.Create("Building A", "Room 101");
Location.Create("Building A", "Room 101", "Zone 1");
Location.Create("Building A", "Room 101", null, 40.7128m, -74.0060m);

// ‚ùå Invalid - will throw exceptions
Location.Create("", "Room 101"); // Empty building
Location.Create("Building A", ""); // Empty room
Location.Create("Building A", "Room 101", null, 100m, -74.0060m); // Invalid latitude (> 90)
Location.Create("Building A", "Room 101", null, 40.7128m, 200m); // Invalid longitude (> 180)
```

### Immutability in Action

```csharp
var location = Location.Create("Building A", "Room 101");

// ‚ùå CANNOT modify - properties are read-only
// location.Building = "Building B"; // Compiler error!

// ‚úÖ MUST create new instance to "change"
var newLocation = Location.Create("Building B", "Room 202");
// Original location is unchanged
```

---

## 8. GetEqualityComponents() Method

### Purpose

Tells the base class **which properties** to use for equality comparison.

### Implementation Pattern

```csharp
protected override IEnumerable<object> GetEqualityComponents()
{
    yield return Value;                    // Compare by value
    yield return Unit.ToUpperInvariant();  // Compare by unit (case-insensitive)
}
```

### Key Points

1. **All Properties**: Include ALL properties that define equality
2. **Normalization**: Normalize values (e.g., uppercase for strings)
3. **Order Matters**: Should be consistent across instances
4. **Null Handling**: Handle null values appropriately

### Why Normalize?

```csharp
// Without normalization
var cap1 = TankCapacity.Create(1000, "L");
var cap2 = TankCapacity.Create(1000, "l"); // lowercase
bool equal = cap1 == cap2; // false (different strings)

// With normalization (ToUpperInvariant)
bool equal = cap1 == cap2; // true (normalized to uppercase)
```

---

## 9. Value Object Design Patterns

### 1. Factory Method Pattern
- Private constructor
- Public static `Create()` method
- Validation in factory method

### 2. Immutability Pattern
- Read-only properties
- Methods return new instances
- No setters

### 3. Value Semantics Pattern
- Equality by value, not reference
- Can be freely copied
- No side effects

### 4. Self-Validation Pattern
- Validation in factory method
- Invalid instances cannot be created
- Business rules enforced at creation

---

## 10. Common Value Object Examples

### Money Value Object
```csharp
public sealed class Money : ValueObject
{
    public decimal Amount { get; }
    public string Currency { get; }
    
    // Equality: Amount + Currency
}
```

### Email Address Value Object
```csharp
public sealed class EmailAddress : ValueObject
{
    public string Value { get; }
    
    // Validation: Must be valid email format
    // Equality: Normalized email (lowercase)
}
```

### Location Value Object (Your Code)
```csharp
public sealed class Location : ValueObject
{
    public string Building { get; }           // Required
    public string Room { get; }               // Required
    public string? Zone { get; }              // Optional
    public decimal? Latitude { get; }         // Optional GPS
    public decimal? Longitude { get; }        // Optional GPS
    
    public static Location Create(string building, string room, 
        string? zone = null, decimal? latitude = null, decimal? longitude = null);
    
    public string GetFullAddress();            // Formats: "Building, Room, Zone"
    public double? DistanceTo(Location other); // Haversine formula, returns meters
    
    // Equality: Building + Room + Zone + Latitude + Longitude (all normalized)
    // Validation: Building/Room required, GPS coordinates must be valid ranges
}
```

**Key Features**:
- Required fields: Building and Room
- Optional fields: Zone, GPS coordinates
- Business methods: GetFullAddress(), DistanceTo()
- GPS validation: Latitude (-90 to 90), Longitude (-180 to 180)
- Distance calculation using Haversine formula

---

## 11. Benefits of Value Objects

### 1. Type Safety
- Prevents primitive obsession (using raw strings/numbers)
- Compiler catches type mismatches
- Self-documenting code

**Without Value Object**:
```csharp
string capacity = "1000"; // What unit? What validation?
```

**With Value Object**:
```csharp
TankCapacity capacity = TankCapacity.Create(1000, "L"); // Clear, validated
```

### 2. Validation
- Business rules enforced at creation
- Invalid values cannot exist
- Reduces error handling throughout codebase

### 3. Encapsulation
- Related values grouped together
- Operations on values in one place
- Prevents scattered logic

### 4. Immutability
- Thread-safe by default
- No unexpected changes
- Easier to reason about

### 5. Domain Language
- Code expresses business concepts
- More readable and maintainable
- Closer to domain expert language

---

## 12. Value Object Best Practices

### ‚úÖ DO: Make All Properties Read-Only
```csharp
public decimal Value { get; }  // ‚úÖ Read-only
// NOT: public decimal Value { get; set; }  // ‚ùå
```

### ‚úÖ DO: Use Factory Methods
```csharp
public static TankCapacity Create(decimal value, string unit = "L")
{
    // Validation here
    return new TankCapacity(value, unit);
}
```

### ‚úÖ DO: Return New Instances for "Changes"
```csharp
public TankCapacity ConvertTo(string targetUnit)
{
    // Calculate new value
    return new TankCapacity(convertedValue, targetUnit); // NEW instance
}
```

### ‚úÖ DO: Normalize in GetEqualityComponents()
```csharp
protected override IEnumerable<object> GetEqualityComponents()
{
    yield return Value;
    yield return Unit.ToUpperInvariant(); // Normalize!
}
```

### ‚ùå DON'T: Add Setters
```csharp
public decimal Value { get; set; }  // ‚ùå Breaks immutability
```

### ‚ùå DON'T: Modify Properties
```csharp
capacity.Value = 2000;  // ‚ùå Cannot do this - property is read-only
```

### ‚ùå DON'T: Forget Validation
```csharp
// ‚ùå Bad - no validation
public TankCapacity(decimal value, string unit)
{
    Value = value; // What if value is negative?
    Unit = unit;   // What if unit is invalid?
}
```

---

## 13. Value Object vs Primitive Types

### Problem: Primitive Obsession

**Primitive Obsession** = Using primitive types (string, int, decimal) instead of domain objects.

### Example Problem

```csharp
// ‚ùå Primitive obsession
public class Tank
{
    public decimal CapacityValue { get; set; }  // What unit?
    public string CapacityUnit { get; set; }    // Scattered
}

// Problems:
// - No validation
// - Easy to mix up values
// - No unit conversion
// - Business logic scattered
```

### Solution: Value Object

```csharp
// ‚úÖ Value object
public class Tank
{
    public TankCapacity Capacity { get; set; }  // Encapsulated
}

// Benefits:
// - Validation in one place
// - Type safety
// - Unit conversion built-in
// - Business logic encapsulated
```

---

## 14. Value Object Equality Details

### How Equality Works

1. **Type Check**: Objects must be same type
2. **Component Comparison**: All equality components compared
3. **Result**: Equal only if ALL components match

### Hash Code Importance

**Critical Rule**: If two objects are equal, they MUST have the same hash code.

**Why?**
- Required for Dictionary, HashSet to work correctly
- Hash code used for quick lookup
- Equal objects must be in same hash bucket

**Implementation**:
```csharp
public override int GetHashCode()
{
    return GetEqualityComponents()
        .Select(x => x?.GetHashCode() ?? 0)
        .Aggregate((x, y) => x ^ y);  // XOR combination
}
```

### Equality Examples

```csharp
var cap1 = TankCapacity.Create(1000, "L");
var cap2 = TankCapacity.Create(1000, "L");
var cap3 = TankCapacity.Create(500, "L");

cap1 == cap2;  // true - same value and unit
cap1 == cap3;  // false - different value
cap1.Equals(cap2);  // true - same as ==
```

---

## 15. Value Object in Collections

### Dictionary Keys

Value objects work perfectly as dictionary keys:

```csharp
var capacities = new Dictionary<TankCapacity, string>();

var cap1 = TankCapacity.Create(1000, "L");
var cap2 = TankCapacity.Create(1000, "L"); // Different instance

capacities[cap1] = "Large Tank";
string value = capacities[cap2]; // ‚úÖ Works! Finds by value, not reference
```

### HashSet

Value objects work in HashSet:

```csharp
var uniqueCapacities = new HashSet<TankCapacity>();

var cap1 = TankCapacity.Create(1000, "L");
var cap2 = TankCapacity.Create(1000, "L"); // Different instance

uniqueCapacities.Add(cap1);
uniqueCapacities.Add(cap2); // ‚úÖ Not added - already exists (by value)
// HashSet contains only one element
```

---

## 16. Real-World Analogy

Think of Value Objects like **currency**:

- **No Identity**: A $100 bill is the same as another $100 bill (if genuine)
- **Immutable**: You can't change a $100 bill to $200 - you exchange it
- **Value-Based**: Two $100 bills are equal (same value)
- **Self-Contained**: Amount and currency go together
- **Replaceable**: If you need $200, you get a NEW $200 bill (or two $100 bills)

**In Code**:
```csharp
var money1 = Money.Create(100, "USD");
var money2 = Money.Create(100, "USD");
bool equal = money1 == money2; // true - same value

// Need more money? Create new instance
var moreMoney = Money.Create(200, "USD"); // NEW instance
```

---

## 17. Value Object Implementation Checklist

When creating a value object, ensure:

- ‚úÖ Inherits from `ValueObject` base class
- ‚úÖ All properties are read-only (`{ get; }`)
- ‚úÖ Constructor is private
- ‚úÖ Factory method (`Create()`) performs validation
- ‚úÖ Methods that "change" return new instances
- ‚úÖ `GetEqualityComponents()` includes all relevant properties
- ‚úÖ Properties are normalized in `GetEqualityComponents()`
- ‚úÖ `ToString()` provides meaningful representation
- ‚úÖ Business rules enforced in factory method
- ‚úÖ Sealed class (prevents inheritance if not needed)

---

## 18. Common Mistakes to Avoid

### ‚ùå Mistake 1: Mutable Properties
```csharp
public decimal Value { get; set; }  // ‚ùå Breaks immutability
```

### ‚úÖ Correct: Read-Only Properties
```csharp
public decimal Value { get; }  // ‚úÖ Immutable
```

### ‚ùå Mistake 2: Modifying Instead of Replacing
```csharp
capacity.Value = 2000;  // ‚ùå Cannot modify
```

### ‚úÖ Correct: Create New Instance
```csharp
var newCapacity = TankCapacity.Create(2000, "L");  // ‚úÖ New instance
```

### ‚ùå Mistake 3: Missing Validation
```csharp
public TankCapacity(decimal value, string unit)
{
    Value = value; // ‚ùå No validation
}
```

### ‚úÖ Correct: Validate in Factory
```csharp
public static TankCapacity Create(decimal value, string unit = "L")
{
    if (value <= 0) throw new ArgumentException(...);  // ‚úÖ Validation
    return new TankCapacity(value, unit);
}
```

### ‚ùå Mistake 4: Incomplete Equality Components
```csharp
protected override IEnumerable<object> GetEqualityComponents()
{
    yield return Value;  // ‚ùå Missing Unit!
}
```

### ‚úÖ Correct: Include All Properties
```csharp
protected override IEnumerable<object> GetEqualityComponents()
{
    yield return Value;
    yield return Unit.ToUpperInvariant();  // ‚úÖ All properties
}
```

---

## 19. Value Object and Entity Framework

### How EF Core Handles Value Objects

**Owned Entity Pattern**:
- Value objects stored as part of parent entity
- No separate table for value object
- Properties embedded in entity table

**Example**:
```csharp
public class Tank : AggregateRoot<TankId>
{
    public TankCapacity Capacity { get; private set; }  // Value object
    public Location Location { get; private set; }      // Value object
}

// In database:
// Tank table has columns:
// - Capacity_Value (decimal)
// - Capacity_Unit (string)
// - Location_Building (string)
// - Location_Room (string)
// etc.
```

### Configuration

EF Core automatically handles value objects when configured as owned entities in the DbContext configuration.

---

## 20. Value Object Performance

### Memory Considerations

**Small Value Objects**: 
- Usually small (few properties)
- Immutable = can be cached/shared
- No overhead from identity tracking

**Comparison Performance**:
- Value-based equality is fast
- Hash code computation is efficient
- Works well in collections

### Best Practices

- Keep value objects small (few properties)
- Avoid deep nesting
- Use value objects for frequently compared values

---

## 21. Summary

The `ValueObject` base class provides:

1. **Immutability**: Read-only properties, create new instances for changes
2. **Value-Based Equality**: Compare by all properties, not identity
3. **Type Safety**: Encapsulate related values with validation
4. **Consistency**: Standardized behavior across all value objects
5. **Domain Language**: Express business concepts in code
6. **Thread Safety**: Immutable = safe for concurrent access
7. **Collection Support**: Works as dictionary keys and in HashSet

**In Simple Terms**: Value objects are like "smart primitives" - they encapsulate related values (like capacity + unit), enforce business rules, and provide operations (like unit conversion). They're compared by their values, not by identity, and once created, they never change.

**Key Takeaway**: When you need to represent a concept that is defined by its attributes (like money, capacity, location), use a value object. It provides type safety, validation, and encapsulates related logic in one place.

---

## 22. TankCapacity Specific Details

### Unit Conversion Logic

The `ConvertTo()` method handles conversions between:
- **Liters (L) ‚Üî Milliliters (ML)**: 1 L = 1000 ML
- **Liters (L) ‚Üî Gallons (GAL)**: 1 L ‚âà 0.264172 GAL

### Conversion Examples

```csharp
var capacity = TankCapacity.Create(1, "L");

// Convert to milliliters
var inML = capacity.ConvertTo("ML");  // Returns 1000 ML

// Convert to gallons
var inGAL = capacity.ConvertTo("GAL");  // Returns ~0.264 GAL

// Convert back
var backToL = inML.ConvertTo("L");  // Returns 1 L
```

### Validation Rules

1. **Value must be positive**: `value > 0`
2. **Unit cannot be empty**: `!string.IsNullOrWhiteSpace(unit)`
3. **Conversion must be supported**: Throws exception for unsupported conversions

### Equality Behavior

- Case-insensitive unit comparison: "L" equals "l"
- Exact value comparison: 1000.0 equals 1000.00
- Different units are NOT equal: 1000 ML ‚â† 1 L (by equality, but equivalent by conversion)

---

## 23. Advanced Value Object Patterns

### Composite Value Objects

Value objects can contain other value objects:

```csharp
public sealed class TankSpecification : ValueObject
{
    public TankCapacity Capacity { get; }      // Value object
    public Location Location { get; }          // Value object
    public TankType Type { get; }              // Enum
    
    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Capacity;
        yield return Location;
        yield return Type;
    }
}
```

### Value Object with Methods

Value objects can have business logic:

```csharp
public sealed class TankCapacity : ValueObject
{
    // Properties...
    
    // Business logic methods
    public bool IsLargeTank() => Value > 10000;
    public bool IsSmallTank() => Value < 1000;
    public TankCapacity Add(TankCapacity other)
    {
        // Convert to same unit, add, return new instance
    }
}
```

---

## 24. Testing Value Objects

### What to Test

1. **Creation**: Valid and invalid inputs
2. **Equality**: Same and different values
3. **Immutability**: Properties cannot be modified
4. **Conversion**: Unit conversions work correctly
5. **Validation**: Invalid values are rejected
6. **Hash Code**: Equal objects have same hash

### Example Tests

```csharp
[Fact]
public void Create_WithValidInput_ReturnsInstance()
{
    var capacity = TankCapacity.Create(1000, "L");
    Assert.Equal(1000, capacity.Value);
    Assert.Equal("L", capacity.Unit);
}

[Fact]
public void Create_WithNegativeValue_ThrowsException()
{
    Assert.Throws<ArgumentException>(() => TankCapacity.Create(-100, "L"));
}

[Fact]
public void Equals_SameValues_ReturnsTrue()
{
    var cap1 = TankCapacity.Create(1000, "L");
    var cap2 = TankCapacity.Create(1000, "L");
    Assert.Equal(cap1, cap2);
}

[Fact]
public void ConvertTo_LitersToGallons_ReturnsCorrectValue()
{
    var capacity = TankCapacity.Create(1, "L");
    var inGallons = capacity.ConvertTo("GAL");
    Assert.True(inGallons.Value > 0.26m && inGallons.Value < 0.27m);
}
```

---

## 25. Value Object in Domain Model

### Where Value Objects Fit

```
Domain Model:
‚îú‚îÄ‚îÄ Entities (have identity)
‚îÇ   ‚îú‚îÄ‚îÄ Tank (AggregateRoot)
‚îÇ   ‚îî‚îÄ‚îÄ Sensor (Entity)
‚îÇ
‚îî‚îÄ‚îÄ Value Objects (no identity)
    ‚îú‚îÄ‚îÄ TankCapacity
    ‚îú‚îÄ‚îÄ Location
    ‚îî‚îÄ‚îÄ WaterQualityParameters
```

### Usage in Aggregates

```csharp
public sealed class Tank : AggregateRoot<TankId>
{
    public TankCapacity Capacity { get; private set; }  // Value object
    public Location Location { get; private set; }      // Value object
    
    public void UpdateCapacity(TankCapacity newCapacity)
    {
        // Replace value object (immutability)
        Capacity = newCapacity;  // Old instance discarded, new one assigned
        Apply(new TankCapacityChangedEvent(...));
    }
}
```

---

## 26. Final Thoughts

Value objects are a **powerful tool** in Domain-Driven Design:

- **Express Domain Concepts**: Code reads like domain language
- **Enforce Business Rules**: Invalid values cannot exist
- **Reduce Bugs**: Type safety prevents many errors
- **Improve Maintainability**: Logic encapsulated in one place
- **Enable Better Design**: Encourages thinking about domain concepts

**Remember**: 
- Value objects are **immutable** - create new instances for changes
- Value objects are **compared by value** - all properties must match
- Value objects **encapsulate validation** - invalid instances cannot be created
- Value objects **express domain concepts** - make code more readable

**In your AquaCulture Platform**:
- Use `TankCapacity` instead of `decimal capacity + string unit`
- Use `Location` instead of separate building/room/zone strings
- Use `WaterQualityParameters` instead of scattered water quality values
- Create more value objects as you discover domain concepts that are defined by their attributes

---

## 27. WaterQualityParameters Value Object - Deep Dive

### Purpose

The `WaterQualityParameters` value object encapsulates all water quality measurements for an aquaculture tank. It represents the optimal and acceptable ranges for temperature, pH, dissolved oxygen, and salinity.

### Structure

```csharp
public sealed class WaterQualityParameters : ValueObject
{
    // Temperature parameters
    public decimal? OptimalTemperature { get; }
    public decimal? MinTemperature { get; }
    public decimal? MaxTemperature { get; }
    
    // pH parameters
    public decimal? OptimalPH { get; }
    public decimal? MinPH { get; }
    public decimal? MaxPH { get; }
    
    // Dissolved oxygen parameters
    public decimal? OptimalOxygen { get; }
    public decimal? MinOxygen { get; }
    
    // Salinity parameters
    public decimal? OptimalSalinity { get; }
    public decimal? MinSalinity { get; }
    public decimal? MaxSalinity { get; }
}
```

### Key Design Decisions

**1. All Parameters are Optional (Nullable)**:
- Allows flexibility in configuration
- Not all tanks need all parameters
- Can specify only relevant parameters for specific tank types

**2. Optimal vs Min/Max Values**:
- **Optimal**: Target value for best water quality
- **Min/Max**: Acceptable range boundaries
- Allows both target-based and range-based monitoring

**3. Validation Methods**:
- `IsTemperatureInRange()`: Checks if temperature is within acceptable range
- `IsPHInRange()`: Checks if pH is within acceptable range
- `IsOxygenSufficient()`: Checks if dissolved oxygen meets minimum requirement
- `IsSalinityInRange()`: Checks if salinity is within acceptable range

### Usage Examples

**Creating Water Quality Parameters**:

```csharp
// Create with all parameters
var parameters = WaterQualityParameters.Create(
    optimalTemperature: 25.0m,
    minTemperature: 20.0m,
    maxTemperature: 30.0m,
    optimalPH: 7.5m,
    minPH: 7.0m,
    maxPH: 8.0m,
    optimalOxygen: 8.0m,
    minOxygen: 6.0m,
    optimalSalinity: 35.0m,
    minSalinity: 30.0m,
    maxSalinity: 40.0m
);

// Create with only temperature parameters
var tempOnly = WaterQualityParameters.Create(
    optimalTemperature: 25.0m,
    minTemperature: 20.0m,
    maxTemperature: 30.0m
);

// Create with minimal parameters
var minimal = WaterQualityParameters.Create(
    optimalTemperature: 25.0m
);
```

**Validation Examples**:

```csharp
var parameters = WaterQualityParameters.Create(
    minTemperature: 20.0m,
    maxTemperature: 30.0m,
    minPH: 7.0m,
    maxPH: 8.0m,
    minOxygen: 6.0m
);

// Check temperature
bool tempOk = parameters.IsTemperatureInRange(25.0m);  // true
bool tempLow = parameters.IsTemperatureInRange(15.0m); // false (below min)
bool tempHigh = parameters.IsTemperatureInRange(35.0m); // false (above max)

// Check pH
bool phOk = parameters.IsPHInRange(7.5m);  // true
bool phLow = parameters.IsPHInRange(6.5m); // false (below min)

// Check oxygen
bool oxygenOk = parameters.IsOxygenSufficient(8.0m);  // true (meets minimum)
bool oxygenLow = parameters.IsOxygenSufficient(5.0m); // false (below minimum)
```

**Using in Tank Aggregate**:

```csharp
public sealed class Tank : AggregateRoot<TankId>
{
    public WaterQualityParameters? OptimalParameters { get; private set; }
    
    public void SetOptimalParameters(WaterQualityParameters parameters)
    {
        OptimalParameters = parameters;
        Apply(new TankOptimalParametersSetEvent(Id, parameters));
    }
    
    public bool IsWaterQualityAcceptable(
        decimal temperature, 
        decimal ph, 
        decimal oxygen, 
        decimal salinity)
    {
        if (OptimalParameters == null) return true; // No parameters set
        
        return OptimalParameters.IsTemperatureInRange(temperature) &&
               OptimalParameters.IsPHInRange(ph) &&
               OptimalParameters.IsOxygenSufficient(oxygen) &&
               OptimalParameters.IsSalinityInRange(salinity);
    }
}
```

### Validation Rules

**Range Validation**:
- When both min and max are provided, min must be strictly less than max
- Applies to: Temperature, pH, and Salinity
- Oxygen only has minimum (no maximum typically needed)

**Example Validation Errors**:

```csharp
// ‚ùå Invalid - min >= max
WaterQualityParameters.Create(
    minTemperature: 30.0m,
    maxTemperature: 20.0m  // Error: Min must be less than max
);

// ‚ùå Invalid - min equals max
WaterQualityParameters.Create(
    minPH: 7.0m,
    maxPH: 7.0m  // Error: Min must be less than max
);

// ‚úÖ Valid - min < max
WaterQualityParameters.Create(
    minTemperature: 20.0m,
    maxTemperature: 30.0m  // OK
);
```

### Business Logic Methods

**1. IsTemperatureInRange(decimal temperature)**:
- Returns `true` if temperature is within min/max range (if specified)
- Returns `true` if no range is specified
- Used for temperature monitoring and alerts

**2. IsPHInRange(decimal ph)**:
- Returns `true` if pH is within min/max range (if specified)
- Returns `true` if no range is specified
- Used for pH monitoring and alerts

**3. IsOxygenSufficient(decimal oxygen)**:
- Returns `true` if oxygen meets or exceeds minimum (if specified)
- Returns `true` if no minimum is specified
- Used for dissolved oxygen monitoring and alerts

**4. IsSalinityInRange(decimal salinity)**:
- Returns `true` if salinity is within min/max range (if specified)
- Returns `true` if no range is specified
- Used for salinity monitoring and alerts

### Real-World Use Cases

**1. Tank Configuration**:
```csharp
// Set optimal parameters when creating a tank
var parameters = WaterQualityParameters.Create(
    optimalTemperature: 25.0m,
    minTemperature: 20.0m,
    maxTemperature: 30.0m,
    optimalPH: 7.5m,
    minPH: 7.0m,
    maxPH: 8.0m
);

tank.SetOptimalParameters(parameters);
```

**2. Sensor Reading Validation**:
```csharp
// Check if sensor reading is acceptable
var reading = sensor.GetLatestReading();
bool isAcceptable = tank.OptimalParameters?.IsTemperatureInRange(reading.Temperature) ?? true;
```

**3. Alert Generation**:
```csharp
// Generate alert if parameters are out of range
if (!parameters.IsTemperatureInRange(currentTemperature))
{
    alertService.SendAlert("Temperature out of acceptable range");
}
```

### Benefits

**1. Encapsulation**:
- All water quality parameters in one place
- Related values grouped together
- Easy to pass around and store

**2. Validation**:
- Range validation at creation
- Invalid ranges cannot be created
- Business rules enforced

**3. Reusability**:
- Can be used in multiple tanks
- Can be used in monitoring services
- Can be used in reporting

**4. Type Safety**:
- Compiler prevents mixing with other types
- Clear domain concept
- Self-documenting code

**5. Immutability**:
- Once created, cannot be changed
- Thread-safe
- Predictable behavior

### Common Patterns

**Pattern 1: Optional Parameters**:
```csharp
// Only specify what you need
var params = WaterQualityParameters.Create(
    optimalTemperature: 25.0m,
    minTemperature: 20.0m,
    maxTemperature: 30.0m
    // Other parameters are null/optional
);
```

**Pattern 2: Validation Before Use**:
```csharp
if (parameters != null && !parameters.IsTemperatureInRange(temperature))
{
    // Handle out of range
}
```

**Pattern 3: Default Behavior**:
```csharp
// If no parameters set, assume all readings are acceptable
bool isOk = parameters?.IsTemperatureInRange(temperature) ?? true;
```

### Integration with Domain Events

WaterQualityParameters is used in domain events:

```csharp
public sealed record TankOptimalParametersSetEvent(
    TankId TankId,
    WaterQualityParameters Parameters
) : DomainEvent;
```

This event is raised when optimal parameters are configured for a tank, enabling:
- Alert threshold configuration
- Monitoring system setup
- Compliance tracking
- Historical parameter tracking

---

This completes the comprehensive guide to Value Objects in Domain-Driven Design! üéØ

