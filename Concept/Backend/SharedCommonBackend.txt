# Theoretical Concepts: Entity.cs Base Class

## 1. What is an Entity in Domain-Driven Design (DDD)?

An **Entity** is a domain object that has:
- **Identity**: A unique identifier that distinguishes it from other entities
- **Lifecycle**: Can be created, modified, and potentially deleted
- **Mutable State**: Properties can change over time, but identity remains constant

**Key Principle**: Two entities are considered equal if they have the same ID, regardless of other property values.

### Example in AquaCulture Platform:
- A `Tank` entity with ID `tank-123` is the same tank even if its water level changes
- A `Sensor` entity with ID `sensor-456` remains the same sensor even if its readings update

---

## 2. The Entity Base Class Pattern

### Why Use a Base Class?

**Code Reusability**: Instead of implementing identity, equality, and event tracking in every entity, we create a base class that provides:
- Common identity management
- Consistent equality comparison
- Domain event tracking infrastructure
- Standardized behavior across all entities

**Benefits**:
- **DRY Principle**: Don't Repeat Yourself - write once, use everywhere
- **Consistency**: All entities behave the same way
- **Maintainability**: Fix bugs or add features in one place
- **Type Safety**: Compiler enforces correct usage

---

## 3. Generic Type Parameter (TId)

### What is `<TId>`?

The `Entity<TId>` uses a **generic type parameter** to allow flexible ID types:

```csharp
Entity<Guid>     // For entities with GUID IDs
Entity<int>      // For entities with integer IDs
Entity<string>   // For entities with string IDs
```

### Why Generic?

**Flexibility**: Different entities might need different ID types:
- `Tank` might use `Guid` for globally unique IDs
- `SensorReading` might use `long` for sequential IDs
- `User` might use `string` for email-based IDs

**Type Safety**: The compiler ensures you use the correct ID type for each entity.

**Constraint**: `where TId : notnull` ensures IDs can never be null, preventing null reference errors.

---

## 4. Abstract Class Concept

### What Does "Abstract" Mean?

An **abstract class**:
- Cannot be instantiated directly: `new Entity<Guid>()` ❌ (compiler error)
- Must be inherited: `class Tank : Entity<Guid>` ✅
- Provides common functionality to derived classes
- Can have both implemented and abstract members

### Why Abstract for Entity?

**Design Intent**: We don't want to create "just an entity" - we want specific entities like `Tank`, `Sensor`, etc.

**Enforcement**: Forces developers to create concrete entity classes with meaningful names and behavior.

---

## 5. Entity Identity and Equality

### Identity-Based Equality

**Core Principle**: Two entities are equal if and only if they have the same ID.

**Why?**
- An entity's identity is its most fundamental characteristic
- Properties can change, but identity remains constant
- This matches real-world understanding: "This is the same tank, even though the water level changed"

### Implementation Strategy

1. **IEquatable<T>**: Provides type-safe comparison
2. **Object.Equals**: Provides compatibility with older code
3. **GetHashCode**: Required for hash-based collections (Dictionary, HashSet)
4. **Operator Overloading**: Allows `==` and `!=` operators

**Important**: All four must be implemented together for correct behavior.

---

## 6. Domain Events Pattern

### What are Domain Events?

**Domain Events** represent something significant that happened in the domain:
- "Tank water level dropped below threshold"
- "Sensor reading exceeded maximum value"
- "Tank maintenance scheduled"

### Why Track Events in Entities?

**Event-Driven Architecture**: 
- Entities raise events when important things happen
- Other parts of the system can react to these events
- Decouples the entity from event handlers

**Example Flow**:
1. Entity changes state: `tank.UpdateWaterLevel(50)`
2. Entity raises event: `tank.AddDomainEvent(new WaterLevelLowEvent(...))`
3. Entity is saved to database
4. Events are published: `eventPublisher.Publish(tank.DomainEvents)`
5. Event handlers react: Send alert, update dashboard, etc.

### [NotMapped] Attribute

**Purpose**: Tells Entity Framework Core "don't store this in the database"

**Why?**: Domain events are:
- Temporary (published and cleared after persistence)
- Not part of the entity's persistent state
- Used for communication, not storage

---

## 7. Protected Members and Encapsulation

### Protected Access Modifier

**Protected** means:
- Accessible within the class itself
- Accessible in derived classes (like `Tank : Entity<Guid>`)
- **NOT** accessible from outside the class hierarchy

### Why Protected?

**Encapsulation**: 
- `Id` setter is protected: Only the entity itself or derived classes can set it
- Prevents external code from changing IDs incorrectly
- Maintains data integrity

**Example**:
```csharp
var tank = new Tank(Guid.NewGuid());
tank.Id = Guid.NewGuid(); // ❌ Compiler error - setter is protected
```

---

## 8. Constructor Pattern

### Two Constructors - Why?

1. **Parameterized Constructor**: `Entity(TId id)`
   - Used when creating new entities
   - Ensures every entity has an ID from the start
   - Enforces business rule: "Every entity must have an identity"

2. **Parameterless Constructor**: `Entity()`
   - Required by Entity Framework Core
   - EF Core uses reflection to create instances from database rows
   - EF Core will set the ID from the database after construction

**Note**: This is a common pattern when using ORMs with DDD.

---

## 9. Read-Only Collections Pattern

### IReadOnlyList<T>

**Why not return `List<IDomainEvent>` directly?**

**Encapsulation**: 
- Prevents external code from modifying the internal list
- External code can read events but cannot add/remove directly
- Forces use of controlled methods: `AddDomainEvent()`, `ClearDomainEvents()`

**Benefits**:
- Maintains control over when events are added
- Prevents accidental modifications
- Allows validation or logging in `AddDomainEvent()`

---

## 10. Nullable Reference Types

### The `?` Symbol

`Entity<TId>?` means "this can be null"

**Why?**
- Allows comparison with null values
- Prevents null reference exceptions
- Makes nullability explicit in the code

**Example**:
```csharp
Entity<Guid>? entity = null;
if (entity != null) { ... } // Safe null check
```

---

## 11. Architecture Role

### Where Entity Fits in Clean Architecture

```
┌─────────────────────────────────────┐
│   Presentation Layer (API)          │
├─────────────────────────────────────┤
│   Application Layer (Use Cases)     │
├─────────────────────────────────────┤
│   Domain Layer ← Entity.cs is HERE  │  ← Core business logic
├─────────────────────────────────────┤
│   Infrastructure Layer (Database)   │
└─────────────────────────────────────┘
```

**Domain Layer**:
- Contains business rules and domain logic
- Independent of databases, APIs, or frameworks
- `Entity.cs` provides the foundation for all domain entities

**Dependency Rule**: 
- Domain layer has NO dependencies on other layers
- All other layers depend on Domain layer
- This ensures business logic is never contaminated by technical concerns

---

## 12. Design Patterns Used

### 1. Template Method Pattern
- Base class defines structure (identity, equality, events)
- Derived classes provide specific behavior

### 2. Identity Map Pattern
- Each entity has a unique identity
- Same ID = same entity instance

### 3. Domain Events Pattern
- Entities raise events for significant domain occurrences
- Enables event-driven architecture

### 4. Value Object vs Entity
- **Entity**: Has identity, mutable, compared by ID
- **Value Object**: No identity, immutable, compared by all properties

---

## 13. Real-World Analogy

Think of `Entity<TId>` like a **birth certificate**:

- **ID**: Like a social security number - unique and permanent
- **Properties**: Like address, name - can change over time
- **Equality**: Two people with the same SSN are the same person
- **Events**: Like life events (birth, marriage) - significant occurrences
- **Base Class**: Like a standard form - all birth certificates have the same structure

---

## 14. Common Mistakes to Avoid

### ❌ Don't: Modify ID After Creation
```csharp
// ❌ Bad - trying to change ID
var tank = new Tank(Guid.NewGuid());
tank.Id = Guid.NewGuid(); // ❌ Compiler error - setter is protected
```

### ✅ Do: Set ID in Constructor
```csharp
// ✅ Good - ID set once in constructor
var tankId = Guid.NewGuid();
var tank = new Tank(tankId);
// ID cannot be changed after creation
```

### ❌ Don't: Compare Entities by Properties
```csharp
// ❌ Bad - comparing by properties
if (tank1.Name == tank2.Name && tank1.Capacity == tank2.Capacity)
{
    // This is wrong! Entities are compared by ID
}
```

### ✅ Do: Compare Entities by ID
```csharp
// ✅ Good - comparing by ID
if (tank1 == tank2)  // Uses ID-based equality
{
    // Correct comparison
}
```

### ❌ Don't: Directly Modify DomainEvents Collection
```csharp
// ❌ Bad - trying to modify read-only collection
var events = tank.DomainEvents;
events.Add(new SomeEvent()); // ❌ Compiler error - collection is read-only
```

### ✅ Do: Use AddDomainEvent() Method
```csharp
// ✅ Good - use controlled method
tank.AddDomainEvent(new WaterLevelLowEvent(...));
```

### ❌ Don't: Forget to Clear Events After Publishing
```csharp
// ❌ Bad - events accumulate
tank.AddDomainEvent(new Event1());
// ... later ...
tank.AddDomainEvent(new Event2());
// Events keep accumulating, never cleared
```

### ✅ Do: Clear Events After Publishing
```csharp
// ✅ Good - clear after publishing
tank.AddDomainEvent(new WaterLevelLowEvent(...));
// ... save to database ...
await mediator.Publish(domainEvent);
tank.ClearDomainEvents(); // ✅ Clear after publishing
```

### ❌ Don't: Use Entity Without ID
```csharp
// ❌ Bad - entity without ID
public class Tank : Entity<Guid>
{
    public Tank() { } // ❌ Missing ID initialization
    // ID will be default(Guid) = empty GUID
}
```

### ✅ Do: Always Initialize ID
```csharp
// ✅ Good - ID always initialized
public class Tank : Entity<Guid>
{
    public Tank(Guid id) : base(id) { } // ✅ ID provided
    protected Tank() { } // For EF Core only
}
```

### ❌ Don't: Expose Mutable Collections
```csharp
// ❌ Bad - exposes mutable list
public List<IDomainEvent> DomainEvents { get; set; }
// External code can modify directly
```

### ✅ Do: Expose Read-Only Collections
```csharp
// ✅ Good - read-only collection
public IReadOnlyList<IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();
// External code can only read, not modify
```

---

## Summary

The `Entity<TId>` base class provides:

1. **Identity Management**: Every entity has a unique, non-null ID
2. **Equality Comparison**: Type-safe, ID-based equality
3. **Domain Events**: Infrastructure for event-driven architecture
4. **Consistency**: Standardized behavior across all entities
5. **Type Safety**: Generic types ensure correct ID usage
6. **Encapsulation**: Protected members maintain data integrity
7. **Framework Integration**: Works with EF Core and .NET collections

**In Simple Terms**: It's the foundation that makes all your domain entities (Tank, Sensor, etc.) work consistently and correctly, following Domain-Driven Design principles.

---

## Additional Notes

### [NotMapped] Attribute
The `[NotMapped]` attribute tells Entity Framework Core not to map a property to a database column.

### IEquatable<T> - Short Explanation

**IEquatable<T>** is an interface that lets a type compare itself to another instance of the same type in a type-safe way.

**Purpose**:
- Defines a type-safe equality method
- Avoids casting to `object`
- Improves performance by avoiding boxing

**In Your Entity Class**:
- Implements `IEquatable<Entity<TId>>`
- Provides `Equals(Entity<TId>? other)` that compares by ID
- Enables direct comparisons like `tank1.Equals(tank2)`

**Benefits**:
1. Type safety: compiler ensures you compare the right types
2. Performance: no boxing or casting
3. Cleaner code: direct comparison without casts
4. Framework support: works well with collections and LINQ

**Real-World Analogy**: Like a contract: "I can compare myself to another entity of my type." It makes comparisons straightforward and efficient.

**In simple terms**: It lets your entities compare themselves to each other in a type-safe, efficient way.

---

# Theoretical Concepts: AggregateRoot.cs Base Class

## 1. What is an Aggregate Root in Domain-Driven Design (DDD)?

An **Aggregate Root** is a special type of entity that:
- **Controls Access**: It's the entry point to an aggregate (a cluster of related entities)
- **Maintains Consistency**: Ensures all entities within the aggregate remain consistent
- **Enforces Boundaries**: Defines what can be accessed from outside the aggregate
- **Tracks Changes**: Maintains version information for optimistic concurrency control

**Key Principle**: External code can only access and modify entities through the aggregate root. You never directly modify child entities - you go through the root.

### Example in AquaCulture Platform:
- `Tank` is an aggregate root containing `Sensor` entities
- To add a sensor: `tank.AddSensor(sensor)` ✅ (through root)
- To directly modify sensor: `sensor.UpdateStatus(...)` ❌ (bypasses root - not allowed)
- The `Tank` aggregate root ensures all sensors belong to it and maintains consistency

---

## 2. Entity vs Aggregate Root

### Relationship

```
AggregateRoot<TId> : Entity<TId>
```

**AggregateRoot inherits from Entity**, meaning:
- An aggregate root IS an entity (has identity, equality, events)
- An aggregate root HAS ADDITIONAL capabilities (version, audit fields, event application)

### When to Use Each

**Use `Entity<TId>` for**:
- Child entities within an aggregate (like `Sensor` inside `Tank`)
- Entities that don't need version tracking
- Simple entities without complex lifecycle management

**Use `AggregateRoot<TId>` for**:
- Main entities that control aggregates (like `Tank`)
- Entities that need optimistic concurrency control
- Entities that participate in event sourcing
- Entities that need audit trail (CreatedAt, UpdatedAt)

---

## 3. Version Tracking (Optimistic Concurrency Control)

### What is Version?

The `Version` property is a **sequence number** that increments every time the aggregate changes.

**Purpose**:
- **Detect Conflicts**: When two users modify the same aggregate simultaneously
- **Event Sourcing**: Track which events have been applied
- **Snapshot Creation**: Know when to create aggregate snapshots

### How It Works

```csharp
// Initial state
tank.Version = 0

// First change
tank.UpdateName("New Name");
// Version becomes 1

// Second change
tank.Activate();
// Version becomes 2
```

### Real-World Scenario

**Problem**: Two users try to update the same tank simultaneously
1. User A loads tank (Version = 5)
2. User B loads tank (Version = 5)
3. User A updates tank → Version becomes 6
4. User B tries to save → **CONFLICT!** Expected version 5, but current is 6
5. System rejects User B's changes and asks them to reload

**Solution**: Version tracking prevents data loss from concurrent modifications.

---

## 4. Audit Fields (CreatedAt, UpdatedAt)

### Purpose

**Audit Trail**: Track when aggregates are created and modified for:
- **Compliance**: Regulatory requirements (who changed what, when)
- **Debugging**: Understand when issues occurred
- **Analytics**: Track system usage patterns
- **History**: Reconstruct timeline of changes

### How They Work

```csharp
// When aggregate is created
tank.CreatedAt = DateTime.UtcNow;  // Set once, never changes
tank.UpdatedAt = null;              // No updates yet

// When aggregate is modified
tank.UpdateName("New Name");
// UpdatedAt = DateTime.UtcNow (automatically set)
```

**Key Points**:
- `CreatedAt`: Set once at creation, never changes
- `UpdatedAt`: Set to `null` initially, updated on every change
- Both use UTC timezone for consistency across servers

---

## 5. The Apply() Method - Event Sourcing Pattern

### What Does Apply() Do?

The `Apply()` method is a **convenience method** that:
1. Adds the domain event to the events collection
2. Increments the version number
3. Updates the `UpdatedAt` timestamp

### Why Use Apply() Instead of AddDomainEvent()?

**Consistency**: Ensures every event application follows the same pattern:
- Event is tracked
- Version is incremented
- Timestamp is updated

**Example Without Apply()**:
```csharp
// Manual approach - easy to forget steps
AddDomainEvent(new TankNameChangedEvent(...));
IncrementVersion();  // What if we forget this?
```

**Example With Apply()**:
```csharp
// Automatic approach - can't forget steps
Apply(new TankNameChangedEvent(...));
// All steps happen automatically!
```

### Event Sourcing Context

In **Event Sourcing**, aggregates are rebuilt by replaying events:
1. Load events from event store
2. Apply each event to rebuild aggregate state
3. Version number tracks how many events have been applied

The `Apply()` method ensures version stays in sync with events.

---

## 6. IncrementVersion() Method

### Purpose

**Protected Method**: Only accessible within the class hierarchy (not from outside)

**Responsibilities**:
1. Increment version number
2. Update `UpdatedAt` timestamp

### Why Protected?

**Encapsulation**: 
- External code cannot manually increment version
- Version only changes through `Apply()` method
- Prevents version manipulation bugs

**Design Intent**: Version should only change when domain events are applied, not arbitrarily.

---

## 7. Inheritance Hierarchy

### Class Structure

```
Entity<TId> (base class)
    ↓
AggregateRoot<TId> (inherits from Entity)
    ↓
Tank : AggregateRoot<TankId> (concrete aggregate)
```

### What AggregateRoot Adds

**Beyond Entity capabilities**:
- ✅ Version tracking
- ✅ Audit fields (CreatedAt, UpdatedAt)
- ✅ Convenient `Apply()` method
- ✅ Automatic version incrementing

**Inherited from Entity**:
- ✅ Identity management
- ✅ Equality comparison
- ✅ Domain events collection
- ✅ Event management methods

---

## 8. Real-World Analogy

Think of `AggregateRoot` like a **bank account**:

- **Entity**: Like a basic account - has ID, can have transactions
- **AggregateRoot**: Like a premium account with:
  - **Version**: Transaction number (prevents double-spending)
  - **CreatedAt**: Account opening date
  - **UpdatedAt**: Last transaction date
  - **Apply()**: Standardized way to record transactions

**The Account Number (ID)**: Never changes (from Entity)
**The Transactions (Events)**: Recorded through Apply() method
**The Balance (State)**: Rebuilt by replaying transactions (event sourcing)

---

## 9. Usage Pattern in Domain Code

### Creating an Aggregate

```csharp
public static Tank Create(string name, TankCapacity capacity, Location location)
{
    var tankId = TankId.Create();
    var tank = new Tank(tankId, name, capacity, location);
    
    // Apply initial event - sets CreatedAt, Version = 1
    tank.Apply(new TankCreatedEvent(tankId, name, capacity, location));
    
    return tank;
}
```

### Modifying an Aggregate

```csharp
public void UpdateName(string newName)
{
    if (Name == newName) return;  // No change needed
    
    var oldName = Name;
    Name = newName;
    
    // Apply event - increments Version, updates UpdatedAt
    Apply(new TankNameChangedEvent(Id, oldName, newName));
}
```

### Key Points

1. **Always use Apply()** for domain events in aggregates
2. **Version increments automatically** - don't manage it manually
3. **UpdatedAt updates automatically** - don't set it manually
4. **CreatedAt is set once** - in constructor or factory method

---

## 10. Event Sourcing Integration

### How Version Helps Event Sourcing

**Event Store Pattern**:
```
Event Store:
  Event 1: TankCreated (Version 1)
  Event 2: TankNameChanged (Version 2)
  Event 3: TankActivated (Version 3)
```

**Rebuilding Aggregate**:
1. Load all events for aggregate
2. Start with empty aggregate (Version 0)
3. Apply each event sequentially
4. Final version matches number of events

**Concurrency Check**:
- When saving: Check expected version matches current version
- If mismatch: Someone else modified the aggregate
- Reject changes and ask user to reload

---

## 11. Design Patterns Used

### 1. Template Method Pattern
- Base class (`AggregateRoot`) defines structure
- Derived classes (`Tank`) provide specific behavior
- Common operations (version, audit) handled in base

### 2. Event Sourcing Pattern
- State changes represented as events
- Version tracks event sequence
- Aggregate can be rebuilt from events

### 3. Optimistic Concurrency Pattern
- Version number detects conflicts
- No locking required
- Fast performance, conflict detection

### 4. Audit Pattern
- CreatedAt/UpdatedAt track lifecycle
- Version tracks change sequence
- Enables compliance and debugging

---

## 12. Benefits of AggregateRoot

### 1. Consistency
- All aggregates behave the same way
- Standardized version tracking
- Uniform audit trail

### 2. Concurrency Safety
- Detects simultaneous modifications
- Prevents data loss
- Enables optimistic locking

### 3. Event Sourcing Support
- Version aligns with event sequence
- Easy to rebuild aggregates
- Supports snapshots

### 4. Compliance & Debugging
- Complete audit trail
- Know when changes occurred
- Track change history

### 5. Developer Experience
- `Apply()` method simplifies event handling
- Less boilerplate code
- Fewer bugs from manual version management

---

## 13. Common Mistakes to Avoid

### ❌ Don't: Manually Set Version
```csharp
tank.Version = 5;  // ❌ Wrong - breaks event sourcing
```

### ✅ Do: Use Apply() Method
```csharp
tank.Apply(new TankActivatedEvent(...));  // ✅ Correct - version increments automatically
```

### ❌ Don't: Manually Set UpdatedAt
```csharp
tank.UpdatedAt = DateTime.UtcNow;  // ❌ Wrong - should be automatic
```

### ✅ Do: Let Apply() Handle It
```csharp
tank.Apply(new TankNameChangedEvent(...));  // ✅ Correct - UpdatedAt set automatically
```

### ❌ Don't: Forget to Apply Events
```csharp
tank.Name = "New Name";
// Missing: Apply(new TankNameChangedEvent(...));  // ❌ Wrong - no event, no version increment
```

### ✅ Do: Always Apply Events
```csharp
tank.Name = "New Name";
tank.Apply(new TankNameChangedEvent(...));  // ✅ Correct - event tracked, version incremented
```

---

## Summary

The `AggregateRoot<TId>` base class provides:

1. **Version Tracking**: Optimistic concurrency control for conflict detection
2. **Audit Fields**: CreatedAt and UpdatedAt for compliance and debugging
3. **Event Application**: Convenient `Apply()` method for event sourcing
4. **Consistency**: Standardized behavior across all aggregates
5. **Event Sourcing Support**: Version aligns with event sequence
6. **Lifecycle Management**: Tracks aggregate creation and modification

**In Simple Terms**: It's the enhanced version of Entity that adds version tracking, audit trails, and event sourcing support. Use it for your main domain aggregates (like Tank) that need these advanced features.

**Key Takeaway**: Always use `Apply()` when raising domain events in aggregates - it ensures version and timestamps are updated correctly, maintaining consistency and enabling event sourcing.

---

# Theoretical Concepts: IDomainEvent.cs Interface

## 1. What is a Domain Event?

A **Domain Event** represents something significant that happened in the domain - a fact that occurred in the past.

**Key Characteristics**:
- **Immutable**: Once created, an event cannot be changed (it's a fact)
- **Past Tense**: Events describe what happened (e.g., "TankCreated", not "CreateTank")
- **Significant**: Only important occurrences become events, not every property change
- **Decoupled**: Events allow different parts of the system to react without knowing about each other

### Example in AquaCulture Platform:
- ✅ `TankCreatedEvent` - A new tank was created
- ✅ `WaterLevelLowEvent` - Tank water level dropped below threshold
- ✅ `SensorMalfunctionEvent` - A sensor stopped reporting data
- ❌ `TankNameChangedEvent` - Minor change, might not need an event

---

## 2. Why Domain Events?

### Problem: Tight Coupling

**Without Events**:
```csharp
// Tank entity directly calls notification service
tank.UpdateWaterLevel(50);
notificationService.SendAlert("Water level low");  // ❌ Tight coupling
dashboardService.UpdateDisplay(tank);              // ❌ Tight coupling
```

**Issues**:
- Tank entity knows about notification and dashboard services
- Hard to add new features (must modify Tank class)
- Difficult to test (need to mock multiple services)
- Violates Single Responsibility Principle

### Solution: Domain Events

**With Events**:
```csharp
// Tank entity raises event
tank.UpdateWaterLevel(50);
tank.AddDomainEvent(new WaterLevelLowEvent(tank.Id, 50));

// Later, after saving...
// Event handlers react independently
eventHandler1.SendAlert(event);      // ✅ Decoupled
eventHandler2.UpdateDashboard(event); // ✅ Decoupled
eventHandler3.LogToDatabase(event);   // ✅ Easy to add
```

**Benefits**:
- ✅ Tank entity doesn't know about handlers
- ✅ Easy to add new handlers (just register them)
- ✅ Easy to test (test entity separately from handlers)
- ✅ Follows Open/Closed Principle

---

## 3. The IDomainEvent Interface

### Purpose

`IDomainEvent` is a **contract** that all domain events must follow. It ensures:
- All events have consistent structure
- Events can be handled uniformly
- Events integrate with MediatR for publishing

### Interface Members

1. **EventId (Guid)**: Unique identifier for each event instance
2. **OccurredOn (DateTime)**: When the event happened
3. **EventType (string)**: Type name for serialization/routing

### Why These Properties?

**EventId**:
- Uniquely identifies each event instance
- Enables event deduplication (prevent processing same event twice)
- Allows event correlation and tracking
- Required for event sourcing

**OccurredOn**:
- Records when the event actually happened
- Important for audit trails and debugging
- Used for event ordering in event stores
- UTC timezone ensures consistency across servers

**EventType**:
- Identifies the event type for serialization
- Used to route events to correct handlers
- Enables polymorphic event handling
- Required for event store persistence

---

## 4. INotification from MediatR

### What is INotification?

`INotification` is a marker interface from MediatR that indicates:
- This is a notification (one-to-many communication)
- Multiple handlers can process this event
- No return value expected (fire-and-forget)

### Why Extend INotification?

**MediatR Integration**:
- MediatR automatically discovers and invokes all handlers
- No manual event bus code needed
- Built-in dependency injection support
- Supports async/await patterns

**Example Flow**:
```csharp
// 1. Entity raises event
tank.AddDomainEvent(new WaterLevelLowEvent(...));

// 2. After saving, publish events
await mediator.Publish(domainEvent);

// 3. MediatR finds all handlers and invokes them
// - AlertHandler.Handle(event)
// - DashboardHandler.Handle(event)
// - LoggingHandler.Handle(event)
```

---

## 5. The DomainEvent Base Record

### Why a Record Type?

**Records** in C# provide:
- **Immutability**: Properties are read-only by default
- **Value Equality**: Two events with same data are equal
- **Concise Syntax**: Less boilerplate code
- **Deconstruction**: Easy to extract values

**Perfect for Events**:
- Events are immutable facts (can't change what happened)
- Events should be compared by value (same event = same data)
- Events are data containers (records are ideal)

### Why Abstract?

**Design Intent**:
- Forces developers to create specific event types
- Prevents creating generic "DomainEvent" instances
- Ensures each event has a meaningful name
- Requires EventType to be specified

---

## 6. Automatic Property Initialization

### EventId = Guid.NewGuid()

**Purpose**: Automatically generates unique ID for each event instance

**Why Automatic?**
- Developers don't need to remember to set it
- Ensures every event has an ID
- Prevents duplicate IDs from manual assignment
- Consistent behavior across all events

**When Generated?**
- At event creation time
- Before the event is added to entity's event collection
- Unique even if same event type is raised multiple times

### OccurredOn = DateTime.UtcNow

**Purpose**: Automatically captures when event occurred

**Why UTC?**
- Consistent across different server timezones
- No daylight saving time issues
- Standard practice for distributed systems
- Easy to convert to local time when displaying

**When Set?**
- At event creation time
- Represents when the event was raised, not when published
- Important for event ordering in event stores

---

## 7. Abstract EventType Property

### Why Abstract?

**Enforcement**: Forces each event class to specify its type name

**Benefits**:
- Type safety: Compiler ensures it's implemented
- Self-documenting: Event type is explicit
- Prevents mistakes: Can't forget to set it
- Enables reflection-based routing

### Implementation Pattern

**Recommended**:
```csharp
public sealed record TankCreatedEvent(...) : DomainEvent
{
    public override string EventType => nameof(TankCreatedEvent);
}
```

**Why `nameof()`?**
- Type-safe: Refactoring tools update it automatically
- No magic strings: Compiler catches typos
- Self-documenting: Clearly shows the type name

---

## 8. Event-Driven Architecture Flow

### Complete Event Lifecycle

```
1. Domain Action
   └─> tank.UpdateWaterLevel(50)
   
2. Entity Raises Event
   └─> tank.AddDomainEvent(new WaterLevelLowEvent(...))
   
3. Entity Persisted
   └─> repository.Save(tank)
   
4. Events Extracted
   └─> var events = tank.DomainEvents
   
5. Events Published
   └─> await mediator.Publish(domainEvent)
   
6. Handlers Invoked (in parallel)
   ├─> AlertHandler.Handle(event)
   ├─> DashboardHandler.Handle(event)
   └─> LoggingHandler.Handle(event)
   
7. Events Cleared
   └─> tank.ClearDomainEvents()
```

### Key Points

- Events are raised **before** persistence
- Events are published **after** successful persistence
- Events are cleared **after** publishing
- Multiple handlers can process same event
- Handlers run independently (decoupled)

---

## 9. Event Naming Conventions

### Best Practices

**Past Tense**: Events describe what happened
- ✅ `TankCreatedEvent`
- ✅ `WaterLevelChangedEvent`
- ✅ `SensorActivatedEvent`
- ❌ `CreateTankEvent` (present tense)
- ❌ `TankCreationEvent` (noun, not past tense)

**Descriptive**: Name clearly indicates what occurred
- ✅ `WaterLevelDroppedBelowThresholdEvent`
- ❌ `WaterEvent` (too vague)

**Domain Language**: Use domain terminology
- ✅ `TankMaintenanceScheduledEvent`
- ❌ `TankMaintenanceAddedEvent` (technical term)

---

## 10. Event Properties Design

### What Should Events Contain?

**Include**:
- ✅ Entity ID (which entity raised the event)
- ✅ Relevant data (what changed)
- ✅ Context (when, where, why)
- ✅ User/Actor (who caused it, if applicable)

**Don't Include**:
- ❌ Entire entity state (too much data)
- ❌ Database-specific fields (breaks domain purity)
- ❌ Computed values (can be calculated from data)

### Example: Good Event Design

```csharp
public sealed record WaterLevelLowEvent(
    Guid TankId,
    decimal CurrentLevel,
    decimal Threshold,
    DateTime DetectedAt
) : DomainEvent
{
    public override string EventType => nameof(WaterLevelLowEvent);
}
```

**Why Good?**
- Contains only necessary data
- Clear and descriptive
- Immutable (record type)
- Self-contained (all context included)

---

## 11. Event Sourcing Integration

### How Events Enable Event Sourcing

**Event Sourcing** stores events as the source of truth:

```
Event Store:
  Event 1: TankCreated (TankId: 123, Name: "Tank A")
  Event 2: WaterLevelChanged (TankId: 123, Level: 50)
  Event 3: WaterLevelLow (TankId: 123, Level: 50, Threshold: 60)
```

**Rebuilding State**:
1. Load all events for aggregate
2. Apply each event sequentially
3. Reconstruct current state

**Benefits**:
- Complete audit trail
- Time travel (see state at any point)
- Debugging (replay events to find issues)
- Analytics (analyze event patterns)

### IDomainEvent Requirements

For event sourcing, events need:
- ✅ Unique ID (EventId) - for deduplication
- ✅ Timestamp (OccurredOn) - for ordering
- ✅ Type (EventType) - for deserialization
- ✅ Serializable data - for persistence

All provided by `IDomainEvent` interface!

---

## 12. Design Patterns Used

### 1. Observer Pattern
- Entities (observables) raise events
- Handlers (observers) react to events
- Loose coupling between components

### 2. Publish-Subscribe Pattern
- Events are published to a mediator
- Multiple subscribers (handlers) receive events
- No direct coupling between publisher and subscribers

### 3. Event Sourcing Pattern
- Events are the source of truth
- State is derived from events
- Complete history is maintained

### 4. Immutability Pattern
- Events are immutable (record type)
- Once created, cannot be changed
- Represents a fact that occurred

---

## 13. Real-World Analogy

Think of `IDomainEvent` like a **newspaper article**:

- **EventId**: Like article ID - unique identifier
- **OccurredOn**: Like publication date - when it happened
- **EventType**: Like article category - "Sports", "News", etc.
- **Data**: Like article content - what actually happened
- **Immutable**: Like a printed article - can't change it once published
- **Facts**: Like news - describes what happened, not what to do

**The Newspaper (Event Store)**:
- Stores all articles (events)
- Can replay history (read old articles)
- Complete record (nothing is lost)

---

## 14. Common Mistakes to Avoid

### ❌ Don't: Include Too Much Data
```csharp
// ❌ Bad - includes entire entity
public record TankUpdatedEvent(Tank Tank) : DomainEvent;
```

### ✅ Do: Include Only Relevant Data
```csharp
// ✅ Good - only what changed
public record TankNameChangedEvent(Guid TankId, string OldName, string NewName) : DomainEvent;
```

### ❌ Don't: Use Present Tense
```csharp
// ❌ Bad - present tense
public record CreateTankEvent(...) : DomainEvent;
```

### ✅ Do: Use Past Tense
```csharp
// ✅ Good - past tense
public record TankCreatedEvent(...) : DomainEvent;
```

### ❌ Don't: Forget EventType
```csharp
// ❌ Bad - missing EventType
public record TankEvent(...) : DomainEvent
{
    // Missing: public override string EventType => ...
}
```

### ✅ Do: Always Implement EventType
```csharp
// ✅ Good - EventType specified
public record TankCreatedEvent(...) : DomainEvent
{
    public override string EventType => nameof(TankCreatedEvent);
}
```

---

## 15. Benefits Summary

### 1. Decoupling
- Entities don't know about handlers
- Handlers don't know about entities
- Easy to add/remove handlers

### 2. Scalability
- Multiple handlers can process events in parallel
- Easy to add new features (just add handler)
- No need to modify existing code

### 3. Testability
- Test entities without handlers
- Test handlers without entities
- Mock events easily

### 4. Audit Trail
- Complete history of domain occurrences
- Know what happened and when
- Enables debugging and compliance

### 5. Event Sourcing
- Events are source of truth
- Can rebuild state from events
- Time travel and analytics

---

## Summary

The `IDomainEvent` interface and `DomainEvent` base record provide:

1. **Standardized Structure**: All events follow same pattern
2. **Automatic Properties**: EventId and OccurredOn set automatically
3. **MediatR Integration**: Works seamlessly with event publishing
4. **Immutability**: Events are immutable facts (record type)
5. **Type Safety**: Abstract EventType ensures implementation
6. **Event Sourcing Support**: All properties needed for event stores
7. **Decoupling**: Enables event-driven architecture

**In Simple Terms**: Domain events are like "news reports" of what happened in your domain. The `IDomainEvent` interface ensures all events have the same structure (ID, timestamp, type), and the `DomainEvent` base record makes it easy to create new events without boilerplate code.

**Key Takeaway**: Use domain events to decouple your domain logic from side effects (notifications, logging, etc.). Raise events when significant things happen, and let handlers react to them independently.

---

# Theoretical Concepts: ValueObject.cs Base Class

## 1. What is a Value Object in Domain-Driven Design (DDD)?

A **Value Object** is a domain object that:
- **Has No Identity**: Defined by its attributes, not by a unique ID
- **Is Immutable**: Cannot be changed after creation (must create new instance)
- **Represents a Concept**: Describes a characteristic or measurement
- **Compared by Value**: Two value objects are equal if all their properties are equal

**Key Principle**: Two value objects with the same values are considered the same object, regardless of where they exist in memory.

### Example in AquaCulture Platform:
- `TankCapacity` (100 liters, "liters") = `TankCapacity` (100 liters, "liters") ✅ (equal)
- `Location` (Lat: 40.7128, Lon: -74.0060) = `Location` (Lat: 40.7128, Lon: -74.0060) ✅ (equal)
- `Money` ($100, "USD") ≠ `Money` ($100, "EUR") ❌ (different currency)

---

## 2. Entity vs Value Object

### Key Differences

| Aspect | Entity | Value Object |
|--------|--------|--------------|
| **Identity** | Has unique ID | No identity |
| **Equality** | Compared by ID | Compared by all properties |
| **Mutability** | Can change state | Immutable |
| **Lifecycle** | Can be tracked | Created and replaced |
| **Example** | `Tank` (ID: 123) | `TankCapacity` (100L) |

### When to Use Each

**Use Entity when**:
- The object has a lifecycle and identity
- You need to track it over time
- Identity matters more than attributes
- Example: `Tank`, `Sensor`, `User`

**Use Value Object when**:
- The object describes a characteristic
- All attributes together define the concept
- Immutability is important
- Example: `Money`, `Address`, `TankCapacity`, `Location`

### Real-World Analogy

**Entity**: Like a person (has SSN/ID, can change address/name, but same person)
**Value Object**: Like a $100 bill (no identity, two $100 bills are interchangeable)

---

## 3. Immutability - Why It Matters

### What is Immutability?

**Immutable** means "cannot be changed after creation". Once created, a value object's properties cannot be modified.

### Why Immutable?

**1. Thread Safety**:
- Multiple threads can safely share value objects
- No need for locking mechanisms
- Prevents race conditions

**2. Predictable Behavior**:
- Value object state never changes unexpectedly
- Easier to reason about code
- Fewer bugs from unexpected mutations

**3. Value Semantics**:
- Two value objects with same values are interchangeable
- Can safely replace one with another
- Matches mathematical concept of "value"

**4. Domain Integrity**:
- Prevents invalid state changes
- Business rules enforced at creation
- No need to validate on every change

### How to Achieve Immutability

```csharp
// ✅ Good - Immutable
public sealed class Money : ValueObject
{
    public decimal Amount { get; }  // Read-only property
    public string Currency { get; } // Read-only property
    
    public Money(decimal amount, string currency)
    {
        Amount = amount;
        Currency = currency;
    }
}

// ❌ Bad - Mutable
public class Money : ValueObject
{
    public decimal Amount { get; set; }  // ❌ Can be changed
    public string Currency { get; set; } // ❌ Can be changed
}
```

---

## 4. Value-Based Equality

### How Value Objects Compare

**Entities**: Compared by ID
```csharp
var tank1 = new Tank(id: 123, name: "Tank A");
var tank2 = new Tank(id: 123, name: "Tank B");
tank1 == tank2  // ✅ True (same ID, even though name differs)
```

**Value Objects**: Compared by all properties
```csharp
var capacity1 = new TankCapacity(100, "liters");
var capacity2 = new TankCapacity(100, "liters");
capacity1 == capacity2  // ✅ True (all properties equal)

var capacity3 = new TankCapacity(100, "gallons");
capacity1 == capacity3  // ❌ False (different unit)
```

### GetEqualityComponents() Method

**Purpose**: Derived classes specify which properties define equality

**Implementation Pattern**:
```csharp
protected override IEnumerable<object> GetEqualityComponents()
{
    yield return Amount;    // Include in equality check
    yield return Currency;   // Include in equality check
    // Don't include: Computed properties, derived values
}
```

**Key Points**:
- Return ALL properties that should affect equality
- Order matters (should be consistent)
- Don't include computed/derived properties
- Don't include properties that don't affect identity

---

## 5. Hash Code Implementation

### Why Hash Code Matters

**Hash-based collections** (Dictionary, HashSet) use hash codes for fast lookups:
- Same hash code → likely same object
- Different hash code → definitely different object

### How It Works

```csharp
public override int GetHashCode()
{
    return GetEqualityComponents()
        .Select(x => x?.GetHashCode() ?? 0)
        .Aggregate((x, y) => x ^ y);  // XOR combination
}
```

**XOR (^) Operation**:
- Combines hash codes of all components
- Order-independent (A ^ B = B ^ A)
- Fast computation
- Good distribution

**Important Rule**: 
- If `Equals()` returns true, `GetHashCode()` must return same value
- If `GetHashCode()` differs, `Equals()` must return false
- Violating this breaks hash-based collections!

---

## 6. The Template Method Pattern

### How ValueObject Uses It

**Base Class (ValueObject)**:
- Defines the structure (Equals, GetHashCode, operators)
- Provides the algorithm (how to compare)
- Calls abstract method (GetEqualityComponents)

**Derived Class (e.g., Money)**:
- Implements abstract method (GetEqualityComponents)
- Specifies what to compare (Amount, Currency)
- Gets comparison logic for free

**Benefits**:
- Consistent equality logic across all value objects
- Derived classes only specify "what" to compare
- Base class handles "how" to compare

---

## 7. Real-World Examples

### Example 1: Money Value Object

```csharp
public sealed class Money : ValueObject
{
    public decimal Amount { get; }
    public string Currency { get; }
    
    public Money(decimal amount, string currency)
    {
        if (amount < 0) throw new ArgumentException("Amount cannot be negative");
        if (string.IsNullOrWhiteSpace(currency)) 
            throw new ArgumentException("Currency is required");
            
        Amount = amount;
        Currency = currency.ToUpper();
    }
    
    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Amount;
        yield return Currency;
    }
    
    // Usage
    var price1 = new Money(100, "USD");
    var price2 = new Money(100, "USD");
    price1 == price2  // ✅ True
    
    var price3 = new Money(100, "EUR");
    price1 == price3  // ❌ False (different currency)
}
```

### Example 2: Location Value Object

```csharp
public sealed class Location : ValueObject
{
    public decimal Latitude { get; }
    public decimal Longitude { get; }
    
    public Location(decimal latitude, decimal longitude)
    {
        if (latitude < -90 || latitude > 90)
            throw new ArgumentException("Invalid latitude");
        if (longitude < -180 || longitude > 180)
            throw new ArgumentException("Invalid longitude");
            
        Latitude = latitude;
        Longitude = longitude;
    }
    
    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Latitude;
        yield return Longitude;
    }
}

// Usage
var location1 = new Location(40.7128m, -74.0060m);  // New York
var location2 = new Location(40.7128m, -74.0060m);  // Same coordinates
location1 == location2  // ✅ True (same location)
```

---

## 8. When to Create Value Objects

### Good Candidates

**✅ Use Value Objects for**:
- Measurements: `TankCapacity`, `Temperature`, `Weight`
- Money: `Money`, `Price`, `Cost`
- Addresses: `Address`, `Location`, `Coordinates`
- Ranges: `DateRange`, `TemperatureRange`
- Complex types: `Email`, `PhoneNumber`, `Url`
- Settings: `WaterQualityParameters`, `TankSettings`

**Characteristics**:
- Describes a concept, not a thing
- Has validation rules
- Should be immutable
- Multiple properties define it
- Used in multiple places

### Avoid Value Objects For

**❌ Don't use for**:
- Things with identity (use Entity)
- Things that change frequently (use Entity)
- Simple primitives (use built-in types)
- Things that need tracking (use Entity)

---

## 9. Benefits of Value Objects

### 1. Encapsulation

**Validation at Creation**:
```csharp
public Money(decimal amount, string currency)
{
    if (amount < 0) throw new ArgumentException("Amount cannot be negative");
    // Validation happens once, at creation
    Amount = amount;
    Currency = currency;
}
```

**Business Rules Enforced**:
- Invalid values cannot be created
- No need to validate everywhere
- Domain rules in one place

### 2. Self-Documenting Code

**Clear Intent**:
```csharp
// ❌ Unclear
decimal price = 100;
string currency = "USD";

// ✅ Clear
Money price = new Money(100, "USD");
```

**Type Safety**:
- Compiler prevents mixing incompatible types
- Can't accidentally pass wrong type
- IntelliSense shows available operations

### 3. Reusability

**Use Anywhere**:
- Entities can contain value objects
- Other value objects can contain value objects
- Services can use value objects
- DTOs can use value objects

### 4. Testability

**Easy to Test**:
- No dependencies to mock
- Simple to create test instances
- Predictable behavior
- Immutable = no side effects

---

## 10. Common Patterns

### Pattern 1: Validation in Constructor

```csharp
public TankCapacity(decimal value, string unit)
{
    if (value <= 0) throw new ArgumentException("Capacity must be positive");
    if (!IsValidUnit(unit)) throw new ArgumentException("Invalid unit");
    
    Value = value;
    Unit = unit;
}
```

### Pattern 2: Factory Methods

```csharp
public static TankCapacity FromLiters(decimal liters)
{
    return new TankCapacity(liters, "liters");
}

public static TankCapacity FromGallons(decimal gallons)
{
    return new TankCapacity(gallons * 3.78541m, "liters");
}
```

### Pattern 3: Conversion Methods

```csharp
public TankCapacity ToLiters()
{
    if (Unit == "liters") return this;
    return new TankCapacity(Value * 3.78541m, "liters");
}
```

---

## 11. Design Patterns Used

### 1. Template Method Pattern
- Base class defines comparison algorithm
- Derived classes specify equality components
- Consistent behavior across all value objects

### 2. Immutability Pattern
- Objects cannot be changed after creation
- Thread-safe by default
- Predictable behavior

### 3. Value Object Pattern (DDD)
- No identity, compared by value
- Immutable, self-validating
- Encapsulates domain concepts

### 4. Factory Pattern
- Static factory methods for creation
- Validates and creates valid instances
- Provides convenient constructors

---

## 12. Common Mistakes to Avoid

### ❌ Don't: Make Value Objects Mutable

```csharp
// ❌ Bad - Can be changed
public class Money : ValueObject
{
    public decimal Amount { get; set; }  // ❌ Mutable
}
```

### ✅ Do: Keep Them Immutable

```csharp
// ✅ Good - Read-only
public sealed class Money : ValueObject
{
    public decimal Amount { get; }  // ✅ Immutable
}
```

### ❌ Don't: Include Non-Essential Properties

```csharp
// ❌ Bad - Includes computed property
protected override IEnumerable<object> GetEqualityComponents()
{
    yield return Amount;
    yield return Currency;
    yield return ToString();  // ❌ Don't include computed values
}
```

### ✅ Do: Include Only Essential Properties

```csharp
// ✅ Good - Only essential properties
protected override IEnumerable<object> GetEqualityComponents()
{
    yield return Amount;
    yield return Currency;
}
```

### ❌ Don't: Forget to Implement GetEqualityComponents

```csharp
// ❌ Bad - Missing implementation
public sealed class Money : ValueObject
{
    // Missing: GetEqualityComponents()
}
```

### ✅ Do: Always Implement GetEqualityComponents

```csharp
// ✅ Good - Properly implemented
public sealed class Money : ValueObject
{
    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Amount;
        yield return Currency;
    }
}
```

---

## 13. Real-World Analogy

Think of **Value Objects** like **currency**:

- **No Identity**: A $100 bill is the same as another $100 bill
- **Defined by Attributes**: Value ($100) and currency (USD) define it
- **Immutable**: Can't change a $100 bill to $50 (must exchange it)
- **Interchangeable**: Any $100 bill works the same
- **Self-Contained**: All information needed is in the bill itself

**Entities** are like **people**:
- **Has Identity**: SSN/ID uniquely identifies a person
- **Can Change**: Address, name, job can change
- **Tracked**: We track people over time
- **Not Interchangeable**: Two people are never the same, even with same name

---

## 14. Integration with Entities

### Value Objects in Entities

```csharp
public class Tank : AggregateRoot<Guid>
{
    public TankCapacity Capacity { get; private set; }  // Value object
    public Location Location { get; private set; }      // Value object
    public WaterQualityParameters Parameters { get; private set; }  // Value object
    
    public void UpdateCapacity(TankCapacity newCapacity)
    {
        Capacity = newCapacity;  // Replace entire value object
    }
}
```

### Key Points

- Entities **contain** value objects
- Value objects **describe** entity characteristics
- Replacing value object = creating new instance
- Value objects validate themselves

---

## 15. Benefits Summary

### 1. Type Safety
- Compiler prevents type mismatches
- Clear domain concepts
- IntelliSense support

### 2. Validation
- Invalid values cannot be created
- Business rules enforced at creation
- No need to validate everywhere

### 3. Immutability
- Thread-safe by default
- Predictable behavior
- No unexpected changes

### 4. Reusability
- Use in multiple entities
- Consistent behavior
- Domain concepts encapsulated

### 5. Testability
- Easy to create test instances
- No dependencies to mock
- Predictable behavior

---

## Summary

The `ValueObject` base class provides:

1. **Value-Based Equality**: Compared by all properties, not identity
2. **Immutability Support**: Structure encourages immutable design
3. **Consistent Comparison**: Same equality logic for all value objects
4. **Hash Code Support**: Proper implementation for hash-based collections
5. **Template Method**: Derived classes specify what to compare
6. **Type Safety**: Compiler enforces correct usage
7. **Domain Concepts**: Encapsulates descriptive domain aspects

**In Simple Terms**: Value objects are like "descriptive labels" for your domain. They have no identity, are immutable, and are compared by their values. Use them for concepts like Money, Address, Temperature, etc. that describe characteristics rather than represent things with identity.

**Key Takeaway**: When you need to represent a concept that is defined by its attributes (like "100 liters" or "$50 USD"), use a value object. It will be immutable, self-validating, and provide type safety throughout your domain.
