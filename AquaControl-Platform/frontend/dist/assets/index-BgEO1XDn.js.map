{"version":3,"mappings":"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","names":["isObject","v","normalizeOptions","options","factoryOptions","target","key","receiver","get","state","path","obj","p","set","val","pick","baseState","paths","substate","pathArray","parsePersistence","store","o","_a","storage","beforeRestore","afterRestore","serializer","debug","k","e","hydrateStore","fromStorage","persistState","toStore","createPersistedState","context","auto","persist","pinia","original_store","persistences","persistence","runHooks","_mutation","src_default","useNotificationStore","defineStore","notifications","ref","addNotification","notification","newNotification","duration","removeNotification","id","index","n","HttpClient$1","axios","config","authStore","useAuthStore","timestamp","randomPart","configWithMetadata","error","response","notificationStore","_error","url","data","file","onProgress","formData","progressEvent","progress","filename","blob","downloadUrl","link","httpClient","HttpClient","authService","credentials","refreshToken","token","refreshTokenValue","user","isLoading","isAuthenticated","computed","isTokenExpired","payload","currentTime","login","err","logout","validateAndRefreshToken","initialize","updateUserProfile","userProfile","setupTokenRefresh","expiryTime","timeUntilExpiry","refreshTime","HttpError","errorMessage","statusCode","trueProto","TimeoutError","AbortError","UnsupportedTransportError","message","transport","DisabledTransportError","FailedToStartTransportError","FailedToNegotiateWithServerError","AggregateErrors","innerErrors","HttpResponse","statusText","content","LogLevel","NullLogger","_logLevel","_message","VERSION","Arg","name","values","Platform","getDataDetail","includeContent","detail","isArrayBuffer","formatArrayBuffer","view","str","num","pad","sendMessage","logger","transportName","headers","value","getUserAgentHeader","responseType","createLogger","ConsoleLogger","SubjectSubscription","subject","observer","_","minimumLogLevel","logLevel","msg","userAgentHeaderName","constructUserAgent","getOsName","getRuntime","getRuntimeVersion","version","os","runtime","runtimeVersion","userAgent","majorAndMinor","getErrorString","getGlobalThis","FetchHttpClient","requireFunc","request","abortController","timeoutId","msTimeout","deserializeContent","cookies","c","XhrHttpClient","resolve","reject","xhr","header","DefaultHttpClient","TextMessageFormat","output","input","messages","HandshakeProtocol","handshakeRequest","messageData","remainingData","binaryData","separatorIndex","responseLength","textData","MessageType","Subject","item","MessageBuffer","protocol","connection","bufferSize","serializedMessage","backpressurePromise","backpressurePromiseResolver","backpressurePromiseRejector","BufferedItem","ackMessage","newestAckedMessage","element","currentId","sequenceId","resolver","rejector","DEFAULT_TIMEOUT_IN_MS","DEFAULT_PING_INTERVAL_IN_MS","DEFAULT_STATEFUL_RECONNECT_BUFFER_SIZE","HubConnectionState","HubConnection","reconnectPolicy","serverTimeoutInMilliseconds","keepAliveIntervalInMilliseconds","statefulReconnectBufferSize","handshakePromise","startPromise","methodName","args","streams","streamIds","invocationDescriptor","promiseQueue","cancelInvocation","invocationEvent","sendPromise","newMethod","method","handlers","removeIdx","callback","responseMessage","nextPing","invocationMessage","methods","methodsCopy","expectsResponse","res","exception","completionMessage","m","prevRes","reconnectStartTime","previousReconnectAttempts","retryError","nextRetryDelay","previousRetryCount","elapsedMilliseconds","retryReason","callbacks","nonblocking","invocationId","streamId","i","argument","arg","result","DEFAULT_RETRY_DELAYS_IN_MILLISECONDS","DefaultReconnectPolicy","retryDelays","retryContext","HeaderNames","AccessTokenHttpClient","innerClient","accessTokenFactory","allowRetry","HttpTransportType","TransferFormat","AbortController$1","LongPollingTransport","AbortController","transferFormat","pollOptions","pollUrl","deleteOptions","logMessage","ServerSentEventsTransport","accessToken","opened","eventSource","WebSocketTransport","logMessageContent","webSocketConstructor","webSocket","_event","event","MAX_REDIRECTS","HttpConnection","webSocketModule","eventSourceModule","TransportSendQueue","negotiateResponse","redirects","negotiateUrl","connectionToken","requestedTransport","requestedTransferFormat","connectUrl","transportExceptions","transports","negotiate","endpoint","transportOrError","ex","callStop","useStatefulReconnect","transportMatches","s","aTag","searchParams","actualTransport","_transport","PromiseSource","transportResult","arrayBuffers","totalLength","b","a","offset","reason","JSON_HUB_PROTOCOL_NAME","JsonHubProtocol","hubMessages","parsedMessage","LogLevelNameMapping","parseLogLevel","mapping","HubConnectionBuilder","logging","isLogger","transportTypeOrOptions","retryDelaysOrReconnectPolicy","milliseconds","httpConnectionOptions","useRealTimeStore","isConnected","connectionState","eventHandlers","isConnecting","hubUrl","signalR.HubConnectionBuilder","eventType","handler","groupName","route","useRoute","router","useRouter","realTimeStore","isCollapsed","activeRoute","toggleSidebar","handleCommand","command","_openBlock","_createElementBlock","_hoisted_1","_createVNode","_component_el_container","_component_el_aside","_createElementVNode","_hoisted_2","_createBlock","_component_el_icon","_unref","Water","_hoisted_3","_component_el_menu","_component_el_menu_item","_cache","Odometer","Box","Cpu","DataAnalysis","Setting","_component_el_header","_hoisted_4","_component_el_button","Expand","Fold","_hoisted_5","_component_el_dropdown","_component_el_dropdown_menu","_component_el_dropdown_item","User","SwitchButton","_hoisted_6","_component_el_avatar","UserFilled","_hoisted_7","_toDisplayString","_component_el_main","_component_router_view","loginFormRef","loginForm","loginRules","handleLogin","valid","ElMessage","_component_el_card","_component_el_form","_component_el_form_item","_component_el_input","$event","Lock","_TransitionGroup","_Fragment","_renderList","_component_el_notification","statusClass","statusIcon","Connection","Refresh","Close","tooltipText","handleReconnect","_component_el_tooltip","_normalizeClass","_resolveDynamicComponent","isInitializing","provide","onMounted","_component_el_loading_service","AppLayout","LoginView","NotificationContainer","ConnectionStatus","DashboardView","__vitePreload","TanksView","TankDetailView","SensorsView","AnalyticsView","SettingsView","NotFoundView","routes","createRouter","createWebHistory","_to","_from","savedPosition","next","app","createApp","App","createPinia","piniaPluginPersistedstate","ElementPlus","component","ElementPlusIconsVue","_instance","info"],"ignoreList":[0,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29],"sources":["../../node_modules/pinia-plugin-persistedstate/dist/index.js","../../src/stores/notificationStore.ts","../../src/services/api/httpClient.ts","../../src/services/api/authService.ts","../../src/stores/authStore.ts","../../node_modules/@microsoft/signalr/dist/esm/Errors.js","../../node_modules/@microsoft/signalr/dist/esm/HttpClient.js","../../node_modules/@microsoft/signalr/dist/esm/ILogger.js","../../node_modules/@microsoft/signalr/dist/esm/Loggers.js","../../node_modules/@microsoft/signalr/dist/esm/Utils.js","../../node_modules/@microsoft/signalr/dist/esm/FetchHttpClient.js","../../node_modules/@microsoft/signalr/dist/esm/XhrHttpClient.js","../../node_modules/@microsoft/signalr/dist/esm/DefaultHttpClient.js","../../node_modules/@microsoft/signalr/dist/esm/TextMessageFormat.js","../../node_modules/@microsoft/signalr/dist/esm/HandshakeProtocol.js","../../node_modules/@microsoft/signalr/dist/esm/IHubProtocol.js","../../node_modules/@microsoft/signalr/dist/esm/Subject.js","../../node_modules/@microsoft/signalr/dist/esm/MessageBuffer.js","../../node_modules/@microsoft/signalr/dist/esm/HubConnection.js","../../node_modules/@microsoft/signalr/dist/esm/DefaultReconnectPolicy.js","../../node_modules/@microsoft/signalr/dist/esm/HeaderNames.js","../../node_modules/@microsoft/signalr/dist/esm/AccessTokenHttpClient.js","../../node_modules/@microsoft/signalr/dist/esm/ITransport.js","../../node_modules/@microsoft/signalr/dist/esm/AbortController.js","../../node_modules/@microsoft/signalr/dist/esm/LongPollingTransport.js","../../node_modules/@microsoft/signalr/dist/esm/ServerSentEventsTransport.js","../../node_modules/@microsoft/signalr/dist/esm/WebSocketTransport.js","../../node_modules/@microsoft/signalr/dist/esm/HttpConnection.js","../../node_modules/@microsoft/signalr/dist/esm/JsonHubProtocol.js","../../node_modules/@microsoft/signalr/dist/esm/HubConnectionBuilder.js","../../src/stores/realTimeStore.ts","../../src/components/layout/AppLayout.vue","../../src/views/auth/LoginView.vue","../../src/components/common/NotificationContainer.vue","../../src/components/common/ConnectionStatus.vue","../../src/App.vue","../../src/router/index.ts","../../src/main.ts"],"sourcesContent":["// src/normalize.ts\nfunction isObject(v) {\n  return typeof v === \"object\" && v !== null;\n}\nfunction normalizeOptions(options, factoryOptions) {\n  options = isObject(options) ? options : /* @__PURE__ */ Object.create(null);\n  return new Proxy(options, {\n    get(target, key, receiver) {\n      if (key === \"key\")\n        return Reflect.get(target, key, receiver);\n      return Reflect.get(target, key, receiver) || Reflect.get(factoryOptions, key, receiver);\n    }\n  });\n}\n\n// src/pick.ts\nfunction get(state, path) {\n  return path.reduce((obj, p) => {\n    return obj == null ? void 0 : obj[p];\n  }, state);\n}\nfunction set(state, path, val) {\n  return path.slice(0, -1).reduce((obj, p) => {\n    if (/^(__proto__)$/.test(p))\n      return {};\n    else return obj[p] = obj[p] || {};\n  }, state)[path[path.length - 1]] = val, state;\n}\nfunction pick(baseState, paths) {\n  return paths.reduce((substate, path) => {\n    const pathArray = path.split(\".\");\n    return set(substate, pathArray, get(baseState, pathArray));\n  }, {});\n}\n\n// src/plugin.ts\nfunction parsePersistence(factoryOptions, store) {\n  return (o) => {\n    var _a;\n    try {\n      const {\n        storage = localStorage,\n        beforeRestore = void 0,\n        afterRestore = void 0,\n        serializer = {\n          serialize: JSON.stringify,\n          deserialize: JSON.parse\n        },\n        key = store.$id,\n        paths = null,\n        debug = false\n      } = o;\n      return {\n        storage,\n        beforeRestore,\n        afterRestore,\n        serializer,\n        key: ((_a = factoryOptions.key) != null ? _a : (k) => k)(typeof key == \"string\" ? key : key(store.$id)),\n        paths,\n        debug\n      };\n    } catch (e) {\n      if (o.debug)\n        console.error(\"[pinia-plugin-persistedstate]\", e);\n      return null;\n    }\n  };\n}\nfunction hydrateStore(store, { storage, serializer, key, debug }) {\n  try {\n    const fromStorage = storage == null ? void 0 : storage.getItem(key);\n    if (fromStorage)\n      store.$patch(serializer == null ? void 0 : serializer.deserialize(fromStorage));\n  } catch (e) {\n    if (debug)\n      console.error(\"[pinia-plugin-persistedstate]\", e);\n  }\n}\nfunction persistState(state, { storage, serializer, key, paths, debug }) {\n  try {\n    const toStore = Array.isArray(paths) ? pick(state, paths) : state;\n    storage.setItem(key, serializer.serialize(toStore));\n  } catch (e) {\n    if (debug)\n      console.error(\"[pinia-plugin-persistedstate]\", e);\n  }\n}\nfunction createPersistedState(factoryOptions = {}) {\n  return (context) => {\n    const { auto = false } = factoryOptions;\n    const {\n      options: { persist = auto },\n      store,\n      pinia\n    } = context;\n    if (!persist)\n      return;\n    if (!(store.$id in pinia.state.value)) {\n      const original_store = pinia._s.get(store.$id.replace(\"__hot:\", \"\"));\n      if (original_store)\n        Promise.resolve().then(() => original_store.$persist());\n      return;\n    }\n    const persistences = (Array.isArray(persist) ? persist.map((p) => normalizeOptions(p, factoryOptions)) : [normalizeOptions(persist, factoryOptions)]).map(parsePersistence(factoryOptions, store)).filter(Boolean);\n    store.$persist = () => {\n      persistences.forEach((persistence) => {\n        persistState(store.$state, persistence);\n      });\n    };\n    store.$hydrate = ({ runHooks = true } = {}) => {\n      persistences.forEach((persistence) => {\n        const { beforeRestore, afterRestore } = persistence;\n        if (runHooks)\n          beforeRestore == null ? void 0 : beforeRestore(context);\n        hydrateStore(store, persistence);\n        if (runHooks)\n          afterRestore == null ? void 0 : afterRestore(context);\n      });\n    };\n    persistences.forEach((persistence) => {\n      const { beforeRestore, afterRestore } = persistence;\n      beforeRestore == null ? void 0 : beforeRestore(context);\n      hydrateStore(store, persistence);\n      afterRestore == null ? void 0 : afterRestore(context);\n      store.$subscribe(\n        (_mutation, state) => {\n          persistState(state, persistence);\n        },\n        {\n          detached: true\n        }\n      );\n    });\n  };\n}\n\n// src/index.ts\nvar src_default = createPersistedState();\nexport {\n  createPersistedState,\n  src_default as default\n};\n","import { defineStore } from 'pinia'\nimport { ref } from 'vue'\n\nexport interface Notification {\n  id: string\n  type: 'success' | 'error' | 'warning' | 'info'\n  title: string\n  message: string\n  duration?: number\n  timestamp: string\n}\n\nexport const useNotificationStore = defineStore('notifications', () => {\n  const notifications = ref<Notification[]>([])\n\n  const addNotification = (notification: Omit<Notification, 'id' | 'timestamp'>) => {\n    const newNotification: Notification = {\n      id: crypto.randomUUID(),\n      timestamp: new Date().toISOString(),\n      ...notification\n    }\n    notifications.value.push(newNotification)\n\n    // Auto-remove after duration (default 5 seconds)\n    const duration = notification.duration || 5000\n    setTimeout(() => {\n      removeNotification(newNotification.id)\n    }, duration)\n  }\n\n  const removeNotification = (id: string) => {\n    const index = notifications.value.findIndex(n => n.id === id)\n    if (index !== -1) {\n      notifications.value.splice(index, 1)\n    }\n  }\n\n  const clearAll = () => {\n    notifications.value = []\n  }\n\n  return {\n    notifications,\n    addNotification,\n    removeNotification,\n    clearAll\n  }\n})\n\n","import axios, { \n  AxiosInstance, \n  AxiosRequestConfig, \n  AxiosResponse, \n  InternalAxiosRequestConfig \n} from 'axios'\nimport { useAuthStore } from '@stores/authStore'\nimport { useNotificationStore } from '@stores/notificationStore'\nimport type { ApiResponse, ApiError } from '@/types/api'\n\nclass HttpClient {\n  private client: AxiosInstance\n  private readonly baseURL: string\n  private readonly timeout: number = 30000\n\n  constructor() {\n    this.baseURL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:5000'\n    \n    this.client = axios.create({\n      baseURL: this.baseURL,\n      timeout: this.timeout,\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n      }\n    })\n\n    this.setupInterceptors()\n  }\n\n  private setupInterceptors(): void {\n    // Request interceptor\n    this.client.interceptors.request.use(\n      (config: InternalAxiosRequestConfig) => {\n        // Add authentication token\n        const authStore = useAuthStore()\n        if (authStore.token) {\n          config.headers.Authorization = `Bearer ${authStore.token}`\n        }\n\n        // Add correlation ID for tracing\n        const timestamp = Date.now()\n        const random = Math.random()\n        const randomStr = random.toString(36)\n        const randomPart = randomStr.slice(2, 9)\n        config.headers['X-Correlation-ID'] = 'req-' + timestamp + '-' + randomPart\n\n        // Add request timestamp\n        const configWithMetadata = config as any\n        configWithMetadata.metadata = { startTime: Date.now() }\n\n        console.log(` API Request: ${config.method?.toUpperCase()} ${config.url}`, {\n          headers: config.headers,\n          data: config.data\n        })\n\n        return config\n      },\n      (error) => {\n        console.error(' Request Error:', error)\n        return Promise.reject(error)\n      }\n    )\n\n    // Response interceptor\n    this.client.interceptors.response.use(\n      (response: AxiosResponse) => {\n        const duration = Date.now() - ((response.config as any).metadata?.startTime || 0)\n        \n        console.log(` API Response: ${response.status} ${response.config.url} (${duration}ms)`, {\n          data: response.data,\n          headers: response.headers\n        })\n\n        return response\n      },\n      async (error) => {\n        const duration = Date.now() - (error.config?.metadata?.startTime || 0)\n        \n        console.error(` API Error: ${error.response?.status || 'Network'} ${error.config?.url} (${duration}ms)`, {\n          error: error.response?.data,\n          status: error.response?.status\n        })\n\n        // Handle specific error cases\n        if (error.response?.status === 401) {\n          await this.handleUnauthorized()\n        } else if (error.response?.status === 403) {\n          this.handleForbidden()\n        } else if (error.response?.status >= 500) {\n          this.handleServerError(error)\n        }\n\n        return Promise.reject(this.transformError(error))\n      }\n    )\n  }\n\n  private async handleUnauthorized(): Promise<void> {\n    const authStore = useAuthStore()\n    const notificationStore = useNotificationStore()\n    \n    // Try to refresh token\n    try {\n      await authStore.refreshTokenAction()\n    } catch {\n      // Refresh failed, logout user\n      await authStore.logout()\n      notificationStore.addNotification({\n        type: 'warning',\n        title: 'Session Expired',\n        message: 'Please log in again to continue'\n      })\n    }\n  }\n\n  private handleForbidden(): void {\n    const notificationStore = useNotificationStore()\n    notificationStore.addNotification({\n      type: 'error',\n      title: 'Access Denied',\n      message: 'You do not have permission to perform this action'\n    })\n  }\n\n  private handleServerError(_error: any): void {\n    const notificationStore = useNotificationStore()\n    notificationStore.addNotification({\n      type: 'error',\n      title: 'Server Error',\n      message: 'An unexpected error occurred. Please try again later.'\n    })\n  }\n\n  private transformError(error: any): ApiError {\n    return {\n      code: error.response?.data?.code || 'UNKNOWN_ERROR',\n      message: error.response?.data?.message || error.message || 'An unexpected error occurred',\n      details: error.response?.data?.details || {},\n      timestamp: new Date().toISOString(),\n      path: error.config?.url || ''\n    }\n  }\n\n  // Generic HTTP methods\n  async get<T>(url: string, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {\n    const response = await this.client.get<ApiResponse<T>>(url, config)\n    return response.data\n  }\n\n  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {\n    const response = await this.client.post<ApiResponse<T>>(url, data, config)\n    return response.data\n  }\n\n  async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {\n    const response = await this.client.put<ApiResponse<T>>(url, data, config)\n    return response.data\n  }\n\n  async patch<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {\n    const response = await this.client.patch<ApiResponse<T>>(url, data, config)\n    return response.data\n  }\n\n  async delete<T>(url: string, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {\n    const response = await this.client.delete<ApiResponse<T>>(url, config)\n    return response.data\n  }\n\n  // Specialized methods\n  async uploadFile(url: string, file: File, onProgress?: (progress: number) => void): Promise<ApiResponse<any>> {\n    const formData = new FormData()\n    formData.append('file', file)\n\n    return this.post(url, formData, {\n      headers: {\n        'Content-Type': 'multipart/form-data'\n      },\n      onUploadProgress: (progressEvent) => {\n        if (onProgress && progressEvent.total) {\n          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total)\n          onProgress(progress)\n        }\n      }\n    })\n  }\n\n  async downloadFile(url: string, filename?: string): Promise<void> {\n    const response = await this.client.get(url, {\n      responseType: 'blob'\n    })\n\n    const blob = new Blob([response.data])\n    const downloadUrl = window.URL.createObjectURL(blob)\n    const link = document.createElement('a')\n    link.href = downloadUrl\n    link.download = filename || 'download'\n    document.body.appendChild(link)\n    link.click()\n    document.body.removeChild(link)\n    window.URL.revokeObjectURL(downloadUrl)\n  }\n}\n\n// Export singleton instance\nexport const httpClient = new HttpClient()\nexport default httpClient\n\n","import { httpClient } from './httpClient'\nimport type { LoginCredentials, LoginResponse, TokenResponse, RefreshTokenRequest } from '@/types/auth'\n\nexport const authService = {\n  async login(credentials: LoginCredentials): Promise<LoginResponse> {\n    try {\n      const response = await httpClient.post<LoginResponse>('/auth/login', credentials)\n      return response.data\n    } catch (error) {\n      console.error('Login failed:', error)\n      throw error\n    }\n  },\n\n  async refreshToken(refreshToken: string): Promise<TokenResponse> {\n    try {\n      const response = await httpClient.post<TokenResponse>('/auth/refresh', { \n        refreshToken \n      } as RefreshTokenRequest)\n      return response.data\n    } catch (error) {\n      console.error('Token refresh failed:', error)\n      throw error\n    }\n  },\n\n  async logout(): Promise<void> {\n    try {\n      await httpClient.post('/auth/logout')\n    } catch (error) {\n      console.error('Logout failed:', error)\n      // Don't throw error for logout - clear local state anyway\n    }\n  },\n\n  async validateToken(token: string): Promise<boolean> {\n    try {\n      await httpClient.get('/auth/validate', {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      })\n      return true\n    } catch (error) {\n      console.error('Token validation failed:', error)\n      return false\n    }\n  },\n\n  async getUserProfile(token: string): Promise<any> {\n    try {\n      const response = await httpClient.get('/auth/profile', {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      })\n      return response.data\n    } catch (error) {\n      console.error('Get user profile failed:', error)\n      throw error\n    }\n  }\n}\n","import { defineStore } from 'pinia'\nimport { ref, computed } from 'vue'\nimport { authService } from '@/services/api/authService'\nimport { useNotificationStore } from './notificationStore'\nimport type { LoginCredentials, User } from '@/types/auth'\n\nexport const useAuthStore = defineStore('auth', () => {\n  const token = ref<string | null>(null)\n  const refreshTokenValue = ref<string | null>(null)\n  const user = ref<User | null>(null)\n  const isLoading = ref(false)\n  const error = ref<string | null>(null)\n\n  const notificationStore = useNotificationStore()\n\n  // Computed properties\n  const isAuthenticated = computed(() => !!token.value && !!user.value)\n  const isTokenExpired = computed(() => {\n    if (!token.value) return true\n    \n    try {\n      const payload = JSON.parse(atob(token.value.split('.')[1]))\n      const currentTime = Date.now() / 1000\n      return payload.exp < currentTime\n    } catch {\n      return true\n    }\n  })\n\n  // Actions\n  const login = async (credentials: LoginCredentials): Promise<boolean> => {\n    try {\n      isLoading.value = true\n      error.value = null\n\n      const response = await authService.login(credentials)\n      \n      token.value = response.accessToken\n      refreshTokenValue.value = response.refreshToken\n      user.value = response.user\n\n      notificationStore.addNotification({\n        type: 'success',\n        title: 'Login Successful',\n        message: `Welcome back, ${response.user.firstName}!`\n      })\n\n      return true\n    } catch (err: any) {\n      error.value = (err as any).response?.data?.message || 'Login failed'\n      notificationStore.addNotification({\n        type: 'error',\n        title: 'Login Failed',\n        message: error.value || 'Login failed'\n      })\n      return false\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  const logout = async (): Promise<void> => {\n    try {\n      if (token.value) {\n        await authService.logout()\n      }\n    } catch (err) {\n      console.error('Logout error:', err)\n    } finally {\n      // Clear state regardless of API call success\n      token.value = null\n      refreshTokenValue.value = null\n      user.value = null\n      error.value = null\n\n      notificationStore.addNotification({\n        type: 'info',\n        title: 'Logged Out',\n        message: 'You have been logged out successfully'\n      })\n    }\n  }\n\n  const refreshToken = async (): Promise<boolean> => {\n    if (!refreshTokenValue.value) {\n      await logout()\n      return false\n    }\n\n    try {\n      const response = await authService.refreshToken(refreshTokenValue.value)\n      \n      token.value = response.accessToken\n      refreshTokenValue.value = response.refreshToken\n      \n      return true\n    } catch (err) {\n      console.error('Token refresh failed:', err)\n      await logout()\n      return false\n    }\n  }\n\n  const validateAndRefreshToken = async (): Promise<boolean> => {\n    if (!token.value) return false\n\n    // Check if token is expired\n    if (isTokenExpired.value) {\n      return await refreshToken()\n    }\n\n    // Validate token with server\n    try {\n      const isValid = await authService.validateToken(token.value)\n      if (!isValid) {\n        return await refreshToken()\n      }\n      return true\n    } catch {\n      return await refreshToken()\n    }\n  }\n\n  const initialize = async (): Promise<void> => {\n    if (token.value && user.value) {\n      // Validate existing token\n      const isValid = await validateAndRefreshToken()\n      if (!isValid) {\n        // Token refresh failed, user needs to login again\n        await logout()\n      }\n    }\n  }\n\n  const updateUserProfile = async (): Promise<void> => {\n    if (!token.value) return\n\n    try {\n      const userProfile = await authService.getUserProfile(token.value)\n      user.value = userProfile\n    } catch (err) {\n      console.error('Failed to update user profile:', err)\n    }\n  }\n\n  // Auto-refresh token before expiry\n  const setupTokenRefresh = () => {\n    if (!token.value) return\n\n    try {\n      const payload = JSON.parse(atob(token.value.split('.')[1]))\n      const expiryTime = payload.exp * 1000\n      const currentTime = Date.now()\n      const timeUntilExpiry = expiryTime - currentTime\n      \n      // Refresh token 5 minutes before expiry\n      const refreshTime = Math.max(timeUntilExpiry - 5 * 60 * 1000, 0)\n      \n      setTimeout(async () => {\n        await refreshToken()\n        setupTokenRefresh() // Setup next refresh\n      }, refreshTime)\n    } catch {\n      // Invalid token format\n      logout()\n    }\n  }\n\n  return {\n    // State\n    token,\n    refreshTokenValue,\n    user,\n    isLoading,\n    error,\n    \n    // Computed\n    isAuthenticated,\n    isTokenExpired,\n    \n    // Actions\n    login,\n    logout,\n    refreshTokenAction: refreshToken,\n    validateAndRefreshToken,\n    initialize,\n    updateUserProfile,\n    setupTokenRefresh\n  }\n}, {\n  persist: {\n    key: 'aquacontrol-auth',\n    storage: localStorage,\n    paths: ['token', 'refreshTokenValue', 'user']\n  }\n})\n\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n/** Error thrown when an HTTP request fails. */\r\nexport class HttpError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     * @param {number} statusCode The HTTP status code represented by this error.\r\n     */\r\n    constructor(errorMessage, statusCode) {\r\n        const trueProto = new.target.prototype;\r\n        super(`${errorMessage}: Status code '${statusCode}'`);\r\n        this.statusCode = statusCode;\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when a timeout elapses. */\r\nexport class TimeoutError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.TimeoutError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    constructor(errorMessage = \"A timeout occurred.\") {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when an action is aborted. */\r\nexport class AbortError extends Error {\r\n    /** Constructs a new instance of {@link AbortError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    constructor(errorMessage = \"An abort occurred.\") {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when the selected transport is unsupported by the browser. */\r\n/** @private */\r\nexport class UnsupportedTransportError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.UnsupportedTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\r\n     */\r\n    constructor(message, transport) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'UnsupportedTransportError';\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when the selected transport is disabled by the browser. */\r\n/** @private */\r\nexport class DisabledTransportError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.DisabledTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\r\n     */\r\n    constructor(message, transport) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'DisabledTransportError';\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when the selected transport cannot be started. */\r\n/** @private */\r\nexport class FailedToStartTransportError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.FailedToStartTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\r\n     */\r\n    constructor(message, transport) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'FailedToStartTransportError';\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when the negotiation with the server failed to complete. */\r\n/** @private */\r\nexport class FailedToNegotiateWithServerError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.FailedToNegotiateWithServerError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     */\r\n    constructor(message) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.errorType = 'FailedToNegotiateWithServerError';\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when multiple errors have occurred. */\r\n/** @private */\r\nexport class AggregateErrors extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.AggregateErrors}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {Error[]} innerErrors The collection of errors this error is aggregating.\r\n     */\r\n    constructor(message, innerErrors) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.innerErrors = innerErrors;\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n//# sourceMappingURL=Errors.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n/** Represents an HTTP response. */\r\nexport class HttpResponse {\r\n    constructor(statusCode, statusText, content) {\r\n        this.statusCode = statusCode;\r\n        this.statusText = statusText;\r\n        this.content = content;\r\n    }\r\n}\r\n/** Abstraction over an HTTP client.\r\n *\r\n * This class provides an abstraction over an HTTP client so that a different implementation can be provided on different platforms.\r\n */\r\nexport class HttpClient {\r\n    get(url, options) {\r\n        return this.send({\r\n            ...options,\r\n            method: \"GET\",\r\n            url,\r\n        });\r\n    }\r\n    post(url, options) {\r\n        return this.send({\r\n            ...options,\r\n            method: \"POST\",\r\n            url,\r\n        });\r\n    }\r\n    delete(url, options) {\r\n        return this.send({\r\n            ...options,\r\n            method: \"DELETE\",\r\n            url,\r\n        });\r\n    }\r\n    /** Gets all cookies that apply to the specified URL.\r\n     *\r\n     * @param url The URL that the cookies are valid for.\r\n     * @returns {string} A string containing all the key-value cookie pairs for the specified URL.\r\n     */\r\n    // @ts-ignore\r\n    getCookieString(url) {\r\n        return \"\";\r\n    }\r\n}\r\n//# sourceMappingURL=HttpClient.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.\r\n/** Indicates the severity of a log message.\r\n *\r\n * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.\r\n */\r\nexport var LogLevel;\r\n(function (LogLevel) {\r\n    /** Log level for very low severity diagnostic messages. */\r\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\r\n    /** Log level for low severity diagnostic messages. */\r\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\r\n    /** Log level for informational diagnostic messages. */\r\n    LogLevel[LogLevel[\"Information\"] = 2] = \"Information\";\r\n    /** Log level for diagnostic messages that indicate a non-fatal problem. */\r\n    LogLevel[LogLevel[\"Warning\"] = 3] = \"Warning\";\r\n    /** Log level for diagnostic messages that indicate a failure in the current operation. */\r\n    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\r\n    /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */\r\n    LogLevel[LogLevel[\"Critical\"] = 5] = \"Critical\";\r\n    /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */\r\n    LogLevel[LogLevel[\"None\"] = 6] = \"None\";\r\n})(LogLevel || (LogLevel = {}));\r\n//# sourceMappingURL=ILogger.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n/** A logger that does nothing when log messages are sent to it. */\r\nexport class NullLogger {\r\n    constructor() { }\r\n    /** @inheritDoc */\r\n    // eslint-disable-next-line\r\n    log(_logLevel, _message) {\r\n    }\r\n}\r\n/** The singleton instance of the {@link @microsoft/signalr.NullLogger}. */\r\nNullLogger.instance = new NullLogger();\r\n//# sourceMappingURL=Loggers.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { NullLogger } from \"./Loggers\";\r\n// Version token that will be replaced by the prepack command\r\n/** The version of the SignalR client. */\r\nexport const VERSION = \"8.0.17\";\r\n/** @private */\r\nexport class Arg {\r\n    static isRequired(val, name) {\r\n        if (val === null || val === undefined) {\r\n            throw new Error(`The '${name}' argument is required.`);\r\n        }\r\n    }\r\n    static isNotEmpty(val, name) {\r\n        if (!val || val.match(/^\\s*$/)) {\r\n            throw new Error(`The '${name}' argument should not be empty.`);\r\n        }\r\n    }\r\n    static isIn(val, values, name) {\r\n        // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.\r\n        if (!(val in values)) {\r\n            throw new Error(`Unknown ${name} value: ${val}.`);\r\n        }\r\n    }\r\n}\r\n/** @private */\r\nexport class Platform {\r\n    // react-native has a window but no document so we should check both\r\n    static get isBrowser() {\r\n        return !Platform.isNode && typeof window === \"object\" && typeof window.document === \"object\";\r\n    }\r\n    // WebWorkers don't have a window object so the isBrowser check would fail\r\n    static get isWebWorker() {\r\n        return !Platform.isNode && typeof self === \"object\" && \"importScripts\" in self;\r\n    }\r\n    // react-native has a window but no document\r\n    static get isReactNative() {\r\n        return !Platform.isNode && typeof window === \"object\" && typeof window.document === \"undefined\";\r\n    }\r\n    // Node apps shouldn't have a window object, but WebWorkers don't either\r\n    // so we need to check for both WebWorker and window\r\n    static get isNode() {\r\n        return typeof process !== \"undefined\" && process.release && process.release.name === \"node\";\r\n    }\r\n}\r\n/** @private */\r\nexport function getDataDetail(data, includeContent) {\r\n    let detail = \"\";\r\n    if (isArrayBuffer(data)) {\r\n        detail = `Binary data of length ${data.byteLength}`;\r\n        if (includeContent) {\r\n            detail += `. Content: '${formatArrayBuffer(data)}'`;\r\n        }\r\n    }\r\n    else if (typeof data === \"string\") {\r\n        detail = `String data of length ${data.length}`;\r\n        if (includeContent) {\r\n            detail += `. Content: '${data}'`;\r\n        }\r\n    }\r\n    return detail;\r\n}\r\n/** @private */\r\nexport function formatArrayBuffer(data) {\r\n    const view = new Uint8Array(data);\r\n    // Uint8Array.map only supports returning another Uint8Array?\r\n    let str = \"\";\r\n    view.forEach((num) => {\r\n        const pad = num < 16 ? \"0\" : \"\";\r\n        str += `0x${pad}${num.toString(16)} `;\r\n    });\r\n    // Trim of trailing space.\r\n    return str.substr(0, str.length - 1);\r\n}\r\n// Also in signalr-protocol-msgpack/Utils.ts\r\n/** @private */\r\nexport function isArrayBuffer(val) {\r\n    return val && typeof ArrayBuffer !== \"undefined\" &&\r\n        (val instanceof ArrayBuffer ||\r\n            // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\r\n            (val.constructor && val.constructor.name === \"ArrayBuffer\"));\r\n}\r\n/** @private */\r\nexport async function sendMessage(logger, transportName, httpClient, url, content, options) {\r\n    const headers = {};\r\n    const [name, value] = getUserAgentHeader();\r\n    headers[name] = value;\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) sending data. ${getDataDetail(content, options.logMessageContent)}.`);\r\n    const responseType = isArrayBuffer(content) ? \"arraybuffer\" : \"text\";\r\n    const response = await httpClient.post(url, {\r\n        content,\r\n        headers: { ...headers, ...options.headers },\r\n        responseType,\r\n        timeout: options.timeout,\r\n        withCredentials: options.withCredentials,\r\n    });\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) request complete. Response status: ${response.statusCode}.`);\r\n}\r\n/** @private */\r\nexport function createLogger(logger) {\r\n    if (logger === undefined) {\r\n        return new ConsoleLogger(LogLevel.Information);\r\n    }\r\n    if (logger === null) {\r\n        return NullLogger.instance;\r\n    }\r\n    if (logger.log !== undefined) {\r\n        return logger;\r\n    }\r\n    return new ConsoleLogger(logger);\r\n}\r\n/** @private */\r\nexport class SubjectSubscription {\r\n    constructor(subject, observer) {\r\n        this._subject = subject;\r\n        this._observer = observer;\r\n    }\r\n    dispose() {\r\n        const index = this._subject.observers.indexOf(this._observer);\r\n        if (index > -1) {\r\n            this._subject.observers.splice(index, 1);\r\n        }\r\n        if (this._subject.observers.length === 0 && this._subject.cancelCallback) {\r\n            this._subject.cancelCallback().catch((_) => { });\r\n        }\r\n    }\r\n}\r\n/** @private */\r\nexport class ConsoleLogger {\r\n    constructor(minimumLogLevel) {\r\n        this._minLevel = minimumLogLevel;\r\n        this.out = console;\r\n    }\r\n    log(logLevel, message) {\r\n        if (logLevel >= this._minLevel) {\r\n            const msg = `[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`;\r\n            switch (logLevel) {\r\n                case LogLevel.Critical:\r\n                case LogLevel.Error:\r\n                    this.out.error(msg);\r\n                    break;\r\n                case LogLevel.Warning:\r\n                    this.out.warn(msg);\r\n                    break;\r\n                case LogLevel.Information:\r\n                    this.out.info(msg);\r\n                    break;\r\n                default:\r\n                    // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug\r\n                    this.out.log(msg);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n/** @private */\r\nexport function getUserAgentHeader() {\r\n    let userAgentHeaderName = \"X-SignalR-User-Agent\";\r\n    if (Platform.isNode) {\r\n        userAgentHeaderName = \"User-Agent\";\r\n    }\r\n    return [userAgentHeaderName, constructUserAgent(VERSION, getOsName(), getRuntime(), getRuntimeVersion())];\r\n}\r\n/** @private */\r\nexport function constructUserAgent(version, os, runtime, runtimeVersion) {\r\n    // Microsoft SignalR/[Version] ([Detailed Version]; [Operating System]; [Runtime]; [Runtime Version])\r\n    let userAgent = \"Microsoft SignalR/\";\r\n    const majorAndMinor = version.split(\".\");\r\n    userAgent += `${majorAndMinor[0]}.${majorAndMinor[1]}`;\r\n    userAgent += ` (${version}; `;\r\n    if (os && os !== \"\") {\r\n        userAgent += `${os}; `;\r\n    }\r\n    else {\r\n        userAgent += \"Unknown OS; \";\r\n    }\r\n    userAgent += `${runtime}`;\r\n    if (runtimeVersion) {\r\n        userAgent += `; ${runtimeVersion}`;\r\n    }\r\n    else {\r\n        userAgent += \"; Unknown Runtime Version\";\r\n    }\r\n    userAgent += \")\";\r\n    return userAgent;\r\n}\r\n// eslint-disable-next-line spaced-comment\r\n/*#__PURE__*/ function getOsName() {\r\n    if (Platform.isNode) {\r\n        switch (process.platform) {\r\n            case \"win32\":\r\n                return \"Windows NT\";\r\n            case \"darwin\":\r\n                return \"macOS\";\r\n            case \"linux\":\r\n                return \"Linux\";\r\n            default:\r\n                return process.platform;\r\n        }\r\n    }\r\n    else {\r\n        return \"\";\r\n    }\r\n}\r\n// eslint-disable-next-line spaced-comment\r\n/*#__PURE__*/ function getRuntimeVersion() {\r\n    if (Platform.isNode) {\r\n        return process.versions.node;\r\n    }\r\n    return undefined;\r\n}\r\nfunction getRuntime() {\r\n    if (Platform.isNode) {\r\n        return \"NodeJS\";\r\n    }\r\n    else {\r\n        return \"Browser\";\r\n    }\r\n}\r\n/** @private */\r\nexport function getErrorString(e) {\r\n    if (e.stack) {\r\n        return e.stack;\r\n    }\r\n    else if (e.message) {\r\n        return e.message;\r\n    }\r\n    return `${e}`;\r\n}\r\n/** @private */\r\nexport function getGlobalThis() {\r\n    // globalThis is semi-new and not available in Node until v12\r\n    if (typeof globalThis !== \"undefined\") {\r\n        return globalThis;\r\n    }\r\n    if (typeof self !== \"undefined\") {\r\n        return self;\r\n    }\r\n    if (typeof window !== \"undefined\") {\r\n        return window;\r\n    }\r\n    if (typeof global !== \"undefined\") {\r\n        return global;\r\n    }\r\n    throw new Error(\"could not find global\");\r\n}\r\n//# sourceMappingURL=Utils.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpResponse } from \"./HttpClient\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { Platform, getGlobalThis, isArrayBuffer } from \"./Utils\";\r\nexport class FetchHttpClient extends HttpClient {\r\n    constructor(logger) {\r\n        super();\r\n        this._logger = logger;\r\n        // Node added a fetch implementation to the global scope starting in v18.\r\n        // We need to add a cookie jar in node to be able to share cookies with WebSocket\r\n        if (typeof fetch === \"undefined\" || Platform.isNode) {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n            // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\r\n            this._jar = new (requireFunc(\"tough-cookie\")).CookieJar();\r\n            if (typeof fetch === \"undefined\") {\r\n                this._fetchType = requireFunc(\"node-fetch\");\r\n            }\r\n            else {\r\n                // Use fetch from Node if available\r\n                this._fetchType = fetch;\r\n            }\r\n            // node-fetch doesn't have a nice API for getting and setting cookies\r\n            // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\r\n            this._fetchType = requireFunc(\"fetch-cookie\")(this._fetchType, this._jar);\r\n        }\r\n        else {\r\n            this._fetchType = fetch.bind(getGlobalThis());\r\n        }\r\n        if (typeof AbortController === \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n            // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\r\n            this._abortControllerType = requireFunc(\"abort-controller\");\r\n        }\r\n        else {\r\n            this._abortControllerType = AbortController;\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    async send(request) {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            throw new AbortError();\r\n        }\r\n        if (!request.method) {\r\n            throw new Error(\"No method defined.\");\r\n        }\r\n        if (!request.url) {\r\n            throw new Error(\"No url defined.\");\r\n        }\r\n        const abortController = new this._abortControllerType();\r\n        let error;\r\n        // Hook our abortSignal into the abort controller\r\n        if (request.abortSignal) {\r\n            request.abortSignal.onabort = () => {\r\n                abortController.abort();\r\n                error = new AbortError();\r\n            };\r\n        }\r\n        // If a timeout has been passed in, setup a timeout to call abort\r\n        // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\r\n        let timeoutId = null;\r\n        if (request.timeout) {\r\n            const msTimeout = request.timeout;\r\n            timeoutId = setTimeout(() => {\r\n                abortController.abort();\r\n                this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                error = new TimeoutError();\r\n            }, msTimeout);\r\n        }\r\n        if (request.content === \"\") {\r\n            request.content = undefined;\r\n        }\r\n        if (request.content) {\r\n            // Explicitly setting the Content-Type header for React Native on Android platform.\r\n            request.headers = request.headers || {};\r\n            if (isArrayBuffer(request.content)) {\r\n                request.headers[\"Content-Type\"] = \"application/octet-stream\";\r\n            }\r\n            else {\r\n                request.headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\r\n            }\r\n        }\r\n        let response;\r\n        try {\r\n            response = await this._fetchType(request.url, {\r\n                body: request.content,\r\n                cache: \"no-cache\",\r\n                credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\r\n                headers: {\r\n                    \"X-Requested-With\": \"XMLHttpRequest\",\r\n                    ...request.headers,\r\n                },\r\n                method: request.method,\r\n                mode: \"cors\",\r\n                redirect: \"follow\",\r\n                signal: abortController.signal,\r\n            });\r\n        }\r\n        catch (e) {\r\n            if (error) {\r\n                throw error;\r\n            }\r\n            this._logger.log(LogLevel.Warning, `Error from HTTP request. ${e}.`);\r\n            throw e;\r\n        }\r\n        finally {\r\n            if (timeoutId) {\r\n                clearTimeout(timeoutId);\r\n            }\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = null;\r\n            }\r\n        }\r\n        if (!response.ok) {\r\n            const errorMessage = await deserializeContent(response, \"text\");\r\n            throw new HttpError(errorMessage || response.statusText, response.status);\r\n        }\r\n        const content = deserializeContent(response, request.responseType);\r\n        const payload = await content;\r\n        return new HttpResponse(response.status, response.statusText, payload);\r\n    }\r\n    getCookieString(url) {\r\n        let cookies = \"\";\r\n        if (Platform.isNode && this._jar) {\r\n            // @ts-ignore: unused variable\r\n            this._jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\r\n        }\r\n        return cookies;\r\n    }\r\n}\r\nfunction deserializeContent(response, responseType) {\r\n    let content;\r\n    switch (responseType) {\r\n        case \"arraybuffer\":\r\n            content = response.arrayBuffer();\r\n            break;\r\n        case \"text\":\r\n            content = response.text();\r\n            break;\r\n        case \"blob\":\r\n        case \"document\":\r\n        case \"json\":\r\n            throw new Error(`${responseType} is not supported.`);\r\n        default:\r\n            content = response.text();\r\n            break;\r\n    }\r\n    return content;\r\n}\r\n//# sourceMappingURL=FetchHttpClient.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpResponse } from \"./HttpClient\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\nexport class XhrHttpClient extends HttpClient {\r\n    constructor(logger) {\r\n        super();\r\n        this._logger = logger;\r\n    }\r\n    /** @inheritDoc */\r\n    send(request) {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            const xhr = new XMLHttpRequest();\r\n            xhr.open(request.method, request.url, true);\r\n            xhr.withCredentials = request.withCredentials === undefined ? true : request.withCredentials;\r\n            xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\r\n            if (request.content === \"\") {\r\n                request.content = undefined;\r\n            }\r\n            if (request.content) {\r\n                // Explicitly setting the Content-Type header for React Native on Android platform.\r\n                if (isArrayBuffer(request.content)) {\r\n                    xhr.setRequestHeader(\"Content-Type\", \"application/octet-stream\");\r\n                }\r\n                else {\r\n                    xhr.setRequestHeader(\"Content-Type\", \"text/plain;charset=UTF-8\");\r\n                }\r\n            }\r\n            const headers = request.headers;\r\n            if (headers) {\r\n                Object.keys(headers)\r\n                    .forEach((header) => {\r\n                    xhr.setRequestHeader(header, headers[header]);\r\n                });\r\n            }\r\n            if (request.responseType) {\r\n                xhr.responseType = request.responseType;\r\n            }\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = () => {\r\n                    xhr.abort();\r\n                    reject(new AbortError());\r\n                };\r\n            }\r\n            if (request.timeout) {\r\n                xhr.timeout = request.timeout;\r\n            }\r\n            xhr.onload = () => {\r\n                if (request.abortSignal) {\r\n                    request.abortSignal.onabort = null;\r\n                }\r\n                if (xhr.status >= 200 && xhr.status < 300) {\r\n                    resolve(new HttpResponse(xhr.status, xhr.statusText, xhr.response || xhr.responseText));\r\n                }\r\n                else {\r\n                    reject(new HttpError(xhr.response || xhr.responseText || xhr.statusText, xhr.status));\r\n                }\r\n            };\r\n            xhr.onerror = () => {\r\n                this._logger.log(LogLevel.Warning, `Error from HTTP request. ${xhr.status}: ${xhr.statusText}.`);\r\n                reject(new HttpError(xhr.statusText, xhr.status));\r\n            };\r\n            xhr.ontimeout = () => {\r\n                this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                reject(new TimeoutError());\r\n            };\r\n            xhr.send(request.content);\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=XhrHttpClient.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { AbortError } from \"./Errors\";\r\nimport { FetchHttpClient } from \"./FetchHttpClient\";\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { Platform } from \"./Utils\";\r\nimport { XhrHttpClient } from \"./XhrHttpClient\";\r\n/** Default implementation of {@link @microsoft/signalr.HttpClient}. */\r\nexport class DefaultHttpClient extends HttpClient {\r\n    /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */\r\n    constructor(logger) {\r\n        super();\r\n        if (typeof fetch !== \"undefined\" || Platform.isNode) {\r\n            this._httpClient = new FetchHttpClient(logger);\r\n        }\r\n        else if (typeof XMLHttpRequest !== \"undefined\") {\r\n            this._httpClient = new XhrHttpClient(logger);\r\n        }\r\n        else {\r\n            throw new Error(\"No usable HttpClient found.\");\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    send(request) {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n        return this._httpClient.send(request);\r\n    }\r\n    getCookieString(url) {\r\n        return this._httpClient.getCookieString(url);\r\n    }\r\n}\r\n//# sourceMappingURL=DefaultHttpClient.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// Not exported from index\r\n/** @private */\r\nexport class TextMessageFormat {\r\n    static write(output) {\r\n        return `${output}${TextMessageFormat.RecordSeparator}`;\r\n    }\r\n    static parse(input) {\r\n        if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {\r\n            throw new Error(\"Message is incomplete.\");\r\n        }\r\n        const messages = input.split(TextMessageFormat.RecordSeparator);\r\n        messages.pop();\r\n        return messages;\r\n    }\r\n}\r\nTextMessageFormat.RecordSeparatorCode = 0x1e;\r\nTextMessageFormat.RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);\r\n//# sourceMappingURL=TextMessageFormat.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n/** @private */\r\nexport class HandshakeProtocol {\r\n    // Handshake request is always JSON\r\n    writeHandshakeRequest(handshakeRequest) {\r\n        return TextMessageFormat.write(JSON.stringify(handshakeRequest));\r\n    }\r\n    parseHandshakeResponse(data) {\r\n        let messageData;\r\n        let remainingData;\r\n        if (isArrayBuffer(data)) {\r\n            // Format is binary but still need to read JSON text from handshake response\r\n            const binaryData = new Uint8Array(data);\r\n            const separatorIndex = binaryData.indexOf(TextMessageFormat.RecordSeparatorCode);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            const responseLength = separatorIndex + 1;\r\n            messageData = String.fromCharCode.apply(null, Array.prototype.slice.call(binaryData.slice(0, responseLength)));\r\n            remainingData = (binaryData.byteLength > responseLength) ? binaryData.slice(responseLength).buffer : null;\r\n        }\r\n        else {\r\n            const textData = data;\r\n            const separatorIndex = textData.indexOf(TextMessageFormat.RecordSeparator);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            const responseLength = separatorIndex + 1;\r\n            messageData = textData.substring(0, responseLength);\r\n            remainingData = (textData.length > responseLength) ? textData.substring(responseLength) : null;\r\n        }\r\n        // At this point we should have just the single handshake message\r\n        const messages = TextMessageFormat.parse(messageData);\r\n        const response = JSON.parse(messages[0]);\r\n        if (response.type) {\r\n            throw new Error(\"Expected a handshake response from the server.\");\r\n        }\r\n        const responseMessage = response;\r\n        // multiple messages could have arrived with handshake\r\n        // return additional data to be parsed as usual, or null if all parsed\r\n        return [remainingData, responseMessage];\r\n    }\r\n}\r\n//# sourceMappingURL=HandshakeProtocol.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n/** Defines the type of a Hub Message. */\r\nexport var MessageType;\r\n(function (MessageType) {\r\n    /** Indicates the message is an Invocation message and implements the {@link @microsoft/signalr.InvocationMessage} interface. */\r\n    MessageType[MessageType[\"Invocation\"] = 1] = \"Invocation\";\r\n    /** Indicates the message is a StreamItem message and implements the {@link @microsoft/signalr.StreamItemMessage} interface. */\r\n    MessageType[MessageType[\"StreamItem\"] = 2] = \"StreamItem\";\r\n    /** Indicates the message is a Completion message and implements the {@link @microsoft/signalr.CompletionMessage} interface. */\r\n    MessageType[MessageType[\"Completion\"] = 3] = \"Completion\";\r\n    /** Indicates the message is a Stream Invocation message and implements the {@link @microsoft/signalr.StreamInvocationMessage} interface. */\r\n    MessageType[MessageType[\"StreamInvocation\"] = 4] = \"StreamInvocation\";\r\n    /** Indicates the message is a Cancel Invocation message and implements the {@link @microsoft/signalr.CancelInvocationMessage} interface. */\r\n    MessageType[MessageType[\"CancelInvocation\"] = 5] = \"CancelInvocation\";\r\n    /** Indicates the message is a Ping message and implements the {@link @microsoft/signalr.PingMessage} interface. */\r\n    MessageType[MessageType[\"Ping\"] = 6] = \"Ping\";\r\n    /** Indicates the message is a Close message and implements the {@link @microsoft/signalr.CloseMessage} interface. */\r\n    MessageType[MessageType[\"Close\"] = 7] = \"Close\";\r\n    MessageType[MessageType[\"Ack\"] = 8] = \"Ack\";\r\n    MessageType[MessageType[\"Sequence\"] = 9] = \"Sequence\";\r\n})(MessageType || (MessageType = {}));\r\n//# sourceMappingURL=IHubProtocol.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { SubjectSubscription } from \"./Utils\";\r\n/** Stream implementation to stream items to the server. */\r\nexport class Subject {\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n    next(item) {\r\n        for (const observer of this.observers) {\r\n            observer.next(item);\r\n        }\r\n    }\r\n    error(err) {\r\n        for (const observer of this.observers) {\r\n            if (observer.error) {\r\n                observer.error(err);\r\n            }\r\n        }\r\n    }\r\n    complete() {\r\n        for (const observer of this.observers) {\r\n            if (observer.complete) {\r\n                observer.complete();\r\n            }\r\n        }\r\n    }\r\n    subscribe(observer) {\r\n        this.observers.push(observer);\r\n        return new SubjectSubscription(this, observer);\r\n    }\r\n}\r\n//# sourceMappingURL=Subject.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { MessageType } from \"./IHubProtocol\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n/** @private */\r\nexport class MessageBuffer {\r\n    constructor(protocol, connection, bufferSize) {\r\n        this._bufferSize = 100000;\r\n        this._messages = [];\r\n        this._totalMessageCount = 0;\r\n        this._waitForSequenceMessage = false;\r\n        // Message IDs start at 1 and always increment by 1\r\n        this._nextReceivingSequenceId = 1;\r\n        this._latestReceivedSequenceId = 0;\r\n        this._bufferedByteCount = 0;\r\n        this._reconnectInProgress = false;\r\n        this._protocol = protocol;\r\n        this._connection = connection;\r\n        this._bufferSize = bufferSize;\r\n    }\r\n    async _send(message) {\r\n        const serializedMessage = this._protocol.writeMessage(message);\r\n        let backpressurePromise = Promise.resolve();\r\n        // Only count invocation messages. Acks, pings, etc. don't need to be resent on reconnect\r\n        if (this._isInvocationMessage(message)) {\r\n            this._totalMessageCount++;\r\n            let backpressurePromiseResolver = () => { };\r\n            let backpressurePromiseRejector = () => { };\r\n            if (isArrayBuffer(serializedMessage)) {\r\n                this._bufferedByteCount += serializedMessage.byteLength;\r\n            }\r\n            else {\r\n                this._bufferedByteCount += serializedMessage.length;\r\n            }\r\n            if (this._bufferedByteCount >= this._bufferSize) {\r\n                backpressurePromise = new Promise((resolve, reject) => {\r\n                    backpressurePromiseResolver = resolve;\r\n                    backpressurePromiseRejector = reject;\r\n                });\r\n            }\r\n            this._messages.push(new BufferedItem(serializedMessage, this._totalMessageCount, backpressurePromiseResolver, backpressurePromiseRejector));\r\n        }\r\n        try {\r\n            // If this is set it means we are reconnecting or resending\r\n            // We don't want to send on a disconnected connection\r\n            // And we don't want to send if resend is running since that would mean sending\r\n            // this message twice\r\n            if (!this._reconnectInProgress) {\r\n                await this._connection.send(serializedMessage);\r\n            }\r\n        }\r\n        catch {\r\n            this._disconnected();\r\n        }\r\n        await backpressurePromise;\r\n    }\r\n    _ack(ackMessage) {\r\n        let newestAckedMessage = -1;\r\n        // Find index of newest message being acked\r\n        for (let index = 0; index < this._messages.length; index++) {\r\n            const element = this._messages[index];\r\n            if (element._id <= ackMessage.sequenceId) {\r\n                newestAckedMessage = index;\r\n                if (isArrayBuffer(element._message)) {\r\n                    this._bufferedByteCount -= element._message.byteLength;\r\n                }\r\n                else {\r\n                    this._bufferedByteCount -= element._message.length;\r\n                }\r\n                // resolve items that have already been sent and acked\r\n                element._resolver();\r\n            }\r\n            else if (this._bufferedByteCount < this._bufferSize) {\r\n                // resolve items that now fall under the buffer limit but haven't been acked\r\n                element._resolver();\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        if (newestAckedMessage !== -1) {\r\n            // We're removing everything including the message pointed to, so add 1\r\n            this._messages = this._messages.slice(newestAckedMessage + 1);\r\n        }\r\n    }\r\n    _shouldProcessMessage(message) {\r\n        if (this._waitForSequenceMessage) {\r\n            if (message.type !== MessageType.Sequence) {\r\n                return false;\r\n            }\r\n            else {\r\n                this._waitForSequenceMessage = false;\r\n                return true;\r\n            }\r\n        }\r\n        // No special processing for acks, pings, etc.\r\n        if (!this._isInvocationMessage(message)) {\r\n            return true;\r\n        }\r\n        const currentId = this._nextReceivingSequenceId;\r\n        this._nextReceivingSequenceId++;\r\n        if (currentId <= this._latestReceivedSequenceId) {\r\n            if (currentId === this._latestReceivedSequenceId) {\r\n                // Should only hit this if we just reconnected and the server is sending\r\n                // Messages it has buffered, which would mean it hasn't seen an Ack for these messages\r\n                this._ackTimer();\r\n            }\r\n            // Ignore, this is a duplicate message\r\n            return false;\r\n        }\r\n        this._latestReceivedSequenceId = currentId;\r\n        // Only start the timer for sending an Ack message when we have a message to ack. This also conveniently solves\r\n        // timer throttling by not having a recursive timer, and by starting the timer via a network call (recv)\r\n        this._ackTimer();\r\n        return true;\r\n    }\r\n    _resetSequence(message) {\r\n        if (message.sequenceId > this._nextReceivingSequenceId) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._connection.stop(new Error(\"Sequence ID greater than amount of messages we've received.\"));\r\n            return;\r\n        }\r\n        this._nextReceivingSequenceId = message.sequenceId;\r\n    }\r\n    _disconnected() {\r\n        this._reconnectInProgress = true;\r\n        this._waitForSequenceMessage = true;\r\n    }\r\n    async _resend() {\r\n        const sequenceId = this._messages.length !== 0\r\n            ? this._messages[0]._id\r\n            : this._totalMessageCount + 1;\r\n        await this._connection.send(this._protocol.writeMessage({ type: MessageType.Sequence, sequenceId }));\r\n        // Get a local variable to the _messages, just in case messages are acked while resending\r\n        // Which would slice the _messages array (which creates a new copy)\r\n        const messages = this._messages;\r\n        for (const element of messages) {\r\n            await this._connection.send(element._message);\r\n        }\r\n        this._reconnectInProgress = false;\r\n    }\r\n    _dispose(error) {\r\n        error !== null && error !== void 0 ? error : (error = new Error(\"Unable to reconnect to server.\"));\r\n        // Unblock backpressure if any\r\n        for (const element of this._messages) {\r\n            element._rejector(error);\r\n        }\r\n    }\r\n    _isInvocationMessage(message) {\r\n        // There is no way to check if something implements an interface.\r\n        // So we individually check the messages in a switch statement.\r\n        // To make sure we don't miss any message types we rely on the compiler\r\n        // seeing the function returns a value and it will do the\r\n        // exhaustive check for us on the switch statement, since we don't use 'case default'\r\n        switch (message.type) {\r\n            case MessageType.Invocation:\r\n            case MessageType.StreamItem:\r\n            case MessageType.Completion:\r\n            case MessageType.StreamInvocation:\r\n            case MessageType.CancelInvocation:\r\n                return true;\r\n            case MessageType.Close:\r\n            case MessageType.Sequence:\r\n            case MessageType.Ping:\r\n            case MessageType.Ack:\r\n                return false;\r\n        }\r\n    }\r\n    _ackTimer() {\r\n        if (this._ackTimerHandle === undefined) {\r\n            this._ackTimerHandle = setTimeout(async () => {\r\n                try {\r\n                    if (!this._reconnectInProgress) {\r\n                        await this._connection.send(this._protocol.writeMessage({ type: MessageType.Ack, sequenceId: this._latestReceivedSequenceId }));\r\n                    }\r\n                    // Ignore errors, that means the connection is closed and we don't care about the Ack message anymore.\r\n                }\r\n                catch { }\r\n                clearTimeout(this._ackTimerHandle);\r\n                this._ackTimerHandle = undefined;\r\n                // 1 second delay so we don't spam Ack messages if there are many messages being received at once.\r\n            }, 1000);\r\n        }\r\n    }\r\n}\r\nclass BufferedItem {\r\n    constructor(message, id, resolver, rejector) {\r\n        this._message = message;\r\n        this._id = id;\r\n        this._resolver = resolver;\r\n        this._rejector = rejector;\r\n    }\r\n}\r\n//# sourceMappingURL=MessageBuffer.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { HandshakeProtocol } from \"./HandshakeProtocol\";\r\nimport { AbortError } from \"./Errors\";\r\nimport { MessageType } from \"./IHubProtocol\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { Subject } from \"./Subject\";\r\nimport { Arg, getErrorString, Platform } from \"./Utils\";\r\nimport { MessageBuffer } from \"./MessageBuffer\";\r\nconst DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\r\nconst DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;\r\nconst DEFAULT_STATEFUL_RECONNECT_BUFFER_SIZE = 100000;\r\n/** Describes the current state of the {@link HubConnection} to the server. */\r\nexport var HubConnectionState;\r\n(function (HubConnectionState) {\r\n    /** The hub connection is disconnected. */\r\n    HubConnectionState[\"Disconnected\"] = \"Disconnected\";\r\n    /** The hub connection is connecting. */\r\n    HubConnectionState[\"Connecting\"] = \"Connecting\";\r\n    /** The hub connection is connected. */\r\n    HubConnectionState[\"Connected\"] = \"Connected\";\r\n    /** The hub connection is disconnecting. */\r\n    HubConnectionState[\"Disconnecting\"] = \"Disconnecting\";\r\n    /** The hub connection is reconnecting. */\r\n    HubConnectionState[\"Reconnecting\"] = \"Reconnecting\";\r\n})(HubConnectionState || (HubConnectionState = {}));\r\n/** Represents a connection to a SignalR Hub. */\r\nexport class HubConnection {\r\n    /** @internal */\r\n    // Using a public static factory method means we can have a private constructor and an _internal_\r\n    // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\r\n    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\r\n    // public parameter-less constructor.\r\n    static create(connection, logger, protocol, reconnectPolicy, serverTimeoutInMilliseconds, keepAliveIntervalInMilliseconds, statefulReconnectBufferSize) {\r\n        return new HubConnection(connection, logger, protocol, reconnectPolicy, serverTimeoutInMilliseconds, keepAliveIntervalInMilliseconds, statefulReconnectBufferSize);\r\n    }\r\n    constructor(connection, logger, protocol, reconnectPolicy, serverTimeoutInMilliseconds, keepAliveIntervalInMilliseconds, statefulReconnectBufferSize) {\r\n        this._nextKeepAlive = 0;\r\n        this._freezeEventListener = () => {\r\n            this._logger.log(LogLevel.Warning, \"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep\");\r\n        };\r\n        Arg.isRequired(connection, \"connection\");\r\n        Arg.isRequired(logger, \"logger\");\r\n        Arg.isRequired(protocol, \"protocol\");\r\n        this.serverTimeoutInMilliseconds = serverTimeoutInMilliseconds !== null && serverTimeoutInMilliseconds !== void 0 ? serverTimeoutInMilliseconds : DEFAULT_TIMEOUT_IN_MS;\r\n        this.keepAliveIntervalInMilliseconds = keepAliveIntervalInMilliseconds !== null && keepAliveIntervalInMilliseconds !== void 0 ? keepAliveIntervalInMilliseconds : DEFAULT_PING_INTERVAL_IN_MS;\r\n        this._statefulReconnectBufferSize = statefulReconnectBufferSize !== null && statefulReconnectBufferSize !== void 0 ? statefulReconnectBufferSize : DEFAULT_STATEFUL_RECONNECT_BUFFER_SIZE;\r\n        this._logger = logger;\r\n        this._protocol = protocol;\r\n        this.connection = connection;\r\n        this._reconnectPolicy = reconnectPolicy;\r\n        this._handshakeProtocol = new HandshakeProtocol();\r\n        this.connection.onreceive = (data) => this._processIncomingData(data);\r\n        this.connection.onclose = (error) => this._connectionClosed(error);\r\n        this._callbacks = {};\r\n        this._methods = {};\r\n        this._closedCallbacks = [];\r\n        this._reconnectingCallbacks = [];\r\n        this._reconnectedCallbacks = [];\r\n        this._invocationId = 0;\r\n        this._receivedHandshakeResponse = false;\r\n        this._connectionState = HubConnectionState.Disconnected;\r\n        this._connectionStarted = false;\r\n        this._cachedPingMessage = this._protocol.writeMessage({ type: MessageType.Ping });\r\n    }\r\n    /** Indicates the state of the {@link HubConnection} to the server. */\r\n    get state() {\r\n        return this._connectionState;\r\n    }\r\n    /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n     *  in the disconnected state or if the negotiation step was skipped.\r\n     */\r\n    get connectionId() {\r\n        return this.connection ? (this.connection.connectionId || null) : null;\r\n    }\r\n    /** Indicates the url of the {@link HubConnection} to the server. */\r\n    get baseUrl() {\r\n        return this.connection.baseUrl || \"\";\r\n    }\r\n    /**\r\n     * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n     * Reconnecting states.\r\n     * @param {string} url The url to connect to.\r\n     */\r\n    set baseUrl(url) {\r\n        if (this._connectionState !== HubConnectionState.Disconnected && this._connectionState !== HubConnectionState.Reconnecting) {\r\n            throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\r\n        }\r\n        if (!url) {\r\n            throw new Error(\"The HubConnection url must be a valid url.\");\r\n        }\r\n        this.connection.baseUrl = url;\r\n    }\r\n    /** Starts the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n     */\r\n    start() {\r\n        this._startPromise = this._startWithStateTransitions();\r\n        return this._startPromise;\r\n    }\r\n    async _startWithStateTransitions() {\r\n        if (this._connectionState !== HubConnectionState.Disconnected) {\r\n            return Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n        this._connectionState = HubConnectionState.Connecting;\r\n        this._logger.log(LogLevel.Debug, \"Starting HubConnection.\");\r\n        try {\r\n            await this._startInternal();\r\n            if (Platform.isBrowser) {\r\n                // Log when the browser freezes the tab so users know why their connection unexpectedly stopped working\r\n                window.document.addEventListener(\"freeze\", this._freezeEventListener);\r\n            }\r\n            this._connectionState = HubConnectionState.Connected;\r\n            this._connectionStarted = true;\r\n            this._logger.log(LogLevel.Debug, \"HubConnection connected successfully.\");\r\n        }\r\n        catch (e) {\r\n            this._connectionState = HubConnectionState.Disconnected;\r\n            this._logger.log(LogLevel.Debug, `HubConnection failed to start successfully because of error '${e}'.`);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n    async _startInternal() {\r\n        this._stopDuringStartError = undefined;\r\n        this._receivedHandshakeResponse = false;\r\n        // Set up the promise before any connection is (re)started otherwise it could race with received messages\r\n        const handshakePromise = new Promise((resolve, reject) => {\r\n            this._handshakeResolver = resolve;\r\n            this._handshakeRejecter = reject;\r\n        });\r\n        await this.connection.start(this._protocol.transferFormat);\r\n        try {\r\n            let version = this._protocol.version;\r\n            if (!this.connection.features.reconnect) {\r\n                // Stateful Reconnect starts with HubProtocol version 2, newer clients connecting to older servers will fail to connect due to\r\n                // the handshake only supporting version 1, so we will try to send version 1 during the handshake to keep old servers working.\r\n                version = 1;\r\n            }\r\n            const handshakeRequest = {\r\n                protocol: this._protocol.name,\r\n                version,\r\n            };\r\n            this._logger.log(LogLevel.Debug, \"Sending handshake request.\");\r\n            await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(handshakeRequest));\r\n            this._logger.log(LogLevel.Information, `Using HubProtocol '${this._protocol.name}'.`);\r\n            // defensively cleanup timeout in case we receive a message from the server before we finish start\r\n            this._cleanupTimeout();\r\n            this._resetTimeoutPeriod();\r\n            this._resetKeepAliveInterval();\r\n            await handshakePromise;\r\n            // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\r\n            // being rejected on close, because this continuation can run after both the handshake completed successfully\r\n            // and the connection was closed.\r\n            if (this._stopDuringStartError) {\r\n                // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\r\n                // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\r\n                // will cause the calling continuation to get scheduled to run later.\r\n                // eslint-disable-next-line @typescript-eslint/no-throw-literal\r\n                throw this._stopDuringStartError;\r\n            }\r\n            const useStatefulReconnect = this.connection.features.reconnect || false;\r\n            if (useStatefulReconnect) {\r\n                this._messageBuffer = new MessageBuffer(this._protocol, this.connection, this._statefulReconnectBufferSize);\r\n                this.connection.features.disconnected = this._messageBuffer._disconnected.bind(this._messageBuffer);\r\n                this.connection.features.resend = () => {\r\n                    if (this._messageBuffer) {\r\n                        return this._messageBuffer._resend();\r\n                    }\r\n                };\r\n            }\r\n            if (!this.connection.features.inherentKeepAlive) {\r\n                await this._sendMessage(this._cachedPingMessage);\r\n            }\r\n        }\r\n        catch (e) {\r\n            this._logger.log(LogLevel.Debug, `Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`);\r\n            this._cleanupTimeout();\r\n            this._cleanupPingTimer();\r\n            // HttpConnection.stop() should not complete until after the onclose callback is invoked.\r\n            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\r\n            await this.connection.stop(e);\r\n            throw e;\r\n        }\r\n    }\r\n    /** Stops the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n     */\r\n    async stop() {\r\n        // Capture the start promise before the connection might be restarted in an onclose callback.\r\n        const startPromise = this._startPromise;\r\n        this.connection.features.reconnect = false;\r\n        this._stopPromise = this._stopInternal();\r\n        await this._stopPromise;\r\n        try {\r\n            // Awaiting undefined continues immediately\r\n            await startPromise;\r\n        }\r\n        catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n    }\r\n    _stopInternal(error) {\r\n        if (this._connectionState === HubConnectionState.Disconnected) {\r\n            this._logger.log(LogLevel.Debug, `Call to HubConnection.stop(${error}) ignored because it is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n        if (this._connectionState === HubConnectionState.Disconnecting) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this._stopPromise;\r\n        }\r\n        const state = this._connectionState;\r\n        this._connectionState = HubConnectionState.Disconnecting;\r\n        this._logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\r\n        if (this._reconnectDelayHandle) {\r\n            // We're in a reconnect delay which means the underlying connection is currently already stopped.\r\n            // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\r\n            // fire the onclose callbacks.\r\n            this._logger.log(LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\r\n            clearTimeout(this._reconnectDelayHandle);\r\n            this._reconnectDelayHandle = undefined;\r\n            this._completeClose();\r\n            return Promise.resolve();\r\n        }\r\n        if (state === HubConnectionState.Connected) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._sendCloseMessage();\r\n        }\r\n        this._cleanupTimeout();\r\n        this._cleanupPingTimer();\r\n        this._stopDuringStartError = error || new AbortError(\"The connection was stopped before the hub handshake could complete.\");\r\n        // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\r\n        // or the onclose callback is invoked. The onclose callback will transition the HubConnection\r\n        // to the disconnected state if need be before HttpConnection.stop() completes.\r\n        return this.connection.stop(error);\r\n    }\r\n    async _sendCloseMessage() {\r\n        try {\r\n            await this._sendWithProtocol(this._createCloseMessage());\r\n        }\r\n        catch {\r\n            // Ignore, this is a best effort attempt to let the server know the client closed gracefully.\r\n        }\r\n    }\r\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n     *\r\n     * @typeparam T The type of the items returned by the server.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n     */\r\n    stream(methodName, ...args) {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const invocationDescriptor = this._createStreamInvocation(methodName, args, streamIds);\r\n        // eslint-disable-next-line prefer-const\r\n        let promiseQueue;\r\n        const subject = new Subject();\r\n        subject.cancelCallback = () => {\r\n            const cancelInvocation = this._createCancelInvocation(invocationDescriptor.invocationId);\r\n            delete this._callbacks[invocationDescriptor.invocationId];\r\n            return promiseQueue.then(() => {\r\n                return this._sendWithProtocol(cancelInvocation);\r\n            });\r\n        };\r\n        this._callbacks[invocationDescriptor.invocationId] = (invocationEvent, error) => {\r\n            if (error) {\r\n                subject.error(error);\r\n                return;\r\n            }\r\n            else if (invocationEvent) {\r\n                // invocationEvent will not be null when an error is not passed to the callback\r\n                if (invocationEvent.type === MessageType.Completion) {\r\n                    if (invocationEvent.error) {\r\n                        subject.error(new Error(invocationEvent.error));\r\n                    }\r\n                    else {\r\n                        subject.complete();\r\n                    }\r\n                }\r\n                else {\r\n                    subject.next((invocationEvent.item));\r\n                }\r\n            }\r\n        };\r\n        promiseQueue = this._sendWithProtocol(invocationDescriptor)\r\n            .catch((e) => {\r\n            subject.error(e);\r\n            delete this._callbacks[invocationDescriptor.invocationId];\r\n        });\r\n        this._launchStreams(streams, promiseQueue);\r\n        return subject;\r\n    }\r\n    _sendMessage(message) {\r\n        this._resetKeepAliveInterval();\r\n        return this.connection.send(message);\r\n    }\r\n    /**\r\n     * Sends a js object to the server.\r\n     * @param message The js object to serialize and send.\r\n     */\r\n    _sendWithProtocol(message) {\r\n        if (this._messageBuffer) {\r\n            return this._messageBuffer._send(message);\r\n        }\r\n        else {\r\n            return this._sendMessage(this._protocol.writeMessage(message));\r\n        }\r\n    }\r\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n     *\r\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n     * be processing the invocation.\r\n     *\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n     */\r\n    send(methodName, ...args) {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const sendPromise = this._sendWithProtocol(this._createInvocation(methodName, args, true, streamIds));\r\n        this._launchStreams(streams, sendPromise);\r\n        return sendPromise;\r\n    }\r\n    /** Invokes a hub method on the server using the specified name and arguments.\r\n     *\r\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n     * resolving the Promise.\r\n     *\r\n     * @typeparam T The expected return type.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n     */\r\n    invoke(methodName, ...args) {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const invocationDescriptor = this._createInvocation(methodName, args, false, streamIds);\r\n        const p = new Promise((resolve, reject) => {\r\n            // invocationId will always have a value for a non-blocking invocation\r\n            this._callbacks[invocationDescriptor.invocationId] = (invocationEvent, error) => {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                }\r\n                else if (invocationEvent) {\r\n                    // invocationEvent will not be null when an error is not passed to the callback\r\n                    if (invocationEvent.type === MessageType.Completion) {\r\n                        if (invocationEvent.error) {\r\n                            reject(new Error(invocationEvent.error));\r\n                        }\r\n                        else {\r\n                            resolve(invocationEvent.result);\r\n                        }\r\n                    }\r\n                    else {\r\n                        reject(new Error(`Unexpected message type: ${invocationEvent.type}`));\r\n                    }\r\n                }\r\n            };\r\n            const promiseQueue = this._sendWithProtocol(invocationDescriptor)\r\n                .catch((e) => {\r\n                reject(e);\r\n                // invocationId will always have a value for a non-blocking invocation\r\n                delete this._callbacks[invocationDescriptor.invocationId];\r\n            });\r\n            this._launchStreams(streams, promiseQueue);\r\n        });\r\n        return p;\r\n    }\r\n    on(methodName, newMethod) {\r\n        if (!methodName || !newMethod) {\r\n            return;\r\n        }\r\n        methodName = methodName.toLowerCase();\r\n        if (!this._methods[methodName]) {\r\n            this._methods[methodName] = [];\r\n        }\r\n        // Preventing adding the same handler multiple times.\r\n        if (this._methods[methodName].indexOf(newMethod) !== -1) {\r\n            return;\r\n        }\r\n        this._methods[methodName].push(newMethod);\r\n    }\r\n    off(methodName, method) {\r\n        if (!methodName) {\r\n            return;\r\n        }\r\n        methodName = methodName.toLowerCase();\r\n        const handlers = this._methods[methodName];\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        if (method) {\r\n            const removeIdx = handlers.indexOf(method);\r\n            if (removeIdx !== -1) {\r\n                handlers.splice(removeIdx, 1);\r\n                if (handlers.length === 0) {\r\n                    delete this._methods[methodName];\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            delete this._methods[methodName];\r\n        }\r\n    }\r\n    /** Registers a handler that will be invoked when the connection is closed.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n     */\r\n    onclose(callback) {\r\n        if (callback) {\r\n            this._closedCallbacks.push(callback);\r\n        }\r\n    }\r\n    /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n     */\r\n    onreconnecting(callback) {\r\n        if (callback) {\r\n            this._reconnectingCallbacks.push(callback);\r\n        }\r\n    }\r\n    /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n     */\r\n    onreconnected(callback) {\r\n        if (callback) {\r\n            this._reconnectedCallbacks.push(callback);\r\n        }\r\n    }\r\n    _processIncomingData(data) {\r\n        this._cleanupTimeout();\r\n        if (!this._receivedHandshakeResponse) {\r\n            data = this._processHandshakeResponse(data);\r\n            this._receivedHandshakeResponse = true;\r\n        }\r\n        // Data may have all been read when processing handshake response\r\n        if (data) {\r\n            // Parse the messages\r\n            const messages = this._protocol.parseMessages(data, this._logger);\r\n            for (const message of messages) {\r\n                if (this._messageBuffer && !this._messageBuffer._shouldProcessMessage(message)) {\r\n                    // Don't process the message, we are either waiting for a SequenceMessage or received a duplicate message\r\n                    continue;\r\n                }\r\n                switch (message.type) {\r\n                    case MessageType.Invocation:\r\n                        this._invokeClientMethod(message)\r\n                            .catch((e) => {\r\n                            this._logger.log(LogLevel.Error, `Invoke client method threw error: ${getErrorString(e)}`);\r\n                        });\r\n                        break;\r\n                    case MessageType.StreamItem:\r\n                    case MessageType.Completion: {\r\n                        const callback = this._callbacks[message.invocationId];\r\n                        if (callback) {\r\n                            if (message.type === MessageType.Completion) {\r\n                                delete this._callbacks[message.invocationId];\r\n                            }\r\n                            try {\r\n                                callback(message);\r\n                            }\r\n                            catch (e) {\r\n                                this._logger.log(LogLevel.Error, `Stream callback threw error: ${getErrorString(e)}`);\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MessageType.Ping:\r\n                        // Don't care about pings\r\n                        break;\r\n                    case MessageType.Close: {\r\n                        this._logger.log(LogLevel.Information, \"Close message received from server.\");\r\n                        const error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\r\n                        if (message.allowReconnect === true) {\r\n                            // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\r\n                            // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\r\n                            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n                            this.connection.stop(error);\r\n                        }\r\n                        else {\r\n                            // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\r\n                            this._stopPromise = this._stopInternal(error);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MessageType.Ack:\r\n                        if (this._messageBuffer) {\r\n                            this._messageBuffer._ack(message);\r\n                        }\r\n                        break;\r\n                    case MessageType.Sequence:\r\n                        if (this._messageBuffer) {\r\n                            this._messageBuffer._resetSequence(message);\r\n                        }\r\n                        break;\r\n                    default:\r\n                        this._logger.log(LogLevel.Warning, `Invalid message type: ${message.type}.`);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        this._resetTimeoutPeriod();\r\n    }\r\n    _processHandshakeResponse(data) {\r\n        let responseMessage;\r\n        let remainingData;\r\n        try {\r\n            [remainingData, responseMessage] = this._handshakeProtocol.parseHandshakeResponse(data);\r\n        }\r\n        catch (e) {\r\n            const message = \"Error parsing handshake response: \" + e;\r\n            this._logger.log(LogLevel.Error, message);\r\n            const error = new Error(message);\r\n            this._handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        if (responseMessage.error) {\r\n            const message = \"Server returned handshake error: \" + responseMessage.error;\r\n            this._logger.log(LogLevel.Error, message);\r\n            const error = new Error(message);\r\n            this._handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        else {\r\n            this._logger.log(LogLevel.Debug, \"Server handshake complete.\");\r\n        }\r\n        this._handshakeResolver();\r\n        return remainingData;\r\n    }\r\n    _resetKeepAliveInterval() {\r\n        if (this.connection.features.inherentKeepAlive) {\r\n            return;\r\n        }\r\n        // Set the time we want the next keep alive to be sent\r\n        // Timer will be setup on next message receive\r\n        this._nextKeepAlive = new Date().getTime() + this.keepAliveIntervalInMilliseconds;\r\n        this._cleanupPingTimer();\r\n    }\r\n    _resetTimeoutPeriod() {\r\n        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\r\n            // Set the timeout timer\r\n            this._timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds);\r\n            // Set keepAlive timer if there isn't one\r\n            if (this._pingServerHandle === undefined) {\r\n                let nextPing = this._nextKeepAlive - new Date().getTime();\r\n                if (nextPing < 0) {\r\n                    nextPing = 0;\r\n                }\r\n                // The timer needs to be set from a networking callback to avoid Chrome timer throttling from causing timers to run once a minute\r\n                this._pingServerHandle = setTimeout(async () => {\r\n                    if (this._connectionState === HubConnectionState.Connected) {\r\n                        try {\r\n                            await this._sendMessage(this._cachedPingMessage);\r\n                        }\r\n                        catch {\r\n                            // We don't care about the error. It should be seen elsewhere in the client.\r\n                            // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\r\n                            this._cleanupPingTimer();\r\n                        }\r\n                    }\r\n                }, nextPing);\r\n            }\r\n        }\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    serverTimeout() {\r\n        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\r\n        // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\r\n    }\r\n    async _invokeClientMethod(invocationMessage) {\r\n        const methodName = invocationMessage.target.toLowerCase();\r\n        const methods = this._methods[methodName];\r\n        if (!methods) {\r\n            this._logger.log(LogLevel.Warning, `No client method with the name '${methodName}' found.`);\r\n            // No handlers provided by client but the server is expecting a response still, so we send an error\r\n            if (invocationMessage.invocationId) {\r\n                this._logger.log(LogLevel.Warning, `No result given for '${methodName}' method and invocation ID '${invocationMessage.invocationId}'.`);\r\n                await this._sendWithProtocol(this._createCompletionMessage(invocationMessage.invocationId, \"Client didn't provide a result.\", null));\r\n            }\r\n            return;\r\n        }\r\n        // Avoid issues with handlers removing themselves thus modifying the list while iterating through it\r\n        const methodsCopy = methods.slice();\r\n        // Server expects a response\r\n        const expectsResponse = invocationMessage.invocationId ? true : false;\r\n        // We preserve the last result or exception but still call all handlers\r\n        let res;\r\n        let exception;\r\n        let completionMessage;\r\n        for (const m of methodsCopy) {\r\n            try {\r\n                const prevRes = res;\r\n                res = await m.apply(this, invocationMessage.arguments);\r\n                if (expectsResponse && res && prevRes) {\r\n                    this._logger.log(LogLevel.Error, `Multiple results provided for '${methodName}'. Sending error to server.`);\r\n                    completionMessage = this._createCompletionMessage(invocationMessage.invocationId, `Client provided multiple results.`, null);\r\n                }\r\n                // Ignore exception if we got a result after, the exception will be logged\r\n                exception = undefined;\r\n            }\r\n            catch (e) {\r\n                exception = e;\r\n                this._logger.log(LogLevel.Error, `A callback for the method '${methodName}' threw error '${e}'.`);\r\n            }\r\n        }\r\n        if (completionMessage) {\r\n            await this._sendWithProtocol(completionMessage);\r\n        }\r\n        else if (expectsResponse) {\r\n            // If there is an exception that means either no result was given or a handler after a result threw\r\n            if (exception) {\r\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId, `${exception}`, null);\r\n            }\r\n            else if (res !== undefined) {\r\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId, null, res);\r\n            }\r\n            else {\r\n                this._logger.log(LogLevel.Warning, `No result given for '${methodName}' method and invocation ID '${invocationMessage.invocationId}'.`);\r\n                // Client didn't provide a result or throw from a handler, server expects a response so we send an error\r\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId, \"Client didn't provide a result.\", null);\r\n            }\r\n            await this._sendWithProtocol(completionMessage);\r\n        }\r\n        else {\r\n            if (res) {\r\n                this._logger.log(LogLevel.Error, `Result given for '${methodName}' method but server is not expecting a result.`);\r\n            }\r\n        }\r\n    }\r\n    _connectionClosed(error) {\r\n        this._logger.log(LogLevel.Debug, `HubConnection.connectionClosed(${error}) called while in state ${this._connectionState}.`);\r\n        // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\r\n        this._stopDuringStartError = this._stopDuringStartError || error || new AbortError(\"The underlying connection was closed before the hub handshake could complete.\");\r\n        // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\r\n        // If it has already completed, this should just noop.\r\n        if (this._handshakeResolver) {\r\n            this._handshakeResolver();\r\n        }\r\n        this._cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\r\n        this._cleanupTimeout();\r\n        this._cleanupPingTimer();\r\n        if (this._connectionState === HubConnectionState.Disconnecting) {\r\n            this._completeClose(error);\r\n        }\r\n        else if (this._connectionState === HubConnectionState.Connected && this._reconnectPolicy) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._reconnect(error);\r\n        }\r\n        else if (this._connectionState === HubConnectionState.Connected) {\r\n            this._completeClose(error);\r\n        }\r\n        // If none of the above if conditions were true were called the HubConnection must be in either:\r\n        // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\r\n        // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\r\n        //    and potentially continue the reconnect() loop.\r\n        // 3. The Disconnected state in which case we're already done.\r\n    }\r\n    _completeClose(error) {\r\n        if (this._connectionStarted) {\r\n            this._connectionState = HubConnectionState.Disconnected;\r\n            this._connectionStarted = false;\r\n            if (this._messageBuffer) {\r\n                this._messageBuffer._dispose(error !== null && error !== void 0 ? error : new Error(\"Connection closed.\"));\r\n                this._messageBuffer = undefined;\r\n            }\r\n            if (Platform.isBrowser) {\r\n                window.document.removeEventListener(\"freeze\", this._freezeEventListener);\r\n            }\r\n            try {\r\n                this._closedCallbacks.forEach((c) => c.apply(this, [error]));\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `An onclose callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n    async _reconnect(error) {\r\n        const reconnectStartTime = Date.now();\r\n        let previousReconnectAttempts = 0;\r\n        let retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\r\n        let nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\r\n        if (nextRetryDelay === null) {\r\n            this._logger.log(LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\r\n            this._completeClose(error);\r\n            return;\r\n        }\r\n        this._connectionState = HubConnectionState.Reconnecting;\r\n        if (error) {\r\n            this._logger.log(LogLevel.Information, `Connection reconnecting because of error '${error}'.`);\r\n        }\r\n        else {\r\n            this._logger.log(LogLevel.Information, \"Connection reconnecting.\");\r\n        }\r\n        if (this._reconnectingCallbacks.length !== 0) {\r\n            try {\r\n                this._reconnectingCallbacks.forEach((c) => c.apply(this, [error]));\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `An onreconnecting callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n            // Exit early if an onreconnecting callback called connection.stop().\r\n            if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                this._logger.log(LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\r\n                return;\r\n            }\r\n        }\r\n        while (nextRetryDelay !== null) {\r\n            this._logger.log(LogLevel.Information, `Reconnect attempt number ${previousReconnectAttempts} will start in ${nextRetryDelay} ms.`);\r\n            await new Promise((resolve) => {\r\n                this._reconnectDelayHandle = setTimeout(resolve, nextRetryDelay);\r\n            });\r\n            this._reconnectDelayHandle = undefined;\r\n            if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                this._logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\r\n                return;\r\n            }\r\n            try {\r\n                await this._startInternal();\r\n                this._connectionState = HubConnectionState.Connected;\r\n                this._logger.log(LogLevel.Information, \"HubConnection reconnected successfully.\");\r\n                if (this._reconnectedCallbacks.length !== 0) {\r\n                    try {\r\n                        this._reconnectedCallbacks.forEach((c) => c.apply(this, [this.connection.connectionId]));\r\n                    }\r\n                    catch (e) {\r\n                        this._logger.log(LogLevel.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`);\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Information, `Reconnect attempt failed because of error '${e}'.`);\r\n                if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                    this._logger.log(LogLevel.Debug, `Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`);\r\n                    // The TypeScript compiler thinks that connectionState must be Connected here. The TypeScript compiler is wrong.\r\n                    if (this._connectionState === HubConnectionState.Disconnecting) {\r\n                        this._completeClose();\r\n                    }\r\n                    return;\r\n                }\r\n                retryError = e instanceof Error ? e : new Error(e.toString());\r\n                nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\r\n            }\r\n        }\r\n        this._logger.log(LogLevel.Information, `Reconnect retries have been exhausted after ${Date.now() - reconnectStartTime} ms and ${previousReconnectAttempts} failed attempts. Connection disconnecting.`);\r\n        this._completeClose();\r\n    }\r\n    _getNextRetryDelay(previousRetryCount, elapsedMilliseconds, retryReason) {\r\n        try {\r\n            return this._reconnectPolicy.nextRetryDelayInMilliseconds({\r\n                elapsedMilliseconds,\r\n                previousRetryCount,\r\n                retryReason,\r\n            });\r\n        }\r\n        catch (e) {\r\n            this._logger.log(LogLevel.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${previousRetryCount}, ${elapsedMilliseconds}) threw error '${e}'.`);\r\n            return null;\r\n        }\r\n    }\r\n    _cancelCallbacksWithError(error) {\r\n        const callbacks = this._callbacks;\r\n        this._callbacks = {};\r\n        Object.keys(callbacks)\r\n            .forEach((key) => {\r\n            const callback = callbacks[key];\r\n            try {\r\n                callback(null, error);\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `Stream 'error' callback called with '${error}' threw error: ${getErrorString(e)}`);\r\n            }\r\n        });\r\n    }\r\n    _cleanupPingTimer() {\r\n        if (this._pingServerHandle) {\r\n            clearTimeout(this._pingServerHandle);\r\n            this._pingServerHandle = undefined;\r\n        }\r\n    }\r\n    _cleanupTimeout() {\r\n        if (this._timeoutHandle) {\r\n            clearTimeout(this._timeoutHandle);\r\n        }\r\n    }\r\n    _createInvocation(methodName, args, nonblocking, streamIds) {\r\n        if (nonblocking) {\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    arguments: args,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        }\r\n        else {\r\n            const invocationId = this._invocationId;\r\n            this._invocationId++;\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        }\r\n    }\r\n    _launchStreams(streams, promiseQueue) {\r\n        if (streams.length === 0) {\r\n            return;\r\n        }\r\n        // Synchronize stream data so they arrive in-order on the server\r\n        if (!promiseQueue) {\r\n            promiseQueue = Promise.resolve();\r\n        }\r\n        // We want to iterate over the keys, since the keys are the stream ids\r\n        // eslint-disable-next-line guard-for-in\r\n        for (const streamId in streams) {\r\n            streams[streamId].subscribe({\r\n                complete: () => {\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId)));\r\n                },\r\n                error: (err) => {\r\n                    let message;\r\n                    if (err instanceof Error) {\r\n                        message = err.message;\r\n                    }\r\n                    else if (err && err.toString) {\r\n                        message = err.toString();\r\n                    }\r\n                    else {\r\n                        message = \"Unknown error\";\r\n                    }\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId, message)));\r\n                },\r\n                next: (item) => {\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createStreamItemMessage(streamId, item)));\r\n                },\r\n            });\r\n        }\r\n    }\r\n    _replaceStreamingParams(args) {\r\n        const streams = [];\r\n        const streamIds = [];\r\n        for (let i = 0; i < args.length; i++) {\r\n            const argument = args[i];\r\n            if (this._isObservable(argument)) {\r\n                const streamId = this._invocationId;\r\n                this._invocationId++;\r\n                // Store the stream for later use\r\n                streams[streamId] = argument;\r\n                streamIds.push(streamId.toString());\r\n                // remove stream from args\r\n                args.splice(i, 1);\r\n            }\r\n        }\r\n        return [streams, streamIds];\r\n    }\r\n    _isObservable(arg) {\r\n        // This allows other stream implementations to just work (like rxjs)\r\n        return arg && arg.subscribe && typeof arg.subscribe === \"function\";\r\n    }\r\n    _createStreamInvocation(methodName, args, streamIds) {\r\n        const invocationId = this._invocationId;\r\n        this._invocationId++;\r\n        if (streamIds.length !== 0) {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                streamIds,\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        }\r\n    }\r\n    _createCancelInvocation(id) {\r\n        return {\r\n            invocationId: id,\r\n            type: MessageType.CancelInvocation,\r\n        };\r\n    }\r\n    _createStreamItemMessage(id, item) {\r\n        return {\r\n            invocationId: id,\r\n            item,\r\n            type: MessageType.StreamItem,\r\n        };\r\n    }\r\n    _createCompletionMessage(id, error, result) {\r\n        if (error) {\r\n            return {\r\n                error,\r\n                invocationId: id,\r\n                type: MessageType.Completion,\r\n            };\r\n        }\r\n        return {\r\n            invocationId: id,\r\n            result,\r\n            type: MessageType.Completion,\r\n        };\r\n    }\r\n    _createCloseMessage() {\r\n        return { type: MessageType.Close };\r\n    }\r\n}\r\n//# sourceMappingURL=HubConnection.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// 0, 2, 10, 30 second delays before reconnect attempts.\r\nconst DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2000, 10000, 30000, null];\r\n/** @private */\r\nexport class DefaultReconnectPolicy {\r\n    constructor(retryDelays) {\r\n        this._retryDelays = retryDelays !== undefined ? [...retryDelays, null] : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS;\r\n    }\r\n    nextRetryDelayInMilliseconds(retryContext) {\r\n        return this._retryDelays[retryContext.previousRetryCount];\r\n    }\r\n}\r\n//# sourceMappingURL=DefaultReconnectPolicy.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nexport class HeaderNames {\r\n}\r\nHeaderNames.Authorization = \"Authorization\";\r\nHeaderNames.Cookie = \"Cookie\";\r\n//# sourceMappingURL=HeaderNames.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { HttpClient } from \"./HttpClient\";\r\n/** @private */\r\nexport class AccessTokenHttpClient extends HttpClient {\r\n    constructor(innerClient, accessTokenFactory) {\r\n        super();\r\n        this._innerClient = innerClient;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n    }\r\n    async send(request) {\r\n        let allowRetry = true;\r\n        if (this._accessTokenFactory && (!this._accessToken || (request.url && request.url.indexOf(\"/negotiate?\") > 0))) {\r\n            // don't retry if the request is a negotiate or if we just got a potentially new token from the access token factory\r\n            allowRetry = false;\r\n            this._accessToken = await this._accessTokenFactory();\r\n        }\r\n        this._setAuthorizationHeader(request);\r\n        const response = await this._innerClient.send(request);\r\n        if (allowRetry && response.statusCode === 401 && this._accessTokenFactory) {\r\n            this._accessToken = await this._accessTokenFactory();\r\n            this._setAuthorizationHeader(request);\r\n            return await this._innerClient.send(request);\r\n        }\r\n        return response;\r\n    }\r\n    _setAuthorizationHeader(request) {\r\n        if (!request.headers) {\r\n            request.headers = {};\r\n        }\r\n        if (this._accessToken) {\r\n            request.headers[HeaderNames.Authorization] = `Bearer ${this._accessToken}`;\r\n        }\r\n        // don't remove the header if there isn't an access token factory, the user manually added the header in this case\r\n        else if (this._accessTokenFactory) {\r\n            if (request.headers[HeaderNames.Authorization]) {\r\n                delete request.headers[HeaderNames.Authorization];\r\n            }\r\n        }\r\n    }\r\n    getCookieString(url) {\r\n        return this._innerClient.getCookieString(url);\r\n    }\r\n}\r\n//# sourceMappingURL=AccessTokenHttpClient.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// This will be treated as a bit flag in the future, so we keep it using power-of-two values.\r\n/** Specifies a specific HTTP transport type. */\r\nexport var HttpTransportType;\r\n(function (HttpTransportType) {\r\n    /** Specifies no transport preference. */\r\n    HttpTransportType[HttpTransportType[\"None\"] = 0] = \"None\";\r\n    /** Specifies the WebSockets transport. */\r\n    HttpTransportType[HttpTransportType[\"WebSockets\"] = 1] = \"WebSockets\";\r\n    /** Specifies the Server-Sent Events transport. */\r\n    HttpTransportType[HttpTransportType[\"ServerSentEvents\"] = 2] = \"ServerSentEvents\";\r\n    /** Specifies the Long Polling transport. */\r\n    HttpTransportType[HttpTransportType[\"LongPolling\"] = 4] = \"LongPolling\";\r\n})(HttpTransportType || (HttpTransportType = {}));\r\n/** Specifies the transfer format for a connection. */\r\nexport var TransferFormat;\r\n(function (TransferFormat) {\r\n    /** Specifies that only text data will be transmitted over the connection. */\r\n    TransferFormat[TransferFormat[\"Text\"] = 1] = \"Text\";\r\n    /** Specifies that binary data will be transmitted over the connection. */\r\n    TransferFormat[TransferFormat[\"Binary\"] = 2] = \"Binary\";\r\n})(TransferFormat || (TransferFormat = {}));\r\n//# sourceMappingURL=ITransport.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// Rough polyfill of https://developer.mozilla.org/en-US/docs/Web/API/AbortController\r\n// We don't actually ever use the API being polyfilled, we always use the polyfill because\r\n// it's a very new API right now.\r\n// Not exported from index.\r\n/** @private */\r\nexport class AbortController {\r\n    constructor() {\r\n        this._isAborted = false;\r\n        this.onabort = null;\r\n    }\r\n    abort() {\r\n        if (!this._isAborted) {\r\n            this._isAborted = true;\r\n            if (this.onabort) {\r\n                this.onabort();\r\n            }\r\n        }\r\n    }\r\n    get signal() {\r\n        return this;\r\n    }\r\n    get aborted() {\r\n        return this._isAborted;\r\n    }\r\n}\r\n//# sourceMappingURL=AbortController.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { AbortController } from \"./AbortController\";\r\nimport { HttpError, TimeoutError } from \"./Errors\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, sendMessage } from \"./Utils\";\r\n// Not exported from 'index', this type is internal.\r\n/** @private */\r\nexport class LongPollingTransport {\r\n    // This is an internal type, not exported from 'index' so this is really just internal.\r\n    get pollAborted() {\r\n        return this._pollAbort.aborted;\r\n    }\r\n    constructor(httpClient, logger, options) {\r\n        this._httpClient = httpClient;\r\n        this._logger = logger;\r\n        this._pollAbort = new AbortController();\r\n        this._options = options;\r\n        this._running = false;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    async connect(url, transferFormat) {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._url = url;\r\n        this._logger.log(LogLevel.Trace, \"(LongPolling transport) Connecting.\");\r\n        // Allow binary format on Node and Browsers that support binary content (indicated by the presence of responseType property)\r\n        if (transferFormat === TransferFormat.Binary &&\r\n            (typeof XMLHttpRequest !== \"undefined\" && typeof new XMLHttpRequest().responseType !== \"string\")) {\r\n            throw new Error(\"Binary protocols over XmlHttpRequest not implementing advanced features are not supported.\");\r\n        }\r\n        const [name, value] = getUserAgentHeader();\r\n        const headers = { [name]: value, ...this._options.headers };\r\n        const pollOptions = {\r\n            abortSignal: this._pollAbort.signal,\r\n            headers,\r\n            timeout: 100000,\r\n            withCredentials: this._options.withCredentials,\r\n        };\r\n        if (transferFormat === TransferFormat.Binary) {\r\n            pollOptions.responseType = \"arraybuffer\";\r\n        }\r\n        // Make initial long polling request\r\n        // Server uses first long polling request to finish initializing connection and it returns without data\r\n        const pollUrl = `${url}&_=${Date.now()}`;\r\n        this._logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\r\n        const response = await this._httpClient.get(pollUrl, pollOptions);\r\n        if (response.statusCode !== 200) {\r\n            this._logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\r\n            // Mark running as false so that the poll immediately ends and runs the close logic\r\n            this._closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n            this._running = false;\r\n        }\r\n        else {\r\n            this._running = true;\r\n        }\r\n        this._receiving = this._poll(this._url, pollOptions);\r\n    }\r\n    async _poll(url, pollOptions) {\r\n        try {\r\n            while (this._running) {\r\n                try {\r\n                    const pollUrl = `${url}&_=${Date.now()}`;\r\n                    this._logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\r\n                    const response = await this._httpClient.get(pollUrl, pollOptions);\r\n                    if (response.statusCode === 204) {\r\n                        this._logger.log(LogLevel.Information, \"(LongPolling transport) Poll terminated by server.\");\r\n                        this._running = false;\r\n                    }\r\n                    else if (response.statusCode !== 200) {\r\n                        this._logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\r\n                        // Unexpected status code\r\n                        this._closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n                        this._running = false;\r\n                    }\r\n                    else {\r\n                        // Process the response\r\n                        if (response.content) {\r\n                            this._logger.log(LogLevel.Trace, `(LongPolling transport) data received. ${getDataDetail(response.content, this._options.logMessageContent)}.`);\r\n                            if (this.onreceive) {\r\n                                this.onreceive(response.content);\r\n                            }\r\n                        }\r\n                        else {\r\n                            // This is another way timeout manifest.\r\n                            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                        }\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    if (!this._running) {\r\n                        // Log but disregard errors that occur after stopping\r\n                        this._logger.log(LogLevel.Trace, `(LongPolling transport) Poll errored after shutdown: ${e.message}`);\r\n                    }\r\n                    else {\r\n                        if (e instanceof TimeoutError) {\r\n                            // Ignore timeouts and reissue the poll.\r\n                            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                        }\r\n                        else {\r\n                            // Close the connection with the error as the result.\r\n                            this._closeError = e;\r\n                            this._running = false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        finally {\r\n            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Polling complete.\");\r\n            // We will reach here with pollAborted==false when the server returned a response causing the transport to stop.\r\n            // If pollAborted==true then client initiated the stop and the stop method will raise the close event after DELETE is sent.\r\n            if (!this.pollAborted) {\r\n                this._raiseOnClose();\r\n            }\r\n        }\r\n    }\r\n    async send(data) {\r\n        if (!this._running) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this._logger, \"LongPolling\", this._httpClient, this._url, data, this._options);\r\n    }\r\n    async stop() {\r\n        this._logger.log(LogLevel.Trace, \"(LongPolling transport) Stopping polling.\");\r\n        // Tell receiving loop to stop, abort any current request, and then wait for it to finish\r\n        this._running = false;\r\n        this._pollAbort.abort();\r\n        try {\r\n            await this._receiving;\r\n            // Send DELETE to clean up long polling on the server\r\n            this._logger.log(LogLevel.Trace, `(LongPolling transport) sending DELETE request to ${this._url}.`);\r\n            const headers = {};\r\n            const [name, value] = getUserAgentHeader();\r\n            headers[name] = value;\r\n            const deleteOptions = {\r\n                headers: { ...headers, ...this._options.headers },\r\n                timeout: this._options.timeout,\r\n                withCredentials: this._options.withCredentials,\r\n            };\r\n            let error;\r\n            try {\r\n                await this._httpClient.delete(this._url, deleteOptions);\r\n            }\r\n            catch (err) {\r\n                error = err;\r\n            }\r\n            if (error) {\r\n                if (error instanceof HttpError) {\r\n                    if (error.statusCode === 404) {\r\n                        this._logger.log(LogLevel.Trace, \"(LongPolling transport) A 404 response was returned from sending a DELETE request.\");\r\n                    }\r\n                    else {\r\n                        this._logger.log(LogLevel.Trace, `(LongPolling transport) Error sending a DELETE request: ${error}`);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                this._logger.log(LogLevel.Trace, \"(LongPolling transport) DELETE request accepted.\");\r\n            }\r\n        }\r\n        finally {\r\n            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Stop finished.\");\r\n            // Raise close event here instead of in polling\r\n            // It needs to happen after the DELETE request is sent\r\n            this._raiseOnClose();\r\n        }\r\n    }\r\n    _raiseOnClose() {\r\n        if (this.onclose) {\r\n            let logMessage = \"(LongPolling transport) Firing onclose event.\";\r\n            if (this._closeError) {\r\n                logMessage += \" Error: \" + this._closeError;\r\n            }\r\n            this._logger.log(LogLevel.Trace, logMessage);\r\n            this.onclose(this._closeError);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=LongPollingTransport.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\r\n/** @private */\r\nexport class ServerSentEventsTransport {\r\n    constructor(httpClient, accessToken, logger, options) {\r\n        this._httpClient = httpClient;\r\n        this._accessToken = accessToken;\r\n        this._logger = logger;\r\n        this._options = options;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    async connect(url, transferFormat) {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\r\n        // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send\r\n        this._url = url;\r\n        if (this._accessToken) {\r\n            url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(this._accessToken)}`;\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            let opened = false;\r\n            if (transferFormat !== TransferFormat.Text) {\r\n                reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\r\n                return;\r\n            }\r\n            let eventSource;\r\n            if (Platform.isBrowser || Platform.isWebWorker) {\r\n                eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials });\r\n            }\r\n            else {\r\n                // Non-browser passes cookies via the dictionary\r\n                const cookies = this._httpClient.getCookieString(url);\r\n                const headers = {};\r\n                headers.Cookie = cookies;\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n                eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials, headers: { ...headers, ...this._options.headers } });\r\n            }\r\n            try {\r\n                eventSource.onmessage = (e) => {\r\n                    if (this.onreceive) {\r\n                        try {\r\n                            this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this._options.logMessageContent)}.`);\r\n                            this.onreceive(e.data);\r\n                        }\r\n                        catch (error) {\r\n                            this._close(error);\r\n                            return;\r\n                        }\r\n                    }\r\n                };\r\n                // @ts-ignore: not using event on purpose\r\n                eventSource.onerror = (e) => {\r\n                    // EventSource doesn't give any useful information about server side closes.\r\n                    if (opened) {\r\n                        this._close();\r\n                    }\r\n                    else {\r\n                        reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\"\r\n                            + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\"\r\n                            + \" If you have multiple servers check that sticky sessions are enabled.\"));\r\n                    }\r\n                };\r\n                eventSource.onopen = () => {\r\n                    this._logger.log(LogLevel.Information, `SSE connected to ${this._url}`);\r\n                    this._eventSource = eventSource;\r\n                    opened = true;\r\n                    resolve();\r\n                };\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n                return;\r\n            }\r\n        });\r\n    }\r\n    async send(data) {\r\n        if (!this._eventSource) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this._logger, \"SSE\", this._httpClient, this._url, data, this._options);\r\n    }\r\n    stop() {\r\n        this._close();\r\n        return Promise.resolve();\r\n    }\r\n    _close(e) {\r\n        if (this._eventSource) {\r\n            this._eventSource.close();\r\n            this._eventSource = undefined;\r\n            if (this.onclose) {\r\n                this.onclose(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=ServerSentEventsTransport.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform } from \"./Utils\";\r\n/** @private */\r\nexport class WebSocketTransport {\r\n    constructor(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor, headers) {\r\n        this._logger = logger;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n        this._logMessageContent = logMessageContent;\r\n        this._webSocketConstructor = webSocketConstructor;\r\n        this._httpClient = httpClient;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n        this._headers = headers;\r\n    }\r\n    async connect(url, transferFormat) {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) Connecting.\");\r\n        let token;\r\n        if (this._accessTokenFactory) {\r\n            token = await this._accessTokenFactory();\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            url = url.replace(/^http/, \"ws\");\r\n            let webSocket;\r\n            const cookies = this._httpClient.getCookieString(url);\r\n            let opened = false;\r\n            if (Platform.isNode || Platform.isReactNative) {\r\n                const headers = {};\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n                if (token) {\r\n                    headers[HeaderNames.Authorization] = `Bearer ${token}`;\r\n                }\r\n                if (cookies) {\r\n                    headers[HeaderNames.Cookie] = cookies;\r\n                }\r\n                // Only pass headers when in non-browser environments\r\n                webSocket = new this._webSocketConstructor(url, undefined, {\r\n                    headers: { ...headers, ...this._headers },\r\n                });\r\n            }\r\n            else {\r\n                if (token) {\r\n                    url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n                }\r\n            }\r\n            if (!webSocket) {\r\n                // Chrome is not happy with passing 'undefined' as protocol\r\n                webSocket = new this._webSocketConstructor(url);\r\n            }\r\n            if (transferFormat === TransferFormat.Binary) {\r\n                webSocket.binaryType = \"arraybuffer\";\r\n            }\r\n            webSocket.onopen = (_event) => {\r\n                this._logger.log(LogLevel.Information, `WebSocket connected to ${url}.`);\r\n                this._webSocket = webSocket;\r\n                opened = true;\r\n                resolve();\r\n            };\r\n            webSocket.onerror = (event) => {\r\n                let error = null;\r\n                // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                    error = event.error;\r\n                }\r\n                else {\r\n                    error = \"There was an error with the transport\";\r\n                }\r\n                this._logger.log(LogLevel.Information, `(WebSockets transport) ${error}.`);\r\n            };\r\n            webSocket.onmessage = (message) => {\r\n                this._logger.log(LogLevel.Trace, `(WebSockets transport) data received. ${getDataDetail(message.data, this._logMessageContent)}.`);\r\n                if (this.onreceive) {\r\n                    try {\r\n                        this.onreceive(message.data);\r\n                    }\r\n                    catch (error) {\r\n                        this._close(error);\r\n                        return;\r\n                    }\r\n                }\r\n            };\r\n            webSocket.onclose = (event) => {\r\n                // Don't call close handler if connection was never established\r\n                // We'll reject the connect call instead\r\n                if (opened) {\r\n                    this._close(event);\r\n                }\r\n                else {\r\n                    let error = null;\r\n                    // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                    if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                        error = event.error;\r\n                    }\r\n                    else {\r\n                        error = \"WebSocket failed to connect. The connection could not be found on the server,\"\r\n                            + \" either the endpoint may not be a SignalR endpoint,\"\r\n                            + \" the connection ID is not present on the server, or there is a proxy blocking WebSockets.\"\r\n                            + \" If you have multiple servers check that sticky sessions are enabled.\";\r\n                    }\r\n                    reject(new Error(error));\r\n                }\r\n            };\r\n        });\r\n    }\r\n    send(data) {\r\n        if (this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN) {\r\n            this._logger.log(LogLevel.Trace, `(WebSockets transport) sending data. ${getDataDetail(data, this._logMessageContent)}.`);\r\n            this._webSocket.send(data);\r\n            return Promise.resolve();\r\n        }\r\n        return Promise.reject(\"WebSocket is not in the OPEN state\");\r\n    }\r\n    stop() {\r\n        if (this._webSocket) {\r\n            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\r\n            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\r\n            this._close(undefined);\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    _close(event) {\r\n        // webSocket will be null if the transport did not start successfully\r\n        if (this._webSocket) {\r\n            // Clear websocket handlers because we are considering the socket closed now\r\n            this._webSocket.onclose = () => { };\r\n            this._webSocket.onmessage = () => { };\r\n            this._webSocket.onerror = () => { };\r\n            this._webSocket.close();\r\n            this._webSocket = undefined;\r\n        }\r\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) socket closed.\");\r\n        if (this.onclose) {\r\n            if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\r\n                this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason || \"no reason given\"}).`));\r\n            }\r\n            else if (event instanceof Error) {\r\n                this.onclose(event);\r\n            }\r\n            else {\r\n                this.onclose();\r\n            }\r\n        }\r\n    }\r\n    _isCloseEvent(event) {\r\n        return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\r\n    }\r\n}\r\n//# sourceMappingURL=WebSocketTransport.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { AccessTokenHttpClient } from \"./AccessTokenHttpClient\";\r\nimport { DefaultHttpClient } from \"./DefaultHttpClient\";\r\nimport { AggregateErrors, DisabledTransportError, FailedToNegotiateWithServerError, FailedToStartTransportError, HttpError, UnsupportedTransportError, AbortError } from \"./Errors\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { HttpTransportType, TransferFormat } from \"./ITransport\";\r\nimport { LongPollingTransport } from \"./LongPollingTransport\";\r\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\r\nimport { Arg, createLogger, getUserAgentHeader, Platform } from \"./Utils\";\r\nimport { WebSocketTransport } from \"./WebSocketTransport\";\r\nconst MAX_REDIRECTS = 100;\r\n/** @private */\r\nexport class HttpConnection {\r\n    constructor(url, options = {}) {\r\n        this._stopPromiseResolver = () => { };\r\n        this.features = {};\r\n        this._negotiateVersion = 1;\r\n        Arg.isRequired(url, \"url\");\r\n        this._logger = createLogger(options.logger);\r\n        this.baseUrl = this._resolveUrl(url);\r\n        options = options || {};\r\n        options.logMessageContent = options.logMessageContent === undefined ? false : options.logMessageContent;\r\n        if (typeof options.withCredentials === \"boolean\" || options.withCredentials === undefined) {\r\n            options.withCredentials = options.withCredentials === undefined ? true : options.withCredentials;\r\n        }\r\n        else {\r\n            throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\r\n        }\r\n        options.timeout = options.timeout === undefined ? 100 * 1000 : options.timeout;\r\n        let webSocketModule = null;\r\n        let eventSourceModule = null;\r\n        if (Platform.isNode && typeof require !== \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n            webSocketModule = requireFunc(\"ws\");\r\n            eventSourceModule = requireFunc(\"eventsource\");\r\n        }\r\n        if (!Platform.isNode && typeof WebSocket !== \"undefined\" && !options.WebSocket) {\r\n            options.WebSocket = WebSocket;\r\n        }\r\n        else if (Platform.isNode && !options.WebSocket) {\r\n            if (webSocketModule) {\r\n                options.WebSocket = webSocketModule;\r\n            }\r\n        }\r\n        if (!Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\r\n            options.EventSource = EventSource;\r\n        }\r\n        else if (Platform.isNode && !options.EventSource) {\r\n            if (typeof eventSourceModule !== \"undefined\") {\r\n                options.EventSource = eventSourceModule;\r\n            }\r\n        }\r\n        this._httpClient = new AccessTokenHttpClient(options.httpClient || new DefaultHttpClient(this._logger), options.accessTokenFactory);\r\n        this._connectionState = \"Disconnected\" /* ConnectionState.Disconnected */;\r\n        this._connectionStarted = false;\r\n        this._options = options;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    async start(transferFormat) {\r\n        transferFormat = transferFormat || TransferFormat.Binary;\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Debug, `Starting connection with transfer format '${TransferFormat[transferFormat]}'.`);\r\n        if (this._connectionState !== \"Disconnected\" /* ConnectionState.Disconnected */) {\r\n            return Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n        this._connectionState = \"Connecting\" /* ConnectionState.Connecting */;\r\n        this._startInternalPromise = this._startInternal(transferFormat);\r\n        await this._startInternalPromise;\r\n        // The TypeScript compiler thinks that connectionState must be Connecting here. The TypeScript compiler is wrong.\r\n        if (this._connectionState === \"Disconnecting\" /* ConnectionState.Disconnecting */) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"Failed to start the HttpConnection before stop() was called.\";\r\n            this._logger.log(LogLevel.Error, message);\r\n            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\r\n            await this._stopPromise;\r\n            return Promise.reject(new AbortError(message));\r\n        }\r\n        else if (this._connectionState !== \"Connected\" /* ConnectionState.Connected */) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\r\n            this._logger.log(LogLevel.Error, message);\r\n            return Promise.reject(new AbortError(message));\r\n        }\r\n        this._connectionStarted = true;\r\n    }\r\n    send(data) {\r\n        if (this._connectionState !== \"Connected\" /* ConnectionState.Connected */) {\r\n            return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\r\n        }\r\n        if (!this._sendQueue) {\r\n            this._sendQueue = new TransportSendQueue(this.transport);\r\n        }\r\n        // Transport will not be null if state is connected\r\n        return this._sendQueue.send(data);\r\n    }\r\n    async stop(error) {\r\n        if (this._connectionState === \"Disconnected\" /* ConnectionState.Disconnected */) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n        if (this._connectionState === \"Disconnecting\" /* ConnectionState.Disconnecting */) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this._stopPromise;\r\n        }\r\n        this._connectionState = \"Disconnecting\" /* ConnectionState.Disconnecting */;\r\n        this._stopPromise = new Promise((resolve) => {\r\n            // Don't complete stop() until stopConnection() completes.\r\n            this._stopPromiseResolver = resolve;\r\n        });\r\n        // stopInternal should never throw so just observe it.\r\n        await this._stopInternal(error);\r\n        await this._stopPromise;\r\n    }\r\n    async _stopInternal(error) {\r\n        // Set error as soon as possible otherwise there is a race between\r\n        // the transport closing and providing an error and the error from a close message\r\n        // We would prefer the close message error.\r\n        this._stopError = error;\r\n        try {\r\n            await this._startInternalPromise;\r\n        }\r\n        catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n        // The transport's onclose will trigger stopConnection which will run our onclose event.\r\n        // The transport should always be set if currently connected. If it wasn't set, it's likely because\r\n        // stop was called during start() and start() failed.\r\n        if (this.transport) {\r\n            try {\r\n                await this.transport.stop();\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `HttpConnection.transport.stop() threw error '${e}'.`);\r\n                this._stopConnection();\r\n            }\r\n            this.transport = undefined;\r\n        }\r\n        else {\r\n            this._logger.log(LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\r\n        }\r\n    }\r\n    async _startInternal(transferFormat) {\r\n        // Store the original base url and the access token factory since they may change\r\n        // as part of negotiating\r\n        let url = this.baseUrl;\r\n        this._accessTokenFactory = this._options.accessTokenFactory;\r\n        this._httpClient._accessTokenFactory = this._accessTokenFactory;\r\n        try {\r\n            if (this._options.skipNegotiation) {\r\n                if (this._options.transport === HttpTransportType.WebSockets) {\r\n                    // No need to add a connection ID in this case\r\n                    this.transport = this._constructTransport(HttpTransportType.WebSockets);\r\n                    // We should just call connect directly in this case.\r\n                    // No fallback or negotiate in this case.\r\n                    await this._startTransport(url, transferFormat);\r\n                }\r\n                else {\r\n                    throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\r\n                }\r\n            }\r\n            else {\r\n                let negotiateResponse = null;\r\n                let redirects = 0;\r\n                do {\r\n                    negotiateResponse = await this._getNegotiationResponse(url);\r\n                    // the user tries to stop the connection when it is being started\r\n                    if (this._connectionState === \"Disconnecting\" /* ConnectionState.Disconnecting */ || this._connectionState === \"Disconnected\" /* ConnectionState.Disconnected */) {\r\n                        throw new AbortError(\"The connection was stopped during negotiation.\");\r\n                    }\r\n                    if (negotiateResponse.error) {\r\n                        throw new Error(negotiateResponse.error);\r\n                    }\r\n                    if (negotiateResponse.ProtocolVersion) {\r\n                        throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\r\n                    }\r\n                    if (negotiateResponse.url) {\r\n                        url = negotiateResponse.url;\r\n                    }\r\n                    if (negotiateResponse.accessToken) {\r\n                        // Replace the current access token factory with one that uses\r\n                        // the returned access token\r\n                        const accessToken = negotiateResponse.accessToken;\r\n                        this._accessTokenFactory = () => accessToken;\r\n                        // set the factory to undefined so the AccessTokenHttpClient won't retry with the same token, since we know it won't change until a connection restart\r\n                        this._httpClient._accessToken = accessToken;\r\n                        this._httpClient._accessTokenFactory = undefined;\r\n                    }\r\n                    redirects++;\r\n                } while (negotiateResponse.url && redirects < MAX_REDIRECTS);\r\n                if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\r\n                    throw new Error(\"Negotiate redirection limit exceeded.\");\r\n                }\r\n                await this._createTransport(url, this._options.transport, negotiateResponse, transferFormat);\r\n            }\r\n            if (this.transport instanceof LongPollingTransport) {\r\n                this.features.inherentKeepAlive = true;\r\n            }\r\n            if (this._connectionState === \"Connecting\" /* ConnectionState.Connecting */) {\r\n                // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\r\n                // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\r\n                this._logger.log(LogLevel.Debug, \"The HttpConnection connected successfully.\");\r\n                this._connectionState = \"Connected\" /* ConnectionState.Connected */;\r\n            }\r\n            // stop() is waiting on us via this.startInternalPromise so keep this.transport around so it can clean up.\r\n            // This is the only case startInternal can exit in neither the connected nor disconnected state because stopConnection()\r\n            // will transition to the disconnected state. start() will wait for the transition using the stopPromise.\r\n        }\r\n        catch (e) {\r\n            this._logger.log(LogLevel.Error, \"Failed to start the connection: \" + e);\r\n            this._connectionState = \"Disconnected\" /* ConnectionState.Disconnected */;\r\n            this.transport = undefined;\r\n            // if start fails, any active calls to stop assume that start will complete the stop promise\r\n            this._stopPromiseResolver();\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n    async _getNegotiationResponse(url) {\r\n        const headers = {};\r\n        const [name, value] = getUserAgentHeader();\r\n        headers[name] = value;\r\n        const negotiateUrl = this._resolveNegotiateUrl(url);\r\n        this._logger.log(LogLevel.Debug, `Sending negotiation request: ${negotiateUrl}.`);\r\n        try {\r\n            const response = await this._httpClient.post(negotiateUrl, {\r\n                content: \"\",\r\n                headers: { ...headers, ...this._options.headers },\r\n                timeout: this._options.timeout,\r\n                withCredentials: this._options.withCredentials,\r\n            });\r\n            if (response.statusCode !== 200) {\r\n                return Promise.reject(new Error(`Unexpected status code returned from negotiate '${response.statusCode}'`));\r\n            }\r\n            const negotiateResponse = JSON.parse(response.content);\r\n            if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\r\n                // Negotiate version 0 doesn't use connectionToken\r\n                // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\r\n                negotiateResponse.connectionToken = negotiateResponse.connectionId;\r\n            }\r\n            if (negotiateResponse.useStatefulReconnect && this._options._useStatefulReconnect !== true) {\r\n                return Promise.reject(new FailedToNegotiateWithServerError(\"Client didn't negotiate Stateful Reconnect but the server did.\"));\r\n            }\r\n            return negotiateResponse;\r\n        }\r\n        catch (e) {\r\n            let errorMessage = \"Failed to complete negotiation with the server: \" + e;\r\n            if (e instanceof HttpError) {\r\n                if (e.statusCode === 404) {\r\n                    errorMessage = errorMessage + \" Either this is not a SignalR endpoint or there is a proxy blocking the connection.\";\r\n                }\r\n            }\r\n            this._logger.log(LogLevel.Error, errorMessage);\r\n            return Promise.reject(new FailedToNegotiateWithServerError(errorMessage));\r\n        }\r\n    }\r\n    _createConnectUrl(url, connectionToken) {\r\n        if (!connectionToken) {\r\n            return url;\r\n        }\r\n        return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + `id=${connectionToken}`;\r\n    }\r\n    async _createTransport(url, requestedTransport, negotiateResponse, requestedTransferFormat) {\r\n        let connectUrl = this._createConnectUrl(url, negotiateResponse.connectionToken);\r\n        if (this._isITransport(requestedTransport)) {\r\n            this._logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\r\n            this.transport = requestedTransport;\r\n            await this._startTransport(connectUrl, requestedTransferFormat);\r\n            this.connectionId = negotiateResponse.connectionId;\r\n            return;\r\n        }\r\n        const transportExceptions = [];\r\n        const transports = negotiateResponse.availableTransports || [];\r\n        let negotiate = negotiateResponse;\r\n        for (const endpoint of transports) {\r\n            const transportOrError = this._resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat, (negotiate === null || negotiate === void 0 ? void 0 : negotiate.useStatefulReconnect) === true);\r\n            if (transportOrError instanceof Error) {\r\n                // Store the error and continue, we don't want to cause a re-negotiate in these cases\r\n                transportExceptions.push(`${endpoint.transport} failed:`);\r\n                transportExceptions.push(transportOrError);\r\n            }\r\n            else if (this._isITransport(transportOrError)) {\r\n                this.transport = transportOrError;\r\n                if (!negotiate) {\r\n                    try {\r\n                        negotiate = await this._getNegotiationResponse(url);\r\n                    }\r\n                    catch (ex) {\r\n                        return Promise.reject(ex);\r\n                    }\r\n                    connectUrl = this._createConnectUrl(url, negotiate.connectionToken);\r\n                }\r\n                try {\r\n                    await this._startTransport(connectUrl, requestedTransferFormat);\r\n                    this.connectionId = negotiate.connectionId;\r\n                    return;\r\n                }\r\n                catch (ex) {\r\n                    this._logger.log(LogLevel.Error, `Failed to start the transport '${endpoint.transport}': ${ex}`);\r\n                    negotiate = undefined;\r\n                    transportExceptions.push(new FailedToStartTransportError(`${endpoint.transport} failed: ${ex}`, HttpTransportType[endpoint.transport]));\r\n                    if (this._connectionState !== \"Connecting\" /* ConnectionState.Connecting */) {\r\n                        const message = \"Failed to select transport before stop() was called.\";\r\n                        this._logger.log(LogLevel.Debug, message);\r\n                        return Promise.reject(new AbortError(message));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (transportExceptions.length > 0) {\r\n            return Promise.reject(new AggregateErrors(`Unable to connect to the server with any of the available transports. ${transportExceptions.join(\" \")}`, transportExceptions));\r\n        }\r\n        return Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"));\r\n    }\r\n    _constructTransport(transport) {\r\n        switch (transport) {\r\n            case HttpTransportType.WebSockets:\r\n                if (!this._options.WebSocket) {\r\n                    throw new Error(\"'WebSocket' is not supported in your environment.\");\r\n                }\r\n                return new WebSocketTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options.logMessageContent, this._options.WebSocket, this._options.headers || {});\r\n            case HttpTransportType.ServerSentEvents:\r\n                if (!this._options.EventSource) {\r\n                    throw new Error(\"'EventSource' is not supported in your environment.\");\r\n                }\r\n                return new ServerSentEventsTransport(this._httpClient, this._httpClient._accessToken, this._logger, this._options);\r\n            case HttpTransportType.LongPolling:\r\n                return new LongPollingTransport(this._httpClient, this._logger, this._options);\r\n            default:\r\n                throw new Error(`Unknown transport: ${transport}.`);\r\n        }\r\n    }\r\n    _startTransport(url, transferFormat) {\r\n        this.transport.onreceive = this.onreceive;\r\n        if (this.features.reconnect) {\r\n            this.transport.onclose = async (e) => {\r\n                let callStop = false;\r\n                if (this.features.reconnect) {\r\n                    try {\r\n                        this.features.disconnected();\r\n                        await this.transport.connect(url, transferFormat);\r\n                        await this.features.resend();\r\n                    }\r\n                    catch {\r\n                        callStop = true;\r\n                    }\r\n                }\r\n                else {\r\n                    this._stopConnection(e);\r\n                    return;\r\n                }\r\n                if (callStop) {\r\n                    this._stopConnection(e);\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            this.transport.onclose = (e) => this._stopConnection(e);\r\n        }\r\n        return this.transport.connect(url, transferFormat);\r\n    }\r\n    _resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat, useStatefulReconnect) {\r\n        const transport = HttpTransportType[endpoint.transport];\r\n        if (transport === null || transport === undefined) {\r\n            this._logger.log(LogLevel.Debug, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n            return new Error(`Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n        }\r\n        else {\r\n            if (transportMatches(requestedTransport, transport)) {\r\n                const transferFormats = endpoint.transferFormats.map((s) => TransferFormat[s]);\r\n                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\r\n                    if ((transport === HttpTransportType.WebSockets && !this._options.WebSocket) ||\r\n                        (transport === HttpTransportType.ServerSentEvents && !this._options.EventSource)) {\r\n                        this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it is not supported in your environment.'`);\r\n                        return new UnsupportedTransportError(`'${HttpTransportType[transport]}' is not supported in your environment.`, transport);\r\n                    }\r\n                    else {\r\n                        this._logger.log(LogLevel.Debug, `Selecting transport '${HttpTransportType[transport]}'.`);\r\n                        try {\r\n                            this.features.reconnect = transport === HttpTransportType.WebSockets ? useStatefulReconnect : undefined;\r\n                            return this._constructTransport(transport);\r\n                        }\r\n                        catch (ex) {\r\n                            return ex;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it does not support the requested transfer format '${TransferFormat[requestedTransferFormat]}'.`);\r\n                    return new Error(`'${HttpTransportType[transport]}' does not support ${TransferFormat[requestedTransferFormat]}.`);\r\n                }\r\n            }\r\n            else {\r\n                this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it was disabled by the client.`);\r\n                return new DisabledTransportError(`'${HttpTransportType[transport]}' is disabled by the client.`, transport);\r\n            }\r\n        }\r\n    }\r\n    _isITransport(transport) {\r\n        return transport && typeof (transport) === \"object\" && \"connect\" in transport;\r\n    }\r\n    _stopConnection(error) {\r\n        this._logger.log(LogLevel.Debug, `HttpConnection.stopConnection(${error}) called while in state ${this._connectionState}.`);\r\n        this.transport = undefined;\r\n        // If we have a stopError, it takes precedence over the error from the transport\r\n        error = this._stopError || error;\r\n        this._stopError = undefined;\r\n        if (this._connectionState === \"Disconnected\" /* ConnectionState.Disconnected */) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is already in the disconnected state.`);\r\n            return;\r\n        }\r\n        if (this._connectionState === \"Connecting\" /* ConnectionState.Connecting */) {\r\n            this._logger.log(LogLevel.Warning, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is still in the connecting state.`);\r\n            throw new Error(`HttpConnection.stopConnection(${error}) was called while the connection is still in the connecting state.`);\r\n        }\r\n        if (this._connectionState === \"Disconnecting\" /* ConnectionState.Disconnecting */) {\r\n            // A call to stop() induced this call to stopConnection and needs to be completed.\r\n            // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\r\n            this._stopPromiseResolver();\r\n        }\r\n        if (error) {\r\n            this._logger.log(LogLevel.Error, `Connection disconnected with error '${error}'.`);\r\n        }\r\n        else {\r\n            this._logger.log(LogLevel.Information, \"Connection disconnected.\");\r\n        }\r\n        if (this._sendQueue) {\r\n            this._sendQueue.stop().catch((e) => {\r\n                this._logger.log(LogLevel.Error, `TransportSendQueue.stop() threw error '${e}'.`);\r\n            });\r\n            this._sendQueue = undefined;\r\n        }\r\n        this.connectionId = undefined;\r\n        this._connectionState = \"Disconnected\" /* ConnectionState.Disconnected */;\r\n        if (this._connectionStarted) {\r\n            this._connectionStarted = false;\r\n            try {\r\n                if (this.onclose) {\r\n                    this.onclose(error);\r\n                }\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `HttpConnection.onclose(${error}) threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n    _resolveUrl(url) {\r\n        // startsWith is not supported in IE\r\n        if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\r\n            return url;\r\n        }\r\n        if (!Platform.isBrowser) {\r\n            throw new Error(`Cannot resolve '${url}'.`);\r\n        }\r\n        // Setting the url to the href propery of an anchor tag handles normalization\r\n        // for us. There are 3 main cases.\r\n        // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\r\n        // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\r\n        // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\r\n        const aTag = window.document.createElement(\"a\");\r\n        aTag.href = url;\r\n        this._logger.log(LogLevel.Information, `Normalizing '${url}' to '${aTag.href}'.`);\r\n        return aTag.href;\r\n    }\r\n    _resolveNegotiateUrl(url) {\r\n        const negotiateUrl = new URL(url);\r\n        if (negotiateUrl.pathname.endsWith('/')) {\r\n            negotiateUrl.pathname += \"negotiate\";\r\n        }\r\n        else {\r\n            negotiateUrl.pathname += \"/negotiate\";\r\n        }\r\n        const searchParams = new URLSearchParams(negotiateUrl.searchParams);\r\n        if (!searchParams.has(\"negotiateVersion\")) {\r\n            searchParams.append(\"negotiateVersion\", this._negotiateVersion.toString());\r\n        }\r\n        if (searchParams.has(\"useStatefulReconnect\")) {\r\n            if (searchParams.get(\"useStatefulReconnect\") === \"true\") {\r\n                this._options._useStatefulReconnect = true;\r\n            }\r\n        }\r\n        else if (this._options._useStatefulReconnect === true) {\r\n            searchParams.append(\"useStatefulReconnect\", \"true\");\r\n        }\r\n        negotiateUrl.search = searchParams.toString();\r\n        return negotiateUrl.toString();\r\n    }\r\n}\r\nfunction transportMatches(requestedTransport, actualTransport) {\r\n    return !requestedTransport || ((actualTransport & requestedTransport) !== 0);\r\n}\r\n/** @private */\r\nexport class TransportSendQueue {\r\n    constructor(_transport) {\r\n        this._transport = _transport;\r\n        this._buffer = [];\r\n        this._executing = true;\r\n        this._sendBufferedData = new PromiseSource();\r\n        this._transportResult = new PromiseSource();\r\n        this._sendLoopPromise = this._sendLoop();\r\n    }\r\n    send(data) {\r\n        this._bufferData(data);\r\n        if (!this._transportResult) {\r\n            this._transportResult = new PromiseSource();\r\n        }\r\n        return this._transportResult.promise;\r\n    }\r\n    stop() {\r\n        this._executing = false;\r\n        this._sendBufferedData.resolve();\r\n        return this._sendLoopPromise;\r\n    }\r\n    _bufferData(data) {\r\n        if (this._buffer.length && typeof (this._buffer[0]) !== typeof (data)) {\r\n            throw new Error(`Expected data to be of type ${typeof (this._buffer)} but was of type ${typeof (data)}`);\r\n        }\r\n        this._buffer.push(data);\r\n        this._sendBufferedData.resolve();\r\n    }\r\n    async _sendLoop() {\r\n        while (true) {\r\n            await this._sendBufferedData.promise;\r\n            if (!this._executing) {\r\n                if (this._transportResult) {\r\n                    this._transportResult.reject(\"Connection stopped.\");\r\n                }\r\n                break;\r\n            }\r\n            this._sendBufferedData = new PromiseSource();\r\n            const transportResult = this._transportResult;\r\n            this._transportResult = undefined;\r\n            const data = typeof (this._buffer[0]) === \"string\" ?\r\n                this._buffer.join(\"\") :\r\n                TransportSendQueue._concatBuffers(this._buffer);\r\n            this._buffer.length = 0;\r\n            try {\r\n                await this._transport.send(data);\r\n                transportResult.resolve();\r\n            }\r\n            catch (error) {\r\n                transportResult.reject(error);\r\n            }\r\n        }\r\n    }\r\n    static _concatBuffers(arrayBuffers) {\r\n        const totalLength = arrayBuffers.map((b) => b.byteLength).reduce((a, b) => a + b);\r\n        const result = new Uint8Array(totalLength);\r\n        let offset = 0;\r\n        for (const item of arrayBuffers) {\r\n            result.set(new Uint8Array(item), offset);\r\n            offset += item.byteLength;\r\n        }\r\n        return result.buffer;\r\n    }\r\n}\r\nclass PromiseSource {\r\n    constructor() {\r\n        this.promise = new Promise((resolve, reject) => [this._resolver, this._rejecter] = [resolve, reject]);\r\n    }\r\n    resolve() {\r\n        this._resolver();\r\n    }\r\n    reject(reason) {\r\n        this._rejecter(reason);\r\n    }\r\n}\r\n//# sourceMappingURL=HttpConnection.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { MessageType } from \"./IHubProtocol\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\nconst JSON_HUB_PROTOCOL_NAME = \"json\";\r\n/** Implements the JSON Hub Protocol. */\r\nexport class JsonHubProtocol {\r\n    constructor() {\r\n        /** @inheritDoc */\r\n        this.name = JSON_HUB_PROTOCOL_NAME;\r\n        /** @inheritDoc */\r\n        this.version = 2;\r\n        /** @inheritDoc */\r\n        this.transferFormat = TransferFormat.Text;\r\n    }\r\n    /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\r\n     *\r\n     * @param {string} input A string containing the serialized representation.\r\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n     */\r\n    parseMessages(input, logger) {\r\n        // The interface does allow \"ArrayBuffer\" to be passed in, but this implementation does not. So let's throw a useful error.\r\n        if (typeof input !== \"string\") {\r\n            throw new Error(\"Invalid input for JSON hub protocol. Expected a string.\");\r\n        }\r\n        if (!input) {\r\n            return [];\r\n        }\r\n        if (logger === null) {\r\n            logger = NullLogger.instance;\r\n        }\r\n        // Parse the messages\r\n        const messages = TextMessageFormat.parse(input);\r\n        const hubMessages = [];\r\n        for (const message of messages) {\r\n            const parsedMessage = JSON.parse(message);\r\n            if (typeof parsedMessage.type !== \"number\") {\r\n                throw new Error(\"Invalid payload.\");\r\n            }\r\n            switch (parsedMessage.type) {\r\n                case MessageType.Invocation:\r\n                    this._isInvocationMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.StreamItem:\r\n                    this._isStreamItemMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Completion:\r\n                    this._isCompletionMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Ping:\r\n                    // Single value, no need to validate\r\n                    break;\r\n                case MessageType.Close:\r\n                    // All optional values, no need to validate\r\n                    break;\r\n                case MessageType.Ack:\r\n                    this._isAckMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Sequence:\r\n                    this._isSequenceMessage(parsedMessage);\r\n                    break;\r\n                default:\r\n                    // Future protocol changes can add message types, old clients can ignore them\r\n                    logger.log(LogLevel.Information, \"Unknown message type '\" + parsedMessage.type + \"' ignored.\");\r\n                    continue;\r\n            }\r\n            hubMessages.push(parsedMessage);\r\n        }\r\n        return hubMessages;\r\n    }\r\n    /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {string} A string containing the serialized representation of the message.\r\n     */\r\n    writeMessage(message) {\r\n        return TextMessageFormat.write(JSON.stringify(message));\r\n    }\r\n    _isInvocationMessage(message) {\r\n        this._assertNotEmptyString(message.target, \"Invalid payload for Invocation message.\");\r\n        if (message.invocationId !== undefined) {\r\n            this._assertNotEmptyString(message.invocationId, \"Invalid payload for Invocation message.\");\r\n        }\r\n    }\r\n    _isStreamItemMessage(message) {\r\n        this._assertNotEmptyString(message.invocationId, \"Invalid payload for StreamItem message.\");\r\n        if (message.item === undefined) {\r\n            throw new Error(\"Invalid payload for StreamItem message.\");\r\n        }\r\n    }\r\n    _isCompletionMessage(message) {\r\n        if (message.result && message.error) {\r\n            throw new Error(\"Invalid payload for Completion message.\");\r\n        }\r\n        if (!message.result && message.error) {\r\n            this._assertNotEmptyString(message.error, \"Invalid payload for Completion message.\");\r\n        }\r\n        this._assertNotEmptyString(message.invocationId, \"Invalid payload for Completion message.\");\r\n    }\r\n    _isAckMessage(message) {\r\n        if (typeof message.sequenceId !== 'number') {\r\n            throw new Error(\"Invalid SequenceId for Ack message.\");\r\n        }\r\n    }\r\n    _isSequenceMessage(message) {\r\n        if (typeof message.sequenceId !== 'number') {\r\n            throw new Error(\"Invalid SequenceId for Sequence message.\");\r\n        }\r\n    }\r\n    _assertNotEmptyString(value, errorMessage) {\r\n        if (typeof value !== \"string\" || value === \"\") {\r\n            throw new Error(errorMessage);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=JsonHubProtocol.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { DefaultReconnectPolicy } from \"./DefaultReconnectPolicy\";\r\nimport { HttpConnection } from \"./HttpConnection\";\r\nimport { HubConnection } from \"./HubConnection\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { JsonHubProtocol } from \"./JsonHubProtocol\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { Arg, ConsoleLogger } from \"./Utils\";\r\nconst LogLevelNameMapping = {\r\n    trace: LogLevel.Trace,\r\n    debug: LogLevel.Debug,\r\n    info: LogLevel.Information,\r\n    information: LogLevel.Information,\r\n    warn: LogLevel.Warning,\r\n    warning: LogLevel.Warning,\r\n    error: LogLevel.Error,\r\n    critical: LogLevel.Critical,\r\n    none: LogLevel.None,\r\n};\r\nfunction parseLogLevel(name) {\r\n    // Case-insensitive matching via lower-casing\r\n    // Yes, I know case-folding is a complicated problem in Unicode, but we only support\r\n    // the ASCII strings defined in LogLevelNameMapping anyway, so it's fine -anurse.\r\n    const mapping = LogLevelNameMapping[name.toLowerCase()];\r\n    if (typeof mapping !== \"undefined\") {\r\n        return mapping;\r\n    }\r\n    else {\r\n        throw new Error(`Unknown log level: ${name}`);\r\n    }\r\n}\r\n/** A builder for configuring {@link @microsoft/signalr.HubConnection} instances. */\r\nexport class HubConnectionBuilder {\r\n    configureLogging(logging) {\r\n        Arg.isRequired(logging, \"logging\");\r\n        if (isLogger(logging)) {\r\n            this.logger = logging;\r\n        }\r\n        else if (typeof logging === \"string\") {\r\n            const logLevel = parseLogLevel(logging);\r\n            this.logger = new ConsoleLogger(logLevel);\r\n        }\r\n        else {\r\n            this.logger = new ConsoleLogger(logging);\r\n        }\r\n        return this;\r\n    }\r\n    withUrl(url, transportTypeOrOptions) {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isNotEmpty(url, \"url\");\r\n        this.url = url;\r\n        // Flow-typing knows where it's at. Since HttpTransportType is a number and IHttpConnectionOptions is guaranteed\r\n        // to be an object, we know (as does TypeScript) this comparison is all we need to figure out which overload was called.\r\n        if (typeof transportTypeOrOptions === \"object\") {\r\n            this.httpConnectionOptions = { ...this.httpConnectionOptions, ...transportTypeOrOptions };\r\n        }\r\n        else {\r\n            this.httpConnectionOptions = {\r\n                ...this.httpConnectionOptions,\r\n                transport: transportTypeOrOptions,\r\n            };\r\n        }\r\n        return this;\r\n    }\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified Hub Protocol.\r\n     *\r\n     * @param {IHubProtocol} protocol The {@link @microsoft/signalr.IHubProtocol} implementation to use.\r\n     */\r\n    withHubProtocol(protocol) {\r\n        Arg.isRequired(protocol, \"protocol\");\r\n        this.protocol = protocol;\r\n        return this;\r\n    }\r\n    withAutomaticReconnect(retryDelaysOrReconnectPolicy) {\r\n        if (this.reconnectPolicy) {\r\n            throw new Error(\"A reconnectPolicy has already been set.\");\r\n        }\r\n        if (!retryDelaysOrReconnectPolicy) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy();\r\n        }\r\n        else if (Array.isArray(retryDelaysOrReconnectPolicy)) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy(retryDelaysOrReconnectPolicy);\r\n        }\r\n        else {\r\n            this.reconnectPolicy = retryDelaysOrReconnectPolicy;\r\n        }\r\n        return this;\r\n    }\r\n    /** Configures {@link @microsoft/signalr.HubConnection.serverTimeoutInMilliseconds} for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    withServerTimeout(milliseconds) {\r\n        Arg.isRequired(milliseconds, \"milliseconds\");\r\n        this._serverTimeoutInMilliseconds = milliseconds;\r\n        return this;\r\n    }\r\n    /** Configures {@link @microsoft/signalr.HubConnection.keepAliveIntervalInMilliseconds} for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    withKeepAliveInterval(milliseconds) {\r\n        Arg.isRequired(milliseconds, \"milliseconds\");\r\n        this._keepAliveIntervalInMilliseconds = milliseconds;\r\n        return this;\r\n    }\r\n    /** Enables and configures options for the Stateful Reconnect feature.\r\n     *\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    withStatefulReconnect(options) {\r\n        if (this.httpConnectionOptions === undefined) {\r\n            this.httpConnectionOptions = {};\r\n        }\r\n        this.httpConnectionOptions._useStatefulReconnect = true;\r\n        this._statefulReconnectBufferSize = options === null || options === void 0 ? void 0 : options.bufferSize;\r\n        return this;\r\n    }\r\n    /** Creates a {@link @microsoft/signalr.HubConnection} from the configuration options specified in this builder.\r\n     *\r\n     * @returns {HubConnection} The configured {@link @microsoft/signalr.HubConnection}.\r\n     */\r\n    build() {\r\n        // If httpConnectionOptions has a logger, use it. Otherwise, override it with the one\r\n        // provided to configureLogger\r\n        const httpConnectionOptions = this.httpConnectionOptions || {};\r\n        // If it's 'null', the user **explicitly** asked for null, don't mess with it.\r\n        if (httpConnectionOptions.logger === undefined) {\r\n            // If our logger is undefined or null, that's OK, the HttpConnection constructor will handle it.\r\n            httpConnectionOptions.logger = this.logger;\r\n        }\r\n        // Now create the connection\r\n        if (!this.url) {\r\n            throw new Error(\"The 'HubConnectionBuilder.withUrl' method must be called before building the connection.\");\r\n        }\r\n        const connection = new HttpConnection(this.url, httpConnectionOptions);\r\n        return HubConnection.create(connection, this.logger || NullLogger.instance, this.protocol || new JsonHubProtocol(), this.reconnectPolicy, this._serverTimeoutInMilliseconds, this._keepAliveIntervalInMilliseconds, this._statefulReconnectBufferSize);\r\n    }\r\n}\r\nfunction isLogger(logger) {\r\n    return logger.log !== undefined;\r\n}\r\n//# sourceMappingURL=HubConnectionBuilder.js.map","import { defineStore } from 'pinia'\nimport { ref, computed } from 'vue'\nimport * as signalR from '@microsoft/signalr'\nimport type { RealTimeEvent } from '@/types/api'\n\ntype EventHandler = (event: RealTimeEvent) => void\n\nexport const useRealTimeStore = defineStore('realtime', () => {\n  const connection = ref<signalR.HubConnection | null>(null)\n  const isConnected = ref(false)\n  const connectionState = ref<'Disconnected' | 'Connecting' | 'Connected' | 'Disconnecting' | 'Reconnecting'>('Disconnected')\n  const eventHandlers = ref<Map<string, EventHandler[]>>(new Map())\n\n  const isConnecting = computed(() => \n    connectionState.value === 'Connecting' || connectionState.value === 'Reconnecting'\n  )\n\n  const connect = async () => {\n    if (connection.value && isConnected.value) {\n      return\n    }\n\n    const hubUrl = import.meta.env.VITE_SIGNALR_HUB_URL || 'http://localhost:5000/hubs/tanks'\n    \n    connection.value = new signalR.HubConnectionBuilder()\n      .withUrl(hubUrl)\n      .withAutomaticReconnect()\n      .build()\n\n    // Connection event handlers\n    connection.value.onclose(() => {\n      isConnected.value = false\n      connectionState.value = 'Disconnected'\n    })\n\n    connection.value.onreconnecting(() => {\n      connectionState.value = 'Reconnecting'\n    })\n\n    connection.value.onreconnected(() => {\n      isConnected.value = true\n      connectionState.value = 'Connected'\n    })\n\n    // Start connection\n    try {\n      connectionState.value = 'Connecting'\n      await connection.value.start()\n      isConnected.value = true\n      connectionState.value = 'Connected'\n\n      // Subscribe to all registered event types\n      eventHandlers.value.forEach((handlers, eventType) => {\n        connection.value?.on(eventType, (data: any) => {\n          const event: RealTimeEvent = {\n            eventType,\n            data,\n            timestamp: new Date().toISOString(),\n            source: 'SignalR'\n          }\n          handlers.forEach(handler => handler(event))\n        })\n      })\n    } catch (error) {\n      console.error('Failed to connect to SignalR hub:', error)\n      connectionState.value = 'Disconnected'\n      throw error\n    }\n  }\n\n  const disconnect = async () => {\n    if (connection.value) {\n      connectionState.value = 'Disconnecting'\n      await connection.value.stop()\n      connection.value = null\n      isConnected.value = false\n      connectionState.value = 'Disconnected'\n    }\n  }\n\n  const subscribe = (eventType: string, handler: EventHandler) => {\n    if (!eventHandlers.value.has(eventType)) {\n      eventHandlers.value.set(eventType, [])\n    }\n    eventHandlers.value.get(eventType)!.push(handler)\n\n    // If already connected, set up the handler immediately\n    if (connection.value && isConnected.value) {\n      connection.value.on(eventType, (data: any) => {\n        const event: RealTimeEvent = {\n          eventType,\n          data,\n          timestamp: new Date().toISOString(),\n          source: 'SignalR'\n        }\n        handler(event)\n      })\n    }\n  }\n\n  const unsubscribe = (eventType: string, handler: EventHandler) => {\n    const handlers = eventHandlers.value.get(eventType)\n    if (handlers) {\n      const index = handlers.indexOf(handler)\n      if (index !== -1) {\n        handlers.splice(index, 1)\n      }\n    }\n  }\n\n  const joinGroup = async (groupName: string) => {\n    if (connection.value && isConnected.value) {\n      await connection.value.invoke('JoinGroup', groupName)\n    }\n  }\n\n  const leaveGroup = async (groupName: string) => {\n    if (connection.value && isConnected.value) {\n      await connection.value.invoke('LeaveGroup', groupName)\n    }\n  }\n\n  return {\n    connection,\n    isConnected,\n    isConnecting,\n    connectionState,\n    connect,\n    disconnect,\n    subscribe,\n    unsubscribe,\n    joinGroup,\n    leaveGroup\n  }\n})\n\n","<template>\n  <div class=\"app-layout\">\n    <el-container>\n      <!-- Sidebar -->\n      <el-aside :width=\"isCollapsed ? '64px' : '240px'\" class=\"app-sidebar\">\n        <div class=\"sidebar-header\">\n          <h1 v-if=\"!isCollapsed\" class=\"app-title\">AquaControl</h1>\n          <el-icon v-else class=\"app-icon\"><Water /></el-icon>\n        </div>\n        \n        <el-menu\n          :default-active=\"activeRoute\"\n          :collapse=\"isCollapsed\"\n          router\n          class=\"sidebar-menu\"\n        >\n          <el-menu-item index=\"/\">\n            <el-icon><Odometer /></el-icon>\n            <template #title>Dashboard</template>\n          </el-menu-item>\n          \n          <el-menu-item index=\"/tanks\">\n            <el-icon><Box /></el-icon>\n            <template #title>Tanks</template>\n          </el-menu-item>\n          \n          <el-menu-item index=\"/sensors\">\n            <el-icon><Cpu /></el-icon>\n            <template #title>Sensors</template>\n          </el-menu-item>\n          \n          <el-menu-item index=\"/analytics\">\n            <el-icon><DataAnalysis /></el-icon>\n            <template #title>Analytics</template>\n          </el-menu-item>\n          \n          <el-menu-item index=\"/settings\">\n            <el-icon><Setting /></el-icon>\n            <template #title>Settings</template>\n          </el-menu-item>\n        </el-menu>\n      </el-aside>\n\n      <!-- Main Content -->\n      <el-container>\n        <!-- Header -->\n        <el-header class=\"app-header\">\n          <div class=\"header-left\">\n            <el-button\n              :icon=\"isCollapsed ? Expand : Fold\"\n              @click=\"toggleSidebar\"\n              text\n            />\n          </div>\n          \n          <div class=\"header-right\">\n            <el-dropdown @command=\"handleCommand\">\n              <span class=\"user-info\">\n                <el-avatar :size=\"32\" :icon=\"UserFilled\" />\n                <span class=\"username\">{{ authStore.user?.username || 'User' }}</span>\n              </span>\n              <template #dropdown>\n                <el-dropdown-menu>\n                  <el-dropdown-item command=\"profile\">\n                    <el-icon><User /></el-icon>\n                    Profile\n                  </el-dropdown-item>\n                  <el-dropdown-item command=\"settings\">\n                    <el-icon><Setting /></el-icon>\n                    Settings\n                  </el-dropdown-item>\n                  <el-dropdown-item divided command=\"logout\">\n                    <el-icon><SwitchButton /></el-icon>\n                    Logout\n                  </el-dropdown-item>\n                </el-dropdown-menu>\n              </template>\n            </el-dropdown>\n          </div>\n        </el-header>\n\n        <!-- Content Area -->\n        <el-main class=\"app-main\">\n          <router-view />\n        </el-main>\n      </el-container>\n    </el-container>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed } from 'vue'\nimport { useRoute, useRouter } from 'vue-router'\nimport { useAuthStore } from '@/stores/authStore'\nimport { useRealTimeStore } from '@/stores/realTimeStore'\nimport {\n  Histogram as Water, Odometer, Box, Cpu, DataAnalysis, Setting,\n  UserFilled, User, SwitchButton, Fold, Expand\n} from '@element-plus/icons-vue'\n\nconst route = useRoute()\nconst router = useRouter()\nconst authStore = useAuthStore()\nconst realTimeStore = useRealTimeStore()\n\nconst isCollapsed = ref(false)\n\nconst activeRoute = computed(() => route.path)\n\nconst toggleSidebar = () => {\n  isCollapsed.value = !isCollapsed.value\n}\n\nconst handleCommand = async (command: string) => {\n  switch (command) {\n    case 'profile':\n      router.push('/profile')\n      break\n    case 'settings':\n      router.push('/settings')\n      break\n    case 'logout':\n      await authStore.logout()\n      await realTimeStore.disconnect()\n      router.push('/login')\n      break\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.app-layout {\n  height: 100vh;\n  width: 100vw;\n  \n  .app-sidebar {\n    background: var(--el-bg-color);\n    border-right: 1px solid var(--el-border-color);\n    transition: width 0.3s;\n    \n    .sidebar-header {\n      height: 60px;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      border-bottom: 1px solid var(--el-border-color);\n      \n      .app-title {\n        margin: 0;\n        font-size: 20px;\n        font-weight: 600;\n        color: var(--el-text-color-primary);\n      }\n      \n      .app-icon {\n        font-size: 24px;\n        color: var(--el-color-primary);\n      }\n    }\n    \n    .sidebar-menu {\n      border-right: none;\n      height: calc(100vh - 60px);\n    }\n  }\n  \n  .app-header {\n    background: var(--el-bg-color);\n    border-bottom: 1px solid var(--el-border-color);\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    padding: 0 24px;\n    \n    .header-left {\n      display: flex;\n      align-items: center;\n    }\n    \n    .header-right {\n      .user-info {\n        display: flex;\n        align-items: center;\n        gap: 8px;\n        cursor: pointer;\n        \n        .username {\n          font-size: 14px;\n          color: var(--el-text-color-primary);\n        }\n      }\n    }\n  }\n  \n  .app-main {\n    background: var(--el-bg-color-page);\n    padding: 24px;\n    overflow-y: auto;\n  }\n}\n</style>\n\n","<template>\n  <div class=\"login-view\">\n    <el-card class=\"login-card\">\n      <template #header>\n        <div class=\"login-header\">\n          <h2>AquaControl Platform</h2>\n          <p>Sign in to your account</p>\n        </div>\n      </template>\n\n      <el-form\n        ref=\"loginFormRef\"\n        :model=\"loginForm\"\n        :rules=\"loginRules\"\n        @submit.prevent=\"handleLogin\"\n      >\n        <el-form-item prop=\"username\">\n          <el-input\n            v-model=\"loginForm.username\"\n            placeholder=\"Username\"\n            :prefix-icon=\"User\"\n            size=\"large\"\n          />\n        </el-form-item>\n\n        <el-form-item prop=\"password\">\n          <el-input\n            v-model=\"loginForm.password\"\n            type=\"password\"\n            placeholder=\"Password\"\n            :prefix-icon=\"Lock\"\n            size=\"large\"\n            show-password\n            @keyup.enter=\"handleLogin\"\n          />\n        </el-form-item>\n\n        <el-form-item>\n          <el-button\n            type=\"primary\"\n            size=\"large\"\n            :loading=\"isLoading\"\n            @click=\"handleLogin\"\n            style=\"width: 100%\"\n          >\n            Sign In\n          </el-button>\n        </el-form-item>\n      </el-form>\n    </el-card>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref } from 'vue'\nimport { useRouter } from 'vue-router'\nimport { useAuthStore } from '@/stores/authStore'\nimport { ElMessage, type FormInstance, type FormRules } from 'element-plus'\nimport { User, Lock } from '@element-plus/icons-vue'\n\nconst router = useRouter()\nconst authStore = useAuthStore()\n\nconst loginFormRef = ref<FormInstance>()\nconst isLoading = ref(false)\n\nconst loginForm = ref({\n  username: '',\n  password: ''\n})\n\nconst loginRules: FormRules = {\n  username: [\n    { required: true, message: 'Please enter username', trigger: 'blur' }\n  ],\n  password: [\n    { required: true, message: 'Please enter password', trigger: 'blur' },\n    { min: 6, message: 'Password must be at least 6 characters', trigger: 'blur' }\n  ]\n}\n\nconst handleLogin = async () => {\n  if (!loginFormRef.value) return\n\n  await loginFormRef.value.validate(async (valid) => {\n    if (valid) {\n      isLoading.value = true\n      try {\n        await authStore.login({\n          username: loginForm.value.username,\n          password: loginForm.value.password\n        })\n        \n        ElMessage.success('Login successful')\n        router.push('/')\n      } catch (error: any) {\n        ElMessage.error(error.message || 'Login failed')\n      } finally {\n        isLoading.value = false\n      }\n    }\n  })\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.login-view {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 100vh;\n  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n  \n  .login-card {\n    width: 400px;\n    \n    .login-header {\n      text-align: center;\n      \n      h2 {\n        margin: 0 0 8px 0;\n        color: var(--el-text-color-primary);\n      }\n      \n      p {\n        margin: 0;\n        color: var(--el-text-color-regular);\n        font-size: 14px;\n      }\n    }\n  }\n}\n</style>\n\n","<template>\n  <div class=\"notification-container\">\n    <transition-group name=\"notification\" tag=\"div\">\n      <el-notification\n        v-for=\"notification in notifications\"\n        :key=\"notification.id\"\n        :title=\"notification.title\"\n        :message=\"notification.message\"\n        :type=\"notification.type\"\n        :duration=\"notification.duration || 4500\"\n        :show-close=\"true\"\n        @close=\"removeNotification(notification.id)\"\n        class=\"notification-item\"\n      />\n    </transition-group>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { useNotificationStore } from '@/stores/notificationStore'\n\nconst notificationStore = useNotificationStore()\n\nconst notifications = computed(() => notificationStore.notifications)\n\nconst removeNotification = (id: string) => {\n  notificationStore.removeNotification(id)\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.notification-container {\n  position: fixed;\n  top: 20px;\n  right: 20px;\n  z-index: 3000;\n}\n\n.notification-enter-active,\n.notification-leave-active {\n  transition: all 0.3s ease;\n}\n\n.notification-enter-from {\n  opacity: 0;\n  transform: translateX(100%);\n}\n\n.notification-leave-to {\n  opacity: 0;\n  transform: translateX(100%);\n}\n</style>\n\n","<template>\n  <el-tooltip\n    :content=\"tooltipText\"\n    placement=\"left\"\n  >\n    <div\n      class=\"connection-status\"\n      :class=\"statusClass\"\n      @click=\"handleReconnect\"\n    >\n      <el-icon>\n        <component :is=\"statusIcon\" />\n      </el-icon>\n    </div>\n  </el-tooltip>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { useRealTimeStore } from '@/stores/realTimeStore'\nimport { Connection, Close, Refresh } from '@element-plus/icons-vue'\n\nconst realTimeStore = useRealTimeStore()\n\nconst statusClass = computed(() => {\n  if (realTimeStore.isConnected) return 'connected'\n  if (realTimeStore.isConnecting) return 'connecting'\n  return 'disconnected'\n})\n\nconst statusIcon = computed(() => {\n  if (realTimeStore.isConnected) return Connection\n  if (realTimeStore.isConnecting) return Refresh\n  return Close\n})\n\nconst tooltipText = computed(() => {\n  if (realTimeStore.isConnected) return 'Real-time connection active'\n  if (realTimeStore.isConnecting) return 'Connecting...'\n  return 'Real-time connection lost. Click to reconnect.'\n})\n\nconst handleReconnect = async () => {\n  if (!realTimeStore.isConnected && !realTimeStore.isConnecting) {\n    await realTimeStore.connect()\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.connection-status {\n  position: fixed;\n  bottom: 20px;\n  right: 20px;\n  width: 40px;\n  height: 40px;\n  border-radius: 50%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  z-index: 2000;\n  transition: all 0.3s ease;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);\n  \n  &.connected {\n    background: var(--el-color-success);\n    color: white;\n    \n    &:hover {\n      transform: scale(1.1);\n    }\n  }\n  \n  &.connecting {\n    background: var(--el-color-warning);\n    color: white;\n    animation: pulse 1.5s infinite;\n  }\n  \n  &.disconnected {\n    background: var(--el-color-danger);\n    color: white;\n    \n    &:hover {\n      transform: scale(1.1);\n    }\n  }\n}\n\n@keyframes pulse {\n  0%, 100% {\n    opacity: 1;\n  }\n  50% {\n    opacity: 0.5;\n  }\n}\n</style>\n\n","<template>\n  <div id=\"app\" class=\"aqua-app\">\n    <!-- Loading overlay -->\n    <div v-if=\"isInitializing\" class=\"loading-overlay\">\n      <el-loading-service />\n    </div>\n\n    <!-- Main application -->\n    <template v-else>\n      <!-- Authentication wrapper -->\n      <template v-if=\"authStore.isAuthenticated\">\n        <AppLayout>\n          <router-view />\n        </AppLayout>\n      </template>\n      \n      <!-- Login page -->\n      <template v-else>\n        <LoginView />\n      </template>\n    </template>\n\n    <!-- Global notifications -->\n    <NotificationContainer />\n    \n    <!-- Real-time connection status -->\n    <ConnectionStatus />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, onMounted, provide } from 'vue'\nimport { useAuthStore } from '@/stores/authStore'\nimport { useRealTimeStore } from '@/stores/realTimeStore'\nimport { useNotificationStore } from '@/stores/notificationStore'\nimport AppLayout from '@/components/layout/AppLayout.vue'\nimport LoginView from '@/views/auth/LoginView.vue'\nimport NotificationContainer from '@/components/common/NotificationContainer.vue'\nimport ConnectionStatus from '@/components/common/ConnectionStatus.vue'\n\n// Stores\nconst authStore = useAuthStore()\nconst realTimeStore = useRealTimeStore()\nconst notificationStore = useNotificationStore()\n\n// State\nconst isInitializing = ref(true)\n\n// Provide global services\nprovide('notificationService', notificationStore)\n\n// Initialize application\nonMounted(async () => {\n  try {\n    // Initialize authentication\n    await authStore.initialize()\n    \n    // Initialize real-time connection if authenticated\n    if (authStore.isAuthenticated) {\n      await realTimeStore.connect()\n    }\n    \n    // Setup global error handling\n    window.addEventListener('unhandledrejection', (event) => {\n      console.error('Unhandled promise rejection:', event.reason)\n      notificationStore.addNotification({\n        type: 'error',\n        title: 'Application Error',\n        message: 'An unexpected error occurred. Please refresh the page.'\n      })\n    })\n    \n  } catch (error) {\n    console.error('Failed to initialize application:', error)\n    notificationStore.addNotification({\n      type: 'error',\n      title: 'Initialization Failed',\n      message: 'Failed to initialize the application. Please refresh the page.'\n    })\n  } finally {\n    isInitializing.value = false\n  }\n})\n</script>\n\n<style lang=\"scss\">\n.aqua-app {\n  height: 100vh;\n  width: 100vw;\n  overflow: hidden;\n}\n\n.loading-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: rgba(255, 255, 255, 0.9);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  z-index: 9999;\n}\n</style>\n","import { createRouter, createWebHistory } from 'vue-router'\nimport { useAuthStore } from '@/stores/authStore'\nimport type { RouteRecordRaw } from 'vue-router'\n\n// Lazy load components\nconst DashboardView = () => import('@/views/dashboard/DashboardView.vue')\nconst TanksView = () => import('@/views/TankList.vue')\nconst TankDetailView = () => import('@/views/TankDetail.vue')\nconst SensorsView = () => import('@/views/sensor/SensorsView.vue')\nconst AnalyticsView = () => import('@/views/analytics/AnalyticsView.vue')\nconst SettingsView = () => import('@/views/settings/SettingsView.vue')\nconst NotFoundView = () => import('@/views/common/NotFoundView.vue')\n\nconst routes: RouteRecordRaw[] = [\n  {\n    path: '/',\n    name: 'Dashboard',\n    component: DashboardView,\n    meta: { requiresAuth: true, title: 'Dashboard' }\n  },\n  {\n    path: '/tanks',\n    name: 'Tanks',\n    component: TanksView,\n    meta: { requiresAuth: true, title: 'Tanks' }\n  },\n  {\n    path: '/tanks/:id',\n    name: 'TankDetail',\n    component: TankDetailView,\n    meta: { requiresAuth: true, title: 'Tank Details' },\n    props: true\n  },\n  {\n    path: '/sensors',\n    name: 'Sensors',\n    component: SensorsView,\n    meta: { requiresAuth: true, title: 'Sensors' }\n  },\n  {\n    path: '/analytics',\n    name: 'Analytics',\n    component: AnalyticsView,\n    meta: { requiresAuth: true, title: 'Analytics' }\n  },\n  {\n    path: '/settings',\n    name: 'Settings',\n    component: SettingsView,\n    meta: { requiresAuth: true, title: 'Settings' }\n  },\n  {\n    path: '/:pathMatch(.*)*',\n    name: 'NotFound',\n    component: NotFoundView,\n    meta: { title: 'Page Not Found' }\n  }\n]\n\nconst router = createRouter({\n  history: createWebHistory(import.meta.env.BASE_URL),\n  routes,\n  scrollBehavior(_to, _from, savedPosition) {\n    if (savedPosition) {\n      return savedPosition\n    } else {\n      return { top: 0 }\n    }\n  }\n})\n\n// Navigation guards\nrouter.beforeEach(async (_to, _from, next) => {\n  const authStore = useAuthStore()\n  \n  // Set page title\n  document.title = _to.meta.title ? `${_to.meta.title} - AquaControl` : 'AquaControl'\n  \n  // Check authentication\n  if (_to.meta.requiresAuth && !authStore.isAuthenticated) {\n    // Redirect to login (will be handled by App.vue)\n    next({ name: 'Dashboard' })\n    return\n  }\n  \n  // Check if user is authenticated but trying to access login\n  if (_to.name === 'Login' && authStore.isAuthenticated) {\n    next({ name: 'Dashboard' })\n    return\n  }\n  \n  next()\n})\n\nexport default router\n","import { createApp } from 'vue'\nimport { createPinia } from 'pinia'\nimport piniaPluginPersistedstate from 'pinia-plugin-persistedstate'\nimport ElementPlus from 'element-plus'\nimport 'element-plus/dist/index.css'\nimport * as ElementPlusIconsVue from '@element-plus/icons-vue'\n\nimport App from './App.vue'\nimport router from './router'\n\n// Create app\nconst app = createApp(App)\n\n// Create pinia store\nconst pinia = createPinia()\npinia.use(piniaPluginPersistedstate)\n\n// Use plugins\napp.use(pinia)\napp.use(router)\napp.use(ElementPlus)\n\n// Register Element Plus icons\nfor (const [key, component] of Object.entries(ElementPlusIconsVue)) {\n  app.component(key, component)\n}\n\n// Global error handler\napp.config.errorHandler = (err, _instance, info) => {\n  console.error('Global error:', err, info)\n  // Send to error reporting service\n}\n\n// Mount app\napp.mount('#app')\n"],"file":"assets/index-BgEO1XDn.js"}